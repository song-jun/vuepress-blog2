<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://songjun520.cn/vuepress-blog2/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Mr.Song</title>
    <link>https://songjun520.cn/vuepress-blog2/</link>
    <description>君陌离的博客，君陌离，君陌离的小跟班，小跟班</description>
    <language>zh-CN</language>
    <pubDate>Fri, 26 Aug 2022 09:47:06 GMT</pubDate>
    <lastBuildDate>Fri, 26 Aug 2022 09:47:06 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Linux</category>
    <category>基础</category>
    <category>随笔</category>
    <category>笔记</category>
    <category>软件</category>
    <category>服务器</category>
    <category>GitHub</category>
    <category>教程</category>
    <category>小程序</category>
    <category>Node.js</category>
    <category>前端</category>
    <category>Vue</category>
    <category>JavaScript</category>
    <category>GIT</category>
    <category>CSS</category>
    <item>
      <title>Mr.Song 介绍</title>
      <link>https://songjun520.cn/vuepress-blog2/about/</link>
      <guid>https://songjun520.cn/vuepress-blog2/about/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Mr.Song 介绍</source>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<i>Content not supported</i>]]></content:encoded>
      <enclosure url="https://songjun520.cn/vuepress-blog2/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>代码笔记</title>
      <link>https://songjun520.cn/vuepress-blog2/code/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">代码笔记</source>
      <description>此处是 Mr.Song 存放的一些代码笔记。
</description>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>此处是 Mr.Song 存放的一些代码笔记。</p>

<h2 id="目录" tabindex="-1"> 目录</h2>
<h3 id="基础" tabindex="-1"> 基础</h3>
<ul>
<li>
<p><a href="/code/windows/">Windows 基础</a></p>
</li>
<li>
<p><a href="/code/github/">GitHub 介绍</a></p>
</li>
</ul>
<h3 id="前端开发" tabindex="-1"> 前端开发</h3>
<ul>
<li>
<p><a href="/code/website/">网站相关</a></p>
</li>
<li>
<p><a href="/code/vue/">Vue 相关</a></p>
</li>
<li>
<p><a href="/code/mini-app/">小程序教程</a></p>
</li>
<li>
<p><a href="/code/node-js/">Node.js</a></p>
</li>
</ul>
<h3 id="代码学习" tabindex="-1"> 代码学习</h3>
<ul>
<li>
<p><a href="/code/language/">代码学习</a></p>
</li>
<li>
<p><a href="/code/language/learning.html">如何学习一门语言</a></p>
</li>
<li>
<p><a href="/code/language/js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/python/">Python 教程</a> (编写中...)</p>
</li>
<li>
<p><a href="/code/language/markdown/">Markdown 教程</a></p>
</li>
<li>
<p><a href="/code/language/yaml/">YAML 教程</a></p>
</li>
<li>
<p><a href="/code/language/json/">JSON 教程</a></p>
</li>
</ul>
<h3 id="代码学习网站" tabindex="-1"> 代码学习网站</h3>
<h3 id="优质网站" tabindex="-1"> 优质网站</h3>
<ul>
<li>
<p><a href="https://wangdoc.com/" target="_blank" rel="noopener noreferrer">网道</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener noreferrer">廖雪峰的网站</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div><p>相关信息</p>
<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>
</div>
</li>
</ul>
<h3 id="杂牌网站" tabindex="-1"> 杂牌网站</h3>
<ul>
<li>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn" target="_blank" rel="noopener noreferrer">w3cschool</a> <i>Content not supported</i> <i>Content not supported</i> <i>Content not supported</i></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener noreferrer">w3school</a> <i>Content not supported</i></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>联系方式</title>
      <link>https://songjun520.cn/vuepress-blog2/innerpage/about.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/innerpage/about.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">联系方式</source>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>欢迎各位朋友一起交流合作</p>
<hr>
<p align='left'><span face='STCAIYUN' size='5' cloor=salmon>微信：********</span></p>
<p align='left'><span face='STCAIYUN' size='5'>QQ：289097246</span></p>
<p align='left'><span face='STCAIYUN' size='5'>邮箱：289097246@qq.com</span></p>
<hr>
<p align='right'><span color='#999' size='3' face="STCAIYUN">注：联系请备注来意，谢谢</span></p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>赞赏</title>
      <link>https://songjun520.cn/vuepress-blog2/innerpage/sponsor.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/innerpage/sponsor.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">赞赏</source>
      <pubDate>Sat, 20 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="联系方式" tabindex="-1"> 联系方式</h2>
<ul>
<li>QQ方式</li>
</ul>

<div class='img-q'>
  <img src="/assets/img/QQ.png" alt="">
</div>
<h2 id="赞赏" tabindex="-1"> 赞赏</h2>
<ul>
<li>
<p>亲的赞赏，犹如滔滔江水，连绵不绝！</p>
<div class='img-box'>
  <img src="/assets/img/zfb.jpg" alt="">
  <img src="/assets/img/zs.jpg" alt="">
  <img src="/assets/img/wx.jpg" alt="">
</div>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>作品展示</title>
      <link>https://songjun520.cn/vuepress-blog2/innerpage/works.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/innerpage/works.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">作品展示</source>
      <pubDate>Mon, 15 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>本人郑重做出以下承诺：</p>
<ol>
<li>每个项目均由本人独立开发或参与开发作品，绝无虚假</li>
<li>部分项目在公司内部上线，为保护公司隐私仅展示部分截图或描述</li>
<li>如上线项目涉及某公司隐私，请联系博主删除下线</li>
</ol>
</div>
<br>
<br>
<pro-show></pro-show>
]]></content:encoded>
    </item>
    <item>
      <title>Linux</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="linux-教程" tabindex="-1"> Linux 教程</h2>
<ul>
<li>
<p><a href="/linux/intro/">Linux 介绍</a></p>
<ul>
<li>
<p><a href="/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/linux/file/">Linux 文件</a></p>
<ul>
<li>
<p><a href="/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="/linux/file/mount.html">挂载</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/linux/command/">Linux 命令</a></p>
<ul>
<li>
<p><a href="/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="ubuntu" tabindex="-1"> ubuntu</h2>
<ul>
<li><a href="/linux/ubuntu/">点击前往</a></li>
</ul>
<h2 id="centos" tabindex="-1"> CentOS</h2>
<ul>
<li><a href="/linux/centos.html">点击前往</a></li>
</ul>
<h2 id="wsl" tabindex="-1"> WSL</h2>
<ul>
<li><a href="/linux/WSL.html">点击前往</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>WSL</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/WSL.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/WSL.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">WSL</source>
      <description>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。
</description>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>

<h2 id="ubuntu" tabindex="-1"> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2 id="wsl-文件位置" tabindex="-1"> WSL 文件位置</h2>
<div><pre><code>C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="重启-wsl" tabindex="-1"> 重启 WSL</h2>
<p>使用</p>
<div><pre><code>net stop LxssManager
</code></pre><div aria-hidden="true"><div></div></div></div><p>和</p>
<div><pre><code>net start LxssManager
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CentOS 教程</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/centos.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/centos.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">CentOS 教程</source>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="管理工具" tabindex="-1"> 管理工具</h2>
<ul>
<li>yum (Centos 7)</li>
<li>dnf (Centos 8)</li>
</ul>
<h2 id="yarn" tabindex="-1"> yarn</h2>
<div><pre><code><span>curl</span> --silent --location https://dl.yarnpkg.com/rpm/yarn.repo <span>|</span> <span>sudo</span> <span>tee</span> /etc/yum.repos.d/yarn.repo

<span>sudo</span> yum <span>install</span> <span>yarn</span>
<span>## OR ##</span>
<span>sudo</span> dnf <span>install</span> <span>yarn</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ssh</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/ssh.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/ssh.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">ssh</source>
      <category>基础</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用密码登录" tabindex="-1"> 使用密码登录</h2>
<ol>
<li>
<p>执行以下命令，连接 Linux 云服务器。</p>
<div><pre><code><span>ssh</span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
</li>
<li>
<p>输入已获取的密码，按 Enter，即可完成登录。</p>
</li>
</ol>
<h2 id="使用密钥登录" tabindex="-1"> 使用密钥登录</h2>
<ol>
<li>
<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>
<div><pre><code><span>chmod</span> <span>400</span> <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>执行以下命令，进行远程登录。</p>
<div><pre><code><span>ssh</span> -i <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
<p>例如，执行 <code>ssh -i &quot;id_rsa&quot; ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>
</li>
</ol>
<h2 id="断开链接" tabindex="-1"> 断开链接</h2>
<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Mr.Song 的随笔</title>
      <link>https://songjun520.cn/vuepress-blog2/note/</link>
      <guid>https://songjun520.cn/vuepress-blog2/note/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Mr.Song 的随笔</source>
      <category>随笔</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里是 Mr.Song 的一些随笔，后续被整理进博客中。</p>
<h2 id="node-js-相关" tabindex="-1"> Node.js 相关</h2>
<ul>
<li><a href="/note/node-js/current-path.html">current-path 相关</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Mr.Song 的笔记</title>
      <link>https://songjun520.cn/vuepress-blog2/other/</link>
      <guid>https://songjun520.cn/vuepress-blog2/other/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Mr.Song 的笔记</source>
      <category>笔记</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里是 Mr.Song 的一些随笔，后续被整理进博客中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Chrome</title>
      <link>https://songjun520.cn/vuepress-blog2/software/chrome.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/software/chrome.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Chrome</source>
      <description>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。
</description>
      <category>软件</category>
      <pubDate>Fri, 13 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Chrome 如今可以说是一家独大。很多国内浏览器都是基于 Chromium 内核的套壳浏览器。</p>
<p>Chrome 内核更新频繁，速度和安全性高，对新特性支持非常良好。另外谷歌具有十分强大的开发者工具，是前端开发使用的首选浏览器。目前最新的版本是 85。</p>
<h2 id="配置" tabindex="-1"> 配置</h2>
<p>由于 Chrome 是谷歌出品的浏览器，所以搜索栏默认使用 Google 搜索，而在中国无法访问 Google 服务，所以需要在右上角的菜单中选择设置，在搜索引擎设置中改为百度即可正常使用。</p>
<p><img src="@source/software/assets/searchEngine.png" alt="更改页面"></p>
<h2 id="快捷键" tabindex="-1"> 快捷键</h2>
<p>Chrome 具有很多快捷键，熟练掌握后可以大幅减少时间。</p>
<ul>
<li><code>Ctrl + J</code>: 打开下载页面；</li>
<li><code>Ctrl + H</code>: 打开历史页面；</li>
<li><code>Ctrl + T</code>: 打开新标签页；</li>
<li><code>Ctrl + Shift + T</code>: 恢复上一个关闭的标签页；</li>
<li><code>Ctrl + N</code>: 打开新的窗口；</li>
<li><code>Ctrl + W</code>: 关闭当前标签页；</li>
<li><code>Ctrl + Tab</code>: 切换标签页；</li>
<li><code>Ctrl + Shift + Tab</code>: 反向切换标签页；</li>
<li><code>Ctrl + F</code>: 反向切换标签页；</li>
<li><code>Ctrl + Shift + I</code> 或 <code>F12</code>: 打开开发者工具；</li>
</ul>
<h2 id="开发者工具" tabindex="-1"> 开发者工具</h2>
<p><img src="@source/software/assets/devTool.png" alt="开发者工具"></p>
<p>使用 <code>Ctrl + Shift + I</code> 或 <code>F12</code> 即可打开开发者工具，在开发者工具里，您可以自由的对任何网页进行调试。</p>
<h2 id="chrome-推荐扩展" tabindex="-1"> Chrome 推荐扩展</h2>
<ul>
<li>AdGuard: 广告屏蔽；</li>
<li>Adobe Acrobat: 将当前网页转为 Adobe PDF 文件；</li>
<li>Betternet Unlimited Free VPN Proxy: 免费的 VPN 代理；</li>
<li>Checker Plus for Gmail™: Gmail 邮件管理；</li>
<li>Convertio: 非常强大的文件在线转换；</li>
<li>Dark Reader: 为网页启用夜间模式；</li>
<li>Enhanced GitHub: 能够展示仓库大小，文件大小和快速下载按钮；</li>
<li>Evernote Web Clipper: 印象笔记剪藏，非常好用的保存工具；</li>
<li>Google 翻译: 谷歌翻译软件；</li>
<li>ImTranslator: 翻译，字典，声音</li>
<li>Infinity: 一款非常好的标签页软件；</li>
<li>Office Online: 在线查看并编辑 Office 文件；</li>
<li>React Developer Tools: React 开发者工具</li>
<li>Save to Pocket: 离线网页的最佳插件；</li>
<li>VPN Free - Betternet Unlimited VPN Proxy: 一款免费的 VPN 插件；</li>
<li>Vue.js Devtools: Vue.js 的开发者工具；</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>代码编辑器</title>
      <link>https://songjun520.cn/vuepress-blog2/software/editor.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/software/editor.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">代码编辑器</source>
      <category>软件</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>
<p><a href="/software/vscode/">VS Code</a></p>
<p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。</p>
<p>VS Code 具有最大的编辑器社区，插件是所有编辑器里最全的。可以通过安装扩展实现几乎所有的功能，但扩展设置界面对新手不够友好，适合有一定经验的开发者。</p>
<div><p>提示</p>
<p>推荐使用轻量的 Visual Studio Code。</p>
</div>
</li>
<li>
<p>其他代码编辑器</p>
<p>在不同领域的开发者可能会偏向不同种类的开发工具。下面列举其他常见的代码编辑器。</p>
<ul>
<li>WebStorm 是专业的 web 开发工具，提供格式化、代码补全等选项。</li>
<li>PhpStorm 是专业的 php 开发工具，提供格式化、代码补全等选项。</li>
<li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener noreferrer">notepad++</a></li>
<li><a href="https://atom.io/" target="_blank" rel="noopener noreferrer">atom</a></li>
<li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener noreferrer">sublime text</a></li>
</ul>
</li>
</ul>
<div><p>IDE 与编辑器</p>
<p>IDE 和编辑器是有区别的:</p>
<ul>
<li>
<p>IDE: 对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</p>
</li>
<li>
<p>编辑器: 要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</p>
</li>
</ul>
<p>需要注意的是，VS Code 的定位是编辑器，而非 IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://songjun520.cn/vuepress-blog2/software/nginx.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/software/nginx.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Nginx</source>
      <description>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。
</description>
      <category>服务器</category>
      <pubDate>Fri, 13 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>

<h2 id="启动-停止和重新加载配置" tabindex="-1"> 启动，停止和重新加载配置</h2>
<p>要启动 nginx，请运行可执行文件。一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>
<div><pre><code>nginx -s signal
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中 <code>signal</code> 可能是以下之一:</p>
<ul>
<li>stop - 快速关机</li>
<li>quit — 正常关机</li>
<li>reload — 重新加载配置文件</li>
<li>reopen — 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构" tabindex="-1"> 配置文件的结构</h2>
<p>Nginx 由受配置文件中指定的指令控制的模块组成。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>
<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。<code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>
<p><code>#</code> 号后的其余行被视为注释。</p>
<h2 id="提供静态内容" tabindex="-1"> 提供静态内容</h2>
<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>
<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 <code>index.html</code> 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>
<p>接下来，打开配置文件。默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。现在，注释掉所有这些块并启动一个新的服务器块:</p>
<div><pre><code><span><span>http</span></span> <span>{</span>
  <span><span>server</span></span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>
<p>将以下位置块添加到服务器块:</p>
<div><pre><code><span><span>location</span> /</span> <span>{</span>
  <span><span>root</span> /data/www</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>
<p>接下来，添加第二个位置块:</p>
<div><pre><code><span><span>location</span> /images/</span> <span>{</span>
  <span><span>root</span> /data</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>
<p>服务器块的最终配置应如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>root</span> /data/www</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。如果该文件不存在，nginx 将发送一个注明 404 错误的响应。URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>
<p>要应用新配置，请启动 nginx (如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code> 信号:</p>
<div><pre><code>nginx -s reload
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>
<h2 id="设置简单的代理服务器" tabindex="-1"> 设置简单的代理服务器</h2>
<p>Nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>
<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>
<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>listen</span> <span>8080</span></span><span>;</span>
  <span><span>root</span> /data/up1</span><span>;</span>

  <span><span>location</span> /</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>
<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。修改后的位置块如下所示:</p>
<div><pre><code><span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
  <span><span>root</span> /data/images</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。正则表达式应以 <code>~</code> 开头。相应的请求将被映射到 <code>/ data/images</code> 目录。</p>
<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>
<p>代理服务器的最终配置如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080/</span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>
<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>
<p>还有许多其他指令可用于进一步配置代理连接。</p>
<h2 id="设置-fastcgi-代理" tabindex="-1"> 设置 FastCGI 代理</h2>
<p>Nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>
<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。配置的结果为:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>fastcgi_pass</span>  localhost:9000</span><span>;</span>
    <span><span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
    <span><span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span></span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://docs.nginx.com/nginx/admin-guide/" target="_blank" rel="noopener noreferrer">点击此处</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Postman</title>
      <link>https://songjun520.cn/vuepress-blog2/software/postman.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/software/postman.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Postman</source>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="postman" tabindex="-1"> Postman</h1>
<p>Postman 是一个强大的抓包与网络调试工具。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">GitHub</source>
      <category>GitHub</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="快速上手" tabindex="-1"> 快速上手</h2>
<ul>
<li>
<p><a href="/code/github/intro.html">GitHub 介绍</a></p>
</li>
<li>
<p><a href="/code/github/pr.html">Pull Request</a></p>
</li>
<li>
<p><a href="/code/github/semantic.html">语义化提交</a></p>
</li>
<li>
<p><a href="/code/github/pages.html">GitHub Pages</a></p>
</li>
<li>
<p><a href="/code/github/speedup.html">利用 Gitee 加速 GitHub 克隆</a></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github" target="_blank" rel="noopener noreferrer">全部文档</a></li>
</ul>
<h3 id="入门指南" tabindex="-1"> 入门指南</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="快速入门" tabindex="-1"> 快速入门</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/set-up-git" target="_blank" rel="noopener noreferrer">设置 Git</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/create-a-repo" target="_blank" rel="noopener noreferrer">创建仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/fork-a-repo" target="_blank" rel="noopener noreferrer">复刻仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/be-social" target="_blank" rel="noopener noreferrer">社交化</a></li>
</ul>
<h3 id="了解-github" tabindex="-1"> 了解 GitHub</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/types-of-github-accounts" target="_blank" rel="noopener noreferrer">账户类型</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/access-permissions-on-github#%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7" target="_blank" rel="noopener noreferrer">GitHub 上的访问权限</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener noreferrer">GitHub 词汇表</a></li>
</ul>
<h2 id="生态系统" tabindex="-1"> 生态系统</h2>
<h3 id="github-cli" tabindex="-1"> GitHub Cli</h3>
<p>GitHub CLI 是用于在计算机上使用 GitHub 功能的命令行工具。</p>
<p>GitHub CLI 是用于从计算机的命令行使用 GitHub 的开源工具。从命令行操作时，您可以使用 GitHub CLI 来节省时间并避免切换上下文。</p>
<p>您可以将以下 GitHub 功能与 GitHub CLI 结合使用。</p>
<ul>
<li>查看、创建、克隆和复刻仓库</li>
<li>创建、关闭和列出议题和拉取请求</li>
<li>审查、差异和合并拉取请求</li>
<li>创建、编辑、列出和查看 Gist</li>
</ul>
<p>有关 GitHub CLI 用途的更多信息，请参阅 <a href="https://cli.github.com/manual" target="_blank" rel="noopener noreferrer">GitHub CLI 手册</a>。</p>
<h3 id="github-desktop" tabindex="-1"> GitHub Desktop</h3>
<p>GitHub Desktop 使用可视界面扩展并简化您的 Git 和 GitHub 工作流程。</p>
<p>GitHub Desktop 是一种开源工具，可帮助您提高工作效率。GitHub Desktop 鼓励您和您的团队使用最佳实践协作处理 Git 和 GitHub。</p>
<p>您可以使用 GitHub Desktop 执行许多任务，包括:</p>
<ul>
<li>以交互方式将更改添加到提交中</li>
<li>快速将合作作者提交到提交中</li>
<li>检出具有拉取请求的分支并查看 CI 状态</li>
<li>比较更改的图像</li>
</ul>
<p>有关 GitHub Desktop 的更多信息，请参阅 GitHub Desktop 文档中的 <a href="https://docs.github.com/cn/free-pro-team@latest/desktop/installing-and-configuring-github-desktop" target="_blank" rel="noopener noreferrer">安装和配置 GitHub Desktop</a>。</p>
<h3 id="手机版-github" tabindex="-1"> 手机版 GitHub</h3>
<p>从移动设备对 GitHub 上的工作进行分类、协作和管理。</p>
<p>手机版 GitHub 目前作为 Android 和 iOS app 提供给 GitHub.com 用户。</p>
<p>手机版 GitHub 为您提供随时随地快速高效使用 GitHub 的方式。手机版 GitHub 是通过可信的第一方客户端应用程序访问 GitHub 数据的安全可靠方式。</p>
<p>通过 手机版 GitHub，您可以:</p>
<ul>
<li>管理、分类和清除通知</li>
<li>阅读、审查及协作处理问题和拉取请求</li>
<li>搜索、浏览用户、仓库和组织以及与之交互</li>
<li>当有人提及您的用户名时收到推送通知</li>
</ul>
<h4 id="安装-手机版-github" tabindex="-1"> 安装 手机版 GitHub</h4>
<p>要安装 Android 或 iOS 版 手机版 GitHub，请参阅 <a href="https://github.com/mobile" target="_blank" rel="noopener noreferrer">手机版 GitHub</a>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>自动部署</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/deploy.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/deploy.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">自动部署</source>
      <description>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。
</description>
      <category>GitHub</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>

<div><p>提示</p>
<p>由于 Centos 仍然是用 GitV1，本教程使用 Ubuntu 20.04 进行教学。</p>
</div>
<h2 id="服务器" tabindex="-1"> 服务器</h2>
<p>为了能供自动部署到服务器，我们需要让服务器的网站目录成为一个 Git 仓库，这样我们可以在 GitHub Actions 中，通过向服务器对应 GitHub 仓库推送网站内容，使服务器网站获得自动更新。下面是服务器侧的部署配置</p>
<h3 id="添加账户" tabindex="-1"> 添加账户</h3>
<p>为了安全，首先需要使用命令创建 Git 用户，为了安全请务必设置密码。</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>之后，查看部署目录所在组，git 用户添加到组中。</p>
<div><pre><code><span>usermod</span> -a -G <span>&lt;</span>目录所在组<span>></span> <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后将部署目录的权限设置为 <code>775</code>，即允许同组访问。这样 git 就有权限访问部署目录。</p>
<h3 id="添加权限" tabindex="-1"> 添加权限</h3>
<p>创建 <code>~/.ssh/</code> 文件夹，生成 <code>authorized_keys</code> 文件，并设置其权限为 <code>600</code>。</p>
<div><pre><code><span>mkdir</span> -p ~/.ssh/

<span>touch</span> ~/.ssh/authorized_keys

<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>之后将需要赋予权限的用户公钥依次粘贴至该文件，这样相关用户即可以使用对应私钥，向服务器相关仓库推送代码。</p>
<h3 id="创建仓库" tabindex="-1"> 创建仓库</h3>
<p>回到 <code>/home/git/</code>，创建所需的文件夹:</p>
<div><pre><code><span>cd</span> ~
<span>mkdir</span> <span>&lt;</span>仓库名<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>进入文件夹，使用</p>
<div><pre><code><span>git</span> init --separate-git-dir<span>=</span>. <span>&lt;</span>部署位置<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这会将 git 库保持在 <code>/home/git/&lt;仓库名&gt;</code> 下，同时将工作区设置到部署文件夹中。</p>
<p>接下来执行:</p>
<div><pre><code><span>git</span> config receive.denyCurrentBranch ignore
<span>git</span> config --global --add safe.directory <span>&lt;</span>部署文件夹<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>注</p>
<p>Git 默认拒绝外部对当前分支的推送操作，因为这可能会覆盖或变更工作区文件。所以我们需要显式通知 Git 不要拒绝当前分支的推送操作。</p>
<p>另外在新版本 Git 中，考虑到安全因素，Git 会在检出时检测项目文件夹是否属于其他组成员，如果检测到会默认拒绝相关操作以防止其他用于获取到本不应该获取到的代码信息。因为部署文件夹的所有者通常不会是 git，所以我们需要标记对应的部署文件夹“安全”。</p>
</div>
<h2 id="github-actions" tabindex="-1"> GitHub Actions</h2>
<p>在 GitHub 一侧，我们需要通过 GitHub Action，在新代码推送时自动构建网站，并部署到 GitHub 的 gh-pages 分支。之后，GitHub Action 将该分支的变动推送服务器的对应仓库，完成网站的自动部署。</p>
<p>之后只需要使用 GitHub Action 通过 Git 推送到 <code>git@&lt;domain&gt;:&lt;部署目录&gt; gh-pages</code> 即可。</p>
<div><pre><code><span># 自动部署的名称</span>
<span>name</span><span>:</span> GitHub pages deploy

<span># 自动部署的条件</span>
<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span># 构建网站并部署到 GitHub Pages</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span># 运行环境</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest

    <span># 步骤</span>
    <span>steps</span><span>:</span>
      <span># 第一步: 下载源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span># action 配置详见 https://github.com/actions/checkout</span>
        <span>uses</span><span>:</span> actions/checkout@v3
        <span>with</span><span>:</span>
          <span># 如果本项目包含了子模块 (git submodules)，需要将此项设置为 true</span>
          <span># submodules: true</span>

          <span># 这是获取历史 commit 的深度，默认为 1，即只拉取最后一个 commit</span>
          <span># 这样可以加快拉取速度</span>
          <span>#</span>
          <span># 如果项目使用 VuePress，为了正确通过 Git 历史提交记录生成页面的最后更新时间</span>
          <span># 需要设置为 0 以拉取完整的 git 历史提交</span>
          <span># fetch-depth: 0</span>

          <span># 如果子模块包含私有仓库，需要设置 ssh key 或 token 以保证拥有拉取相应仓库的权限</span>
          <span># 您可以将 ssh-key 设置为 github 绑定公钥对应的私钥</span>
          <span># 也可以新建一个具有相关仓库访问权限的 github token</span>
          <span># token:</span>

      <span># 缓存 node_modules 以避免重复安装</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v3
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span># 需要缓存的路径</span>
          <span>path</span><span>:</span> node_modules/
          <span># 缓存的 key</span>
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span># 恢复 key</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>

      <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span># 只有没有命中缓存才会执行</span>
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span># 严格按照 yarn.lock 安装依赖</span>
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

      <span># 构建项目</span>
      <span>-</span> <span>name</span><span>:</span> Build
        <span># 项目的构建命令</span>
        <span>run</span><span>:</span> yarn run build

      <span># 第四步，部署</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># action 配置详见 https://github.com/JamesIves/github-pages-deploy-action</span>
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@v4
        <span>with</span><span>:</span>
          <span># 部署到的分支</span>
          <span>branch</span><span>:</span> gh<span>-</span>pages
          <span># 需要部署的文件夹</span>
          <span>folder</span><span>:</span> dist

  <span># 部署到服务器</span>
  <span>deploy-server</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span># 确保在部署到 GitHub Pages 之后执行</span>
    <span>needs</span><span>:</span> deploy<span>-</span>gh<span>-</span>pages
    <span>steps</span><span>:</span>
      <span># 检出网站代码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v3
        <span>with</span><span>:</span>
          <span># 检出 gh-pages 分支</span>
          <span>ref</span><span>:</span> gh<span>-</span>pages
          <span># 获取全部的历史提交</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>

      <span># 配置环境</span>
      <span>-</span> <span>name</span><span>:</span> Configuration environment
        <span># 写入私钥、配置 Git 用户名，写入服务器地址</span>
        <span># 您需要自行将服务器的私钥写入 secrets 的 SSH_PRIVATE_KEY</span>
        <span>run</span><span>:</span> <span>|</span><span>
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan &lt;your domain> >> ~/.ssh/known_hosts
          git config --global user.name 'Your Name'
          git config --global user.email 'You email'</span>

      <span># 部署到服务器</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># 使用 Git 将网站代码强制推送到远程的网站目录</span>
        <span># 并使用 SSH 连接服务器进入网站目录手动切换到最新提交</span>
        <span>run</span><span>:</span> <span>|</span><span>
          git push -f git@&lt;your domain>:&lt;deploy dir> gh-pages
          ssh git@&lt;your domain> "cd &lt;deploy dir> &amp;&amp; git reset --hard HEAD"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>GitHub 简介</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/intro.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/intro.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">GitHub 简介</source>
      <category>GitHub</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="gayhub-github-是世界上最大的-同性交友-代码托管网站" tabindex="-1"> <s>Gayhub</s> GitHub 是世界上最大的 <s>同性交友</s> 代码托管网站</h2>
<p>😋当然在上面交友也是极好的(这是重点，圈起来要考的😎)。</p>
<h2 id="基本概念" tabindex="-1"> 基本概念</h2>
<h3 id="repository" tabindex="-1"> Repository</h3>
<p>仓库。一个仓库即是一个项目。仓库是 GitHub 上的主要内容。每当您新建一个项目并想要在 GitHub。</p>
<h3 id="star" tabindex="-1"> Star</h3>
<p>收藏。在每一个仓库主页的上方可以看到 star 按钮。其上的数值为收藏该项目的人数。点击星星即可将当前仓库收藏到您的账号上。您可以收藏一些您比较喜欢，或者项目对您来说有很大价值的项目。同时，点击数字可以看到哪些人收藏了这个项目。</p>
<h3 id="fork" tabindex="-1"> Fork</h3>
<p>复刻。在每一个仓库主页的上方可以看到 Fork 按钮。点击该按钮的作用是将当前项目复刻一份到自己的仓库中，这样，您就可以在此仓库仓库上查看当前、历史的版本，切换分支、或者是随心所欲的进行修改。原项目的新的推送、对历史版本的修改、甚至原作者删除了他的 repo，都不会对您 fork 的项目产生任何影响。</p>
<h3 id="issue" tabindex="-1"> Issue</h3>
<p>议题。你可将这里理解为 Bug 汇报区与新功能提交区。</p>
<p>如果您在使用该项目的过程中遇到了问题，可以在相应项目的 Issue 板块按照项目的要求提出 Issue。在 Issue 中可以汇报一个 bug，或者是提出一个 Feature Request (功能请求)。项目的拥有者可以针对您汇报的情况对您做出回复。</p>
<p>同时，项目拥有者还可以:</p>
<ul>
<li>为此 issue 增加 label (标签)，以帮助项目成员或是项目的其他使用者更好的理解这个 issue 的分类</li>
<li>将此 issue assign (分派) 给特定的项目成员解决。</li>
<li>将此 issue 加入特定的 project (项目) 以安排处理日期与进度。</li>
</ul>
<div><p>提示</p>
<p>为了 GitHub 的友好交流环境，请在汇报 bug 时永远带上 bug 的一个简易的复现流程，可以直接建立一个简单的 reproduction repo 并把链接放置在您提出的 issue 中。</p>
</div>
<h3 id="pull-request" tabindex="-1"> Pull Request</h3>
<p>发起推送请求，简称 <strong>PR</strong>。如果是您自己的项目，您可以从一个分支向另一个分支发起推送请求。如果您想对别人的(您无权进行推送)项目进行代码的推送请求的化，需要先 fork 这个仓库。在自己 fork 的项目上进行修改，然后提交到自己的项目上，之后，建立一个从自己仓库到对方仓库的 PR。如果对方觉得您的新改动很不错，在经过测试或者 review 后就会接受它，这样原有项目就可拥有这些新的代码了.</p>
<h3 id="dicussion" tabindex="-1"> Dicussion</h3>
<p>GitHub 的讨论区，和 Issue 区主要用于 Bug 和 Feature Request 的追踪不同，通常情况下，你可以在讨论区开帖子询问使用中遇到的问题，以便其他人进行答复。你也可以在 Dicussion 区提供项目的看法与建议，比如对某个功能进行改进的方式以及相关理由。你也可以展示你自己使用项目的一些新的或是与项目相关的一些内容。</p>
<h3 id="watch" tabindex="-1"> Watch</h3>
<p>关注，在每一个仓库主页的上方可以看到 Watch 按钮。如果您关注了某个项目,那么这个项目有了变化的时候,您就会得到通知.在您点击关注后，您还可以点击下拉列表进一步设置关注级别。您可以选择接受 Release (新发布) 通知，也可以选择 Watching 来监听所有的通知。当您选择 Ignore 的话，即使有人在这个仓库中 metion (提到) 了您，您也不会得到通知。</p>
<h3 id="review" tabindex="-1"> Review</h3>
<p>审查。当项目收到 PR 时，项目的拥有成员可以对这份 PR 的代码改动进行审查，在 Review 的过程中，可以对代码的特定行或特定几行通过 comment(评论) 的方式来提出自己对代码改动的意见。</p>
<h2 id="主页" tabindex="-1"> 主页</h2>
<p><img src="@source/code/github/assets/mainPage.png" alt="个人主页"></p>
<p><a href="https://github.com" target="_blank" rel="noopener noreferrer">https://github.com</a></p>
<p>主页，在您登陆后，屏幕的左侧会展示您和您加入团队的项目，以及您的团队详情。中部会显示您关注的项目、人的动态，右侧会根据算法展示一些您可能会感兴趣的 repo。</p>
<h2 id="个人主页" tabindex="-1"> 个人主页</h2>
<p><img src="@source/code/github/assets/profile.png" alt="个人主页"></p>
<p><strong>地址:</strong> <code>https://github.com/&lt;您的用户名&gt;</code></p>
<p>个人主页会有几个主要面板:</p>
<h3 id="overview" tabindex="-1"> Overview</h3>
<p>个人概览，您可以在上方 pin(固定) 最多六个您想要展示给他人的仓库。</p>
<p>下方就是您过去一年里向 GitHub 的提交数量分布图，以及您在 GitHub 上的活动比例。</p>
<p>最下方是近几年您在 GitHub 上的活动记录。</p>
<h3 id="repositories" tabindex="-1"> Repositories</h3>
<p><img src="@source/code/github/assets/personalRepo.png" alt="个人仓库"></p>
<p>仓库列表，该面板会按照最后更新时间的倒序，展示该用户拥有的所有 reo，同时也会在面板上展示项目的 Descript(描述)、Star 数、Fork 数、语言、协议、标签，以及过去一年内项目的 commit 分布数量。这些都能够帮助浏览者在不进入具体仓库页面的情况下大致了解每一个仓库的内容、欢迎程度与维护情况。</p>
<h3 id="projects" tabindex="-1"> Projects</h3>
<p>个人拥有的项目，在管理自己与团队跨仓库的活动日程时很有用。可以设置涉及到的仓库，提出任务、代办、时间表等。</p>
<h3 id="packages" tabindex="-1"> Packages</h3>
<p>个人在 GitHub 上拥有的包。目前较少人在 GitHub 上发布相关的包。</p>
<h3 id="stars" tabindex="-1"> Stars</h3>
<p>和仓库列表完全相同，只不过展示该用户收藏的 repo。</p>
<h3 id="followers-following" tabindex="-1"> Followers / Following</h3>
<p>关注您的人 / 关注的人。在个人主页的左侧就有 follow 按钮，follow 一个人意味着这个人在 GitHub 的的活动会出现在 GitHub 主页的 Activity List 上。</p>
<h2 id="仓库主页" tabindex="-1"> 仓库主页</h2>
<p><img src="@source/code/github/assets/repo.png" alt="仓库主页"></p>
<p>仓库主页主要显示项目的信息。从左到右的面板依次是: Code(代码)，Issues (问题)、Pull Requests (提交请求)、Actions (自动流程)、 Projects (项目)、 Wiki (项目介绍)、 Security (项目安全)、 Insights (项目数据统计) 与 Settings (项目设置)。</p>
<p>在下方会展示代码文件以及项目说明 README.md 文件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Pages</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/pages.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/pages.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">GitHub Pages</source>
      <description>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。
您可以将站点托管在 GitHub 的 github.io 域名或您自己的自定义域名上。
</description>
      <category>GitHub</category>
      <pubDate>Sat, 20 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。</p>
<p>您可以将站点托管在 GitHub 的 <code>github.io</code> 域名或您自己的自定义域名上。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>GitHub Pages 站点共有三种类型: 项目，用户和组织。</p>
<p>项目站点连接到 GitHub 上托管的特定项目，而用户和组织站点已连接到特定的 GitHub 帐户。</p>
<ul>
<li>要发布用户站点，您必须创建一个名为的用户帐户拥有的存储库 <code>&lt;username&gt;.github.io</code>。</li>
<li>要发布组织站点，您必须创建一个名为的组织所拥有的存储库 <code>&lt;organization&gt;.github.io</code>。</li>
</ul>
<p>除非您使用自定义域名，否则用户站点和组织站点均位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p>
<p>项目站点的源文件与其项目存储在同一存储库中。除非您使用自定义域，否则项目站点可在 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 访问。</p>
<p>虽然您只能在 GitHub 上为每个帐户创建一个用户或组织站点。但无论是组织还是用户帐户拥有的项目站点都是无限的。</p>
<h2 id="发布源文件到-github-pages" tabindex="-1"> 发布源文件到 GitHub Pages</h2>
<div><p>警告</p>
<p>GitHub Pages 站点 默认在互联网上公开，即使站点的仓库是私有的。</p>
</div>
<p>如果您的存储库中存在默认发布源，则 GitHub Pages 将自动从该源发布网站。用户和组织站点的默认发布源是存储库的默认分支的根目录。项目站点的默认发布源是 gh-pages 分支的根目录。</p>
<p>您需要跳转到 Settings (设置) 选项卡，下来找到 GitHub Pages 的配置部分。</p>
<div><p>提示</p>
<p>您只能在根目录 (<code>/</code>) 和 文档目录 (<code>/docs</code>) 之间进行选择，而不能将仓库内的任意文件夹作为发布源。</p>
</div>
<h3 id="静态站点" tabindex="-1"> 静态站点</h3>
<p>GitHub Pages 发布您推送到存储库的所有静态文件，这意味它不支持服务器端语言，例如 PHP，Ruby 或 Python。也就是您只能通过 GitHub Pages 发布 “无后端” 的纯静态站点。</p>
<h3 id="限制" tabindex="-1"> 限制</h3>
<ul>
<li>
<p>GitHub Pages 网站不得超过 1 GB。</p>
</li>
<li>
<p>GitHub Pages 站点的带宽限制为每月 100GB。</p>
</li>
<li>
<p>GitHub Pages 站点限制为每小时最多构建 10 次。</p>
</li>
</ul>
<h3 id="子模块" tabindex="-1"> 子模块</h3>
<p>如果 GitHub Pages 站点的仓库包含子模块，则在构建站点时会自动拉取其内容。</p>
<p>只能使用指向公共仓库的子模块，因为 GitHub Pages 服务器无法访问私有仓库。</p>
<p>对子模块 (包括嵌套子模块) 使用 <code>https://</code> 只读 URL。 您可以在 .gitmodules 文件中进行此更改。</p>
<h2 id="取消发布" tabindex="-1"> 取消发布</h2>
<h3 id="取消发布项目站点" tabindex="-1"> 取消发布项目站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>如果仓库中存在 gh-pages 分支，请删除 gh-pages 分支。</li>
<li>在仓库名称下，单击 Settings (设置) 。</li>
<li>在“ GitHub Pages”下，使用 Source (源) 下拉菜单并选择 None (无) 。</li>
</ol>
<h3 id="取消发布用户或组织站点" tabindex="-1"> 取消发布用户或组织站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>删除用作发布源的分支，或删除整个仓库。</li>
</ol>
<h2 id="自定义域名" tabindex="-1"> 自定义域名</h2>
<p>您可以在对应仓库的 Settings (设置) 选项卡设置自定义域名，同时您需要将自定义域名的 CNAME 记录指向 <code>&lt;用户名&gt;.github.io</code>。</p>
<div><p>提示</p>
<p>自定义域名的控制是由发布源文件夹下的 CNAME 文件控制的，您可以直接创建这个文件写入链接。</p>
<p>同时，GitHub Pages 要求这个文件一直存在，否则自定义域名会失效。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Pull Request</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/pr.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/pr.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Pull Request</source>
      <category>GitHub</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>对于一个用户的公开仓库，在默认情况下虽然其他用户可以拉取该库的代码，但是他们并不能够直接向这个库进行推送。</p>
<p>GitHub 是一个代码社区，这意味着鼓励大家互相提交与贡献代码。所以这就是 Fork 和 Pull Request 出现的意义。没有人会给一个陌生人添加访问自己仓库的权限，所以我们需要一种方式，能够让大家向仓库所有者发起贡献代码的请求。这就是 pull request 的由来。</p>
<h2 id="提交自己贡献的代码" tabindex="-1"> 提交自己贡献的代码</h2>
<p>对于代码贡献者来说，他需要用一种方法将自己贡献的代码推送到远程库上，以便发起请求，最好的办法就是 fork 原仓库。</p>
<p><img src="@source/code/github/assets/fork.png" alt="Fork 仓库"></p>
<div><p>相关信息</p>
<p>相关介绍，请见 <a href="/code/github/intro.html#fork">GitHub 简介 → fork</a></p>
</div>
<p>这样，贡献者在自己的账号上获得一个和原仓库完全相同的副本。</p>
<p>既然副本已经创建在自己的账号上，贡献者自然可以:</p>
<ol>
<li>克隆这个项目到本地</li>
<li>在这个项目上贡献自己的代码</li>
<li>将贡献的代码推送到这个副本上</li>
</ol>
<h2 id="发送请求" tabindex="-1"> 发送请求</h2>
<p>pull request 是请求仓库所有者拉取指定仓库分支代码的请求。</p>
<p>在贡献自己的代码并推送到自己的 fork 仓库后，贡献者即可到原仓库去选择自己仓库的对应分支发送这个拉取请求。仓库所有者随时可以批准这个更改，使其自动添加到自己的库中，或是拒绝这个请求。</p>
<p><img src="@source/code/github/assets/pull-request.png" alt="Pull request"></p>
<blockquote>
<p>这个仓库我已经删了所以显示 <code>unknown repository</code>，原为 <code>Mister-Hope:master</code></p>
</blockquote>
<p>这个页面允许所有人在主要对话线上交换自己的意见。</p>
<p>在 Pull request 里，一旦请求被创建，仓库所有者应该可以直观地看到哪些文件发生了怎样的改变。</p>
<p><img src="@source/code/github/assets/file-changes.png" alt="文件改动"></p>
<p>同时，他们也可以对贡献者的代码进行审查，对特定行或片段标注，并陈述自己的意见，同时将这个意见根据程度标注为“探讨”、“改进”或者“必须更改”，以便贡献者进行交流讨论与完善修改。</p>
<p><img src="@source/code/github/assets/pull-request-review.png" alt="代码审查"></p>
<p>同时，对于一个大型库来说，仓库所有者应该可以看到贡献的代码是否通过了所有测试。</p>
<p><img src="@source/code/github/assets/pull-request-check.png" alt="测试通过情况"></p>
<p>如果审查者认为没有问题，他可能就会通过这个拉取请求，拉取对应的代码到自己的仓库上。这样您就完成了对这个仓库的贡献。</p>
<h2 id="同步原仓库" tabindex="-1"> 同步原仓库</h2>
<p>需要注意的是，fork 创建的是一个时刻副本，也就是自己 fork 产生的仓库，会保持 fork 时的状态，原仓库的任何变动都不会自动同步到 fork 的仓库上。</p>
<p>有些时候，在自己 fork 原仓库、自己编写代码并提交的这段时间里，原仓库已经进行了很多提交。这时，我们就需要同步原仓库的更新到自己的副本上，以确保自己贡献的代码并未和新增代码发生冲突、可以正常工作。</p>
<p>这个时候只需反向拉取，在自己的仓库创建原仓库特定分支到自己仓库特定分支的 Pull request，并批准这个 pull request。这样即可很方便的将原仓库特定分支的更新同步到自己的副本上。</p>
<p>您当然可以在本地添加原仓库的远程库，将最新的更改直接 fetch 到本地，在本地测试通过并完成合并后，由本地推送至自己的 fork 仓库。</p>
]]></content:encoded>
    </item>
    <item>
      <title>语义化提交</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/semantic.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/semantic.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">语义化提交</source>
      <category>GitHub</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="semantic" tabindex="-1"> Semantic</h2>
<p>对于一个大型项目，几千个 commit 是很常见的，这些 commit 部分是项目维护者提交的 commit，部分是一些热心的开发者通过 PR 贡献的。</p>
<p>无论是对于项目维护者，还是想要贡献代码的热心开发者来说，一个简洁明了的 commit 描述都是必不可少的。也就是说我们需要用尽可能简短的备注信息，备注每一个 commit 的作用，以便大家查看。所以我们需要一种规范的，语义化的备注格式，很快由知名项目牵头，全球接收并统一了一种语义化的备注格式，这就是 semantic 规范的来源。</p>
<h2 id="优势" tabindex="-1"> 优势</h2>
<p>当一个仓库所有的 commit 信息都是用标准的 semantic 格式时，用户可以很方便的理解每一个 commit 的作用。</p>
<p>同时，senmantic 支持直接将某个提交或 PR 与特定 issue 链接，并自动关闭或引用这些 issue。</p>
<p>通过一些第三方工具，大家可以基于这些备注信息进行过滤查找，更新日志生成等操作。</p>
<h2 id="格式" tabindex="-1"> 格式</h2>
<div><pre><code>&lt;type>(&lt;scope>): &lt;subject>
&lt;body>

&lt;footer>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="header" tabindex="-1"> header</h3>
<p>第一行被称为 <code>header</code>，它必须只有一行，包括三个字段: <code>&lt;type&gt;</code>(必需)、<code>&lt;scope&gt;</code>(可选)和 <code>&lt;subject&gt;</code>(必需)</p>
<h3 id="type" tabindex="-1"> type</h3>
<p>commit 的类型。</p>
<p>规范中规定了如下类型:</p>
<ul>
<li><code>feat</code>: feature, 新增功能</li>
<li><code>fix</code> : bug fix, 修复 bug</li>
<li><code>docs</code>: documentation, 仅仅修改了文档，如 <code>README.md</code></li>
<li><code>style</code>: style, 仅仅是对格式进行修改，如逗号、缩进、空格等，不改变代码逻辑</li>
<li><code>refactor</code>: refactor, 代码重构，一般更改了源文件或测试文件，但没有新增功能或修复 bug</li>
<li><code>perf</code>: preformance, 优化相关，如提升性能、用户体验等</li>
<li><code>test</code>: test, 测试用例，包括单元测试，集成测试</li>
<li><code>chore</code>: chore, 对于库的其他内容的改变，一般不涉及到源文件或测试文件，比如更改 CI 设置，提升仓库以来等</li>
<li><code>revert</code>: 版本回滚</li>
</ul>
<h3 id="scope" tabindex="-1"> scope</h3>
<p>用于说明 commit 影响的范围，比如: <code>views</code> , <code>component</code>, <code>utils</code>, <code>test</code>。这个是由项目的内容与结构决定的。</p>
<h3 id="subject" tabindex="-1"> subject</h3>
<p>commit 目的的简短描述，最好小于 50 字符，一般不超过 65 个字符，最长不超过 80 字符。</p>
<p>当 subject 限制的字符数无法详细说明此 commit 的变动时，将 commit 的具体变动放置在 body 中</p>
<h3 id="body" tabindex="-1"> body</h3>
<p>对本次 commit 修改内容的具体描述，可以分为多行。<code>body</code> 是可选的，而且 <code>body</code> 可以有多行。</p>
<h3 id="footer" tabindex="-1"> footer</h3>
<p>可选的，前面有一空行。可以添加一些备注，一般放置 <code>BREAKING CHANGE</code>(一些破坏性的变动) 或修复的 bug(涉及的 issue)的链接。</p>
<h2 id="semantic-commit-与-changelog-生成" tabindex="-1"> Semantic commit 与 Changelog 生成</h2>
<p>不同语言环境都有很多种工具来帮助您创建一个 semantic commit 或者自动生成 changelog。</p>
<div><p>案例</p>
<p>Node.js 环境下可以使用:</p>
<ul>
<li>
<p><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noopener noreferrer"><code>cz-conventional-changelog</code></a> 提供 <code>git cz</code> 命令辅助创建 semantic commit。</p>
</li>
<li>
<p><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener noreferrer"><code>conventional-changelog-cli</code></a> 来快速生成更新日志，如 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">vuepress-theme-hope 的更改日志</a></p>
</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>加速 GitHub 克隆</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/speedup.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/speedup.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">加速 GitHub 克隆</source>
      <category>GitHub</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于天朝墙的存在，GitHub 的访问速度在大部分国内地区都很慢。如果需要克隆体积比较大的项目，可能需要很长时间，也很大概率会在中途因为网络波动、终端问题导致克隆失败。</p>
<p>本文介绍如何使用 Gitee 加快 GitHub 项目克隆。</p>
<h2 id="gitee" tabindex="-1"> Gitee</h2>
<p>Gitee 又称码云，是一个国内的代码托管商，国内访问 Gitee 的速度是十分 Amazing 的。</p>
<h3 id="注册" tabindex="-1"> 注册</h3>
<p>Gitee 账户可以很方便的通过 GitHub 账户 + 绑定手机号注册。</p>
<h3 id="添加公钥" tabindex="-1"> 添加公钥</h3>
<p>完成注册后，您需要上传本地公钥，以保证可以从 Gitee 上拉取或克隆，其步骤与 GitHub 大致相同。</p>
<h3 id="导入-github-仓库" tabindex="-1"> 导入 GitHub 仓库</h3>
<p>码云的企业专线访问 GitHub 的速度很快，而码云在新建仓库的时候提供了导入选项，这就给我们的加速提供了方式。</p>
<p>我们只需要在码云上新建仓库，选择导入，然后输入自己想要克隆的 GitHub 仓库地址，交给码云完成导入即可。</p>
<p>稍等片刻后，码云即会将 GitHub 的仓库同步到自己的服务器上，此时我们只需要克隆码云上的这个仓库地址，就可以高速克隆这个项目。</p>
<h3 id="远程库地址修改" tabindex="-1"> 远程库地址修改</h3>
<p>在克隆完毕后，本地的 origin 远程库会默认为 Gitee 的仓库，此时我们需要使用 <code>git remote rename origin gitee</code> 命令，将码云的远程仓库重命名为 <code>gitee</code>，并使用 <code>git remote add origin &lt;github url&gt;</code> 命令重新添加 GitHub 的远程仓库为 origin。</p>
<p>这样我们稍后在做出本地提交后，即可直接推送到 GitHub 仓库。</p>
<h3 id="同步仓库" tabindex="-1"> 同步仓库</h3>
<p>如果以导入的形式创建码云仓库。则可以随时点击仓库页面上的同步图标，让码云随时拉取最新的 gitee 代码，以便在本地通过 <code>git fetch gitee</code>，通过码云服务器高速拉取最新代码。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Token</title>
      <link>https://songjun520.cn/vuepress-blog2/code/github/token.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/github/token.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">GitHub Token</source>
      <description>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。
</description>
      <category>GitHub</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。</p>

<h2 id="创建个人访问令牌" tabindex="-1"> 创建个人访问令牌</h2>
<ol>
<li>
<p>访问 <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener noreferrer">新建 Token 页面</a> (当然您需要先登陆 GitHub)</p>
<blockquote>
<p>或者可以点击头像 → Settings → Developer settings → Personal access tokens → Generate new Token</p>
</blockquote>
</li>
<li>
<p>输入一个备注，选择您需要授权 Token 访问的内容，之后点击页面底部的 &quot;Generate Token&quot;</p>
</li>
<li>
<p>妥善保存该 Token (因为您无法再次查看它)</p>
</li>
</ol>
<p>详见 <a href="https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token" target="_blank" rel="noopener noreferrer">创建个人访问令牌</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>代码学习教程</title>
      <link>https://songjun520.cn/vuepress-blog2/code/language/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/language/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">代码学习教程</source>
      <category>教程</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li><a href="/code/language/learning.html">如何学习一门语言</a></li>
</ul>
<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/language/js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/python/">Python 教程</a> (编写中...)</p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener noreferrer">Java 教程</a>(廖雪峰的博客)</p>
</li>
<li>
<p><a href="/code/language/markdown/">Markdown 教程</a></p>
</li>
<li>
<p><a href="/code/language/yaml/">YAML 教程</a></p>
</li>
<li>
<p><a href="/code/language/json/">JSON 教程</a></p>
</li>
</ul>
<h2 id="linter" tabindex="-1"> Linter</h2>
<ul>
<li><a href="/code/language/linter/">Linter 介绍</a></li>
</ul>
<div><p>提示</p>
<p>C 、C++、Java、PHP 正在编写中...</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>如何学习一门计算机语言</title>
      <link>https://songjun520.cn/vuepress-blog2/code/language/learning.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/language/learning.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">如何学习一门计算机语言</source>
      <category>教程</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="如何学习一门计算机语言" tabindex="-1"> 如何学习一门计算机语言</h1>
<div><p>提示</p>
<p>学习一门语言的基本顺序是:</p>
<ul>
<li>了解数据结构</li>
<li>了解变量声明与赋值</li>
<li>了解判断和循环体结构</li>
<li>了解函数声明</li>
<li>了解输入输出</li>
</ul>
<p>本部分将以 JS 作为示例，展示什么是一门计算机语言，应该如何学习它们。</p>
</div>
<h2 id="基础" tabindex="-1"> 基础</h2>
<p>首先，任何语言都是由一些基本结构组成的，下面介绍几乎所有语言共有的一些概念:</p>
<h3 id="语句" tabindex="-1"> 语句</h3>
<p>语句可以简单理解为一个操作，它可以是赋值，也可以是执行，还可以是介于或者是可以归类到两者上的判断、声明、标记等。</p>
<p>请注意一条语句通常是一个计算机语言描述的最小操作。</p>
<p>比如:</p>
<div><pre><code><span>let</span> a <span>=</span> <span>1</span><span>;</span> <span>// 赋值</span>
<span>alert</span><span>(</span><span>"Hello word"</span><span>)</span><span>;</span> <span>// 调用函数 执行操作</span>
<span>if</span> <span>(</span>a <span>></span> <span>2</span><span>)</span> <span>{</span>
  <span>// 判断</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="代码块" tabindex="-1"> 代码块</h3>
<p>通常情况下，在有了语句概念后，我们就要使用不同的语句顺序，完成不同的操作，但是某些操作总是固定的。</p>
<p>比如回家，总是 “掏出钥匙”-“插入钥匙”-“转动钥匙”-“开启房门”-“拔出钥匙”-“进入”-“关闭房门” 。</p>
<p>这些步骤每一步都可以理解为一个语句，但是由于其顺序基本是固定的，我们就可以设计一个代码块，来约束它们。</p>
<div><pre><code>{
  “掏出钥匙”;
  “插入钥匙”;
  “转动钥匙”;
  “开启房门”;
  “拔出钥匙”;
  “进入”;
  “关闭房门”;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>大多数语言会使用 <code>{ }</code> 的形式，少数语言会使用统一的缩进进行表达。</p>
<h2 id="数据结构" tabindex="-1"> 数据结构</h2>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。</p>
<p>任何语言都是操作、计算(处理)、生成数据的。数据结构是一门语言存放数据的方式。不同的数据，需要定义不同的数据类型。了解了数据结构就了解了一门语言可以存储或处理何种数据。</p>
<p>大多数语言都包含了以下的一种或多种内容:</p>
<ul>
<li>
<p>数字:</p>
<p>不同语言对数字有不同的处理方式，少数语言可能只有数字这一种类型，一些语言可能会拆分成整数与浮点数。一些底层语言(涉及到内存)可能会魔鬼的将数字拆分为: 整型、浮点数、无符号整型、长整型、无符号长整形、长浮点数。(说的就是您，C 语言)</p>
</li>
<li>
<p>字符串:</p>
<p>一些语言只有字符串这个概念，一些语言分为字符和字符串这个概念。</p>
</li>
<li>
<p>布尔值:</p>
<p>几乎所有语言都有布尔值，布尔值只有真和假两种类型。大多数会表示为 <code>true</code> 和 <code>false</code>，少数会表示为 <code>True</code> 和 <code>False</code>。</p>
</li>
<li>
<p>数组:</p>
<p>大部分语言都有数组 (Array) 这个概念，它是一个有序的元素集合。很多底层语言就是靠数组实现的字符串 (因为字符串长度不固定)。在数组中，每个元素具有标号，从 0 开始依次递增。</p>
<p>一些语言还有 Set 这个概念，Set 表示的是无序元素集合，所有元素没有先后与标号的概念，自然 Set 也无法存入相同的元素。</p>
</li>
<li>
<p>对象:</p>
<p>大部分语言的对象 (Object) 都是由键值对组成的，它是一个由键标记的元素集合，可以使用特定的键名写入或读取其对应的值。</p>
<p>一些产生较晚的语言，将对象改为 Map，Map 表达一个映射，将对应的键映射到对应的值上。</p>
</li>
<li>
<p>类:</p>
<p>类 (Class) 是一个内容集合，它包含了自己的构造器、变量与方法。类在声明后，可以很轻松的使用构造器创建一个新的实例。每个实例可以用其内部的变量维护或表达一个状态，并可以使用它自身的方法来读取或是改变自己的状态。不同的类之间还可以进行继承。</p>
</li>
</ul>
<h2 id="变量" tabindex="-1"> 变量</h2>
<p>一个<strong>变量</strong>是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。</p>
<p>下面的语句创建(换句话说，<strong>声明</strong>或者<strong>定义</strong>)了一个名称为“message”的变量:</p>
<div><pre><code><span>let</span> message<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在有了变量之后，我们就可以将刚了解的数据结构赋值给变量，以变量来代替这些数据。</p>
<div><pre><code><span>let</span> user <span>=</span> <span>"John"</span><span>;</span>
<span>let</span> age <span>=</span> <span>25</span><span>;</span>
<span>let</span> message <span>=</span> <span>"Hello"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="条件" tabindex="-1"> 条件</h2>
<p>条件运算符用于判断，通过判断一个条件的真假，来执行不同的逻辑。这是每一门语言逻辑结构的基础。</p>
<div><pre><code><span>let</span> year <span>=</span> <span>2015</span><span>;</span>
<span>if</span> <span>(</span>year <span>&lt;</span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too early..."</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span>year <span>></span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too late"</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Exactly!"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="循环" tabindex="-1"> 循环</h2>
<p>循环运算符的作用，是在条件控制下，零次或多次执行特定代码块。它使得重复执行成为了可能。</p>
<div><pre><code><span>let</span> result <span>=</span> <span>0</span><span>;</span>
<span>let</span> i <span>=</span> <span>1</span><span>;</span>

<span>while</span> <span>(</span>i <span>&lt;=</span> <span>100</span><span>)</span> <span>{</span>
  <span>// 计算1+2+3+...+100的结果</span>
  i <span>=</span> i <span>+</span> <span>1</span><span>;</span>
  result <span>=</span> result <span>+</span> i<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>// 结果为 0、1、2</span>
  <span>alert</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="函数" tabindex="-1"> 函数</h2>
<p>函数是程序的主要“构建模块”，</p>
<p>创建函数时，需要声明函数内容，函数内容由一系列语句(代码块) 构成。在声明函数后，使用函数即可多次调用一段代码。</p>
<p>例如:</p>
<div><pre><code><span>function</span> <span>showMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Hello everyone!"</span><span>)</span><span>;</span>
<span>}</span> <span>// 声明一个函数</span>

<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 调用它</span>
<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 可以在任意时刻调用它</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同时函数可以通过接受参数的形式来根据情况返回不同的结果，比如这是一个简单的求和函数。</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>sum1<span>,</span> sum2</span><span>)</span> <span>{</span>
  <span>return</span> sum1 <span>+</span> sum2<span>;</span>
<span>}</span>

<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span> <span>// return 3</span>
<span>sum</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span> <span>// return 11</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>小程序</title>
      <link>https://songjun520.cn/vuepress-blog2/code/mini-app/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/mini-app/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">小程序</source>
      <description>提示
在开发小程序之前。应当掌握 HTML、CSS、JavaScript 基础 以及 ES6。

</description>
      <category>小程序</category>
      <pubDate>Mon, 25 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>提示</p>
<p>在开发小程序之前。应当掌握 <a href="/code/website/html/">HTML</a>、<a href="/code/website/css/">CSS</a>、<a href="/code/language/js/guide/">JavaScript 基础</a> 以及 <a href="/code/language/js/es6/">ES6</a>。</p>
</div>

<h2 id="小程序基础简介" tabindex="-1"> 小程序基础简介</h2>
<p>在微信小程序中主要有四种文件结构: <code>wxml</code>、<code>wxss</code>、<code>js</code> 和 <code>json</code>。其中 <code>wxml</code> 对应带有 vue.js 特征的 html5，<code>wxss</code> 对应 css3，<code>js</code> 对应 ES6 标准的的 javaScript。</p>
<p>对于 QQ 小程序，其文件结构为 <code>QML</code>、<code>qss</code>、<code>js</code> 和 <code>json</code>。</p>
<div><p>提示</p>
<p>QQ 小程序本质还是换汤不换药的，且 QQ 开发者工具兼容 <code>wxml</code> 与 <code>wss</code>)</p>
</div>
<p>小程序开发与网页开发极其相似。所以必须有适当的网页开发基础。零基础的人可能很难直接上手小程序开发。</p>
<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/mini-app/guide/file-structure.html">文件结构</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/env.html">运行环境</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/config/">小程序配置</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/config/app-config.html">全局配置</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/config/page-config.html">页面配置</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/config/sitemap-config.html">sitemap 配置</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/">小程序框架</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/frame/intro.html">框架介绍</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/scene.html">场景值</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/env.html">运行环境</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/mechanism.html">运行机制</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/update.html">更新机制</a> <i>Content not supported</i></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/service/">逻辑层</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/service/lifetime.html">生命周期</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/route.html">路由</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/register.html">注册</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/app.html">App()</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/page.html">Page()</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/run.html">运行</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/module.html">模块化</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/api/">API</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/view/">视图层</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/view/wxml.html">WXML</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxss.html">WXSS</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxs.html">WXS</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/event.html">事件</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/component.html">基础组件</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/animation.html">动画</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxs.html">WXS</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxs-event.html">WXS 事件</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/model.html">建议双向绑定</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/selector.html">获取界面上的节点信息</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/selector.html">相应显示区域变化</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/rendering-cache.html">初始渲染缓存</a> <i>Content not supported</i></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/">小程序能力</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/ability/network.html">网络请求</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/storage.html">存储</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/file-system.html">文件系统</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/debug.html">调试</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="开发者工具" tabindex="-1"> 开发者工具</h2>
<ul>
<li>
<p><a href="/code/mini-app/tools/interface.html">工具界面简介</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/debug.html">调试</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/npm.html">npm</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/audit.html">体验评分</a></p>
</li>
</ul>
<h2 id="官方教程" tabindex="-1"> 官方教程</h2>
<ul>
<li><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener noreferrer">点击前往</a></li>
</ul>
<h2 id="案例" tabindex="-1"> 案例</h2>
<ul>
<li><a href="https://github.com/Hope-Studio/wxminiappdemo" target="_blank" rel="noopener noreferrer">GitHub repository</a></li>
</ul>
<h2 id="mr-song-框架说明" tabindex="-1"> Mr.Song 框架说明</h2>
<ul>
<li>
<p><a href="/code/mini-app/framework/">小程序框架使用说明</a></p>
</li>
<li>
<p><a href="/code/mini-app/framework/tag-list.html">tag 值参数表</a></p>
</li>
<li>
<p><a href="/code/mini-app/framework/page.html">setPage 库使用说明</a></p>
</li>
<li>
<p><a href="/code/mini-app/framework/simple-debug.html">界面简单开发学习指南</a></p>
</li>
<li>
<p><a href="/code/mini-app/qr-code.html">分享相关</a></p>
</li>
</ul>
<h2 id="学习视频" tabindex="-1"> 学习视频</h2>
<ul>
<li>
<p><a href="https://www.bilibili.com/video/av22790583/" target="_blank" rel="noopener noreferrer">零基础开发小程序</a>(比较新的视频，强调总体思想)</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/av11938917" target="_blank" rel="noopener noreferrer">小程序-从入门到入土</a>(比较老的视频，针对每个组件或者 API 进行了针对的讲解与示范，但部分内容已经与最新官方文档不符)</p>
</li>
</ul>
<h2 id="示例代码" tabindex="-1"> 示例代码</h2>
<ul>
<li>
<p><a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener noreferrer">小程序实例源码</a></p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg" alt="小程序示例二维码"></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://q.qq.com/wiki/" target="_blank" rel="noopener noreferrer">QQ 小程序</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener noreferrer">微信小程序</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/question" target="_blank" rel="noopener noreferrer">微信小程序社区</a>
<ul>
<li><a href="https://developers.weixin.qq.com/community/develop/list/2?id=" target="_blank" rel="noopener noreferrer">官方公告</a></li>
</ul>
</li>
</ul>
<h3 id="qq-开发者工具" tabindex="-1"> QQ 开发者工具</h3>
<p>现在很多功能还处于缺失状态，bug 到没之前那么多了。</p>
<ul>
<li>
<p><a href="https://q.qq.com/wiki/" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
<li>
<p><a href="https://q.qq.com/wiki/tools/devtool/" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
</ul>
<h2 id="微信开发者工具" tabindex="-1"> 微信开发者工具</h2>
<p>微信开发者工具用来开发与调试微信小程序和微信相关网页的官方工具。小程序使用该开发工具进行开发。</p>
<ul>
<li>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/">开发者工具教程</a></p>
</li>
<li>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html" target="_blank" rel="noopener noreferrer">官方使用指南</a></p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>小程序分享</title>
      <link>https://songjun520.cn/vuepress-blog2/code/mini-app/qr-code.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/mini-app/qr-code.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">小程序分享</source>
      <category>小程序</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="二维码生成" tabindex="-1"> 二维码生成</h2>
<p>目前小程序二维码生成选用的是<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener noreferrer">无限制生成二维码</a>。</p>
<p>我们使用 Postman 软件进行二维码的获取。</p>
<h3 id="调用凭据获取" tabindex="-1"> 调用凭据获取</h3>
<p>获取任何二维码都需要先获取 <code>access_token</code>，这是小程序全局唯一后台接口调用凭据。<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html" target="_blank" rel="noopener noreferrer">文档地址</a></p>
<p>请求方式为:</p>
<div><pre><code>GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET
</code></pre><div aria-hidden="true"><div></div></div></div><p>更多详情可以见文档。<code>AppSecret</code> 由于权限很大不在此文档中直接放置。</p>
<h3 id="无限制二维码生成" tabindex="-1"> 无限制二维码生成</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<p>在获取 <code>access_token</code> 之后就可以获取小程序二维码了。</p>
<div><pre><code>POST https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN
</code></pre><div aria-hidden="true"><div></div></div></div><p>请注意，在 Postman 软件中，首先要注意使用 <code>post</code> 方法。Body 使用 <code>raw</code>，格式选择 <code>Text</code>，需要将 <code>pretty</code> 化的 JSON 输入即可正常获取二维码。获取完二维码之后，需要在 <code>response</code> 中点击返回图片右上角的 <code>save as</code>，保存为 <code>jpg</code> 格式的文件即可保存二维码。</p>
<h2 id="小程序链接" tabindex="-1"> 小程序链接</h2>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Service_Center_messages.html" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<p>具体格式如下:</p>
<div><pre><code><span><span><span>&lt;</span>a</span>
  <span>href</span><span><span>=</span><span>"</span>不支持小程序时打开的网页<span>"</span></span>
  <span>data-miniprogram-appid</span><span><span>=</span><span>"</span>小程序的appid<span>"</span></span>
  <span>data-miniprogram-path</span><span><span>=</span><span>"</span>小程序路径<span>"</span></span>
  <span>></span></span>文本内容<span><span><span>&lt;/</span>a</span>
<span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://songjun520.cn/vuepress-blog2/code/node-js/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/node-js/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Node.js</source>
      <description>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。
</description>
      <category>Node.js</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>

<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/node-js/intro.html">Node.js 介绍</a></p>
</li>
<li>
<p><a href="/code/node-js/install.html">Node.js 与 npm 安装</a></p>
</li>
<li>
<p><a href="/code/node-js/environment.html">Node.js 环境</a></p>
</li>
<li>
<p><a href="/code/node-js/program.html">编程</a></p>
</li>
<li>
<p><a href="/code/node-js/cjs.html">Node.js CJS 模块</a></p>
</li>
</ul>
<p>以上，就是 Node.js 的简易介绍，系统学习可以查看下方的详细教程。</p>
<h2 id="初学者教程" tabindex="-1"> 初学者教程</h2>
<ul>
<li>
<p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener noreferrer">Node.js 入门</a></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn/nodejs/" target="_blank" rel="noopener noreferrer">W3CSchool</a></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/" target="_blank" rel="noopener noreferrer">地址</a></li>
</ul>
<h2 id="yarn" tabindex="-1"> Yarn</h2>
<p>快速、可靠、安全的依赖管理工具。</p>
<ul>
<li>
<p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p>
</li>
<li>
<p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p>
</li>
<li>
<p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
</ul>
<h3 id="命令" tabindex="-1"> 命令</h3>
<ul>
<li>
<p><code>yarn install</code>: 执行安装</p>
</li>
<li>
<p><code>yarn upgrade</code>: 执行升级</p>
</li>
<li>
<p><code>yarn add &lt;package&gt;</code>: 添加一个包</p>
</li>
<li>
<p><code>yarn config set cache-folder &lt;path&gt;</code>: 更改缓存文件夹</p>
</li>
<li>
<p><code>yarn config set registry &lt;registry&gt;</code>: 更改源</p>
<div><p>提示</p>
<p>在国内，建议换成淘宝源 <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener noreferrer">https://registry.npm.taobao.org</a></p>
<p>即执行</p>
<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
</code></pre><div aria-hidden="true"><div></div></div></div></div>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>模块</title>
      <link>https://songjun520.cn/vuepress-blog2/code/node-js/cjs.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/node-js/cjs.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">模块</source>
      <description>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 .js 文件就称之为一个模块(module)。
使用模块有什么好处?
最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。
使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。
</description>
      <category>Node.js</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>
<p>使用模块有什么好处?</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>

<p>在上一节，我们编写了一个 hello.js 文件，这个 hello.js 文件就是一个模块，模块的名字就是文件名(去掉.js 后缀)，所以 hello.js 文件就是名为 hello 的模块。</p>
<p>我们把 hello.js 改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>", "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数 <code>greet()</code> 是我们在 hello 模块中定义的，您可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数 <code>greet</code> 作为模块的输出暴露出去，这样其他模块就可以使用 <code>greet</code> 函数了。</p>
<p>问题是其他模块怎么使用 hello 模块的这个 <code>greet</code> 函数呢? 我们再编写一个 <code>main.js</code> 文件，调用 <code>hello</code> 模块的 <code>greet</code> 函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>// 引入hello模块:</span>
<span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Michael"</span><span>;</span>

<span>greet</span><span>(</span>s<span>)</span><span>;</span> <span>// Hello, Michael!</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意到引入 <code>hello</code> 模块用 Node.js 提供的 <code>require</code> 函数:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>引入的模块作为变量保存在 <code>greet</code> 变量中，那 greet 变量到底是什么东西? 其实变量 <code>greet</code> 就是在 <code>hello.js</code> 中我们用 <code>module.exports = greet;</code> 输出的 <code>greet</code> 函数。所以，<code>main.js</code> 就成功地引用了 <code>hello.js</code> 模块中定义的 <code>greet()</code> 函数，接下来就可以直接使用它了。</p>
<p>在使用 <code>require()</code> 引入模块的时候，请注意模块的相对路径。因为 main.js 和 hello.js 位于同一个目录，所以我们用了当前目录.:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span> <span>// 不要忘了写相对目录!</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果只写模块名:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>则 Node.js 会依次在内置模块、全局模块和当前模块下查找 hello.js，您很可能会得到一个错误:</p>
<div><pre><code>module<span>.</span>js
    <span>throw</span> err<span>;</span>
          <span>^</span>
<span>Error</span><span>:</span> Cannot find module <span>'hello'</span>
    at Function<span>.</span>Module<span>.</span>_resolveFilename
    at Function<span>.</span>Module<span>.</span>_load
    <span>...</span>
    at Function<span>.</span>Module<span>.</span>_load
    at Function<span>.</span>Module<span>.</span>runMain
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>遇到这个错误，您要检查:</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h2 id="commonjs-规范" tabindex="-1"> CommonJS 规范</h2>
<p>这种模块加载机制被称为 <code>CommonJS</code> 规范。在这个规范下，每个 <code>.js</code> 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code> 和 <code>main.js</code> 都申明了全局变量 <code>const s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量(函数也是变量)，可以用 <code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用 <code>const ref = require('module_name');</code> 就拿到了引用模块的变量。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>要在模块中对外输出变量，用:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> variable<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用:</p>
<div><pre><code><span>const</span> foo <span>=</span> <span>require</span><span>(</span><span>"other_module"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h2 id="深入了解模块原理" tabindex="-1"> 深入了解模块原理</h2>
<p>如果您想详细地了解<strong>CommonJS</strong>的模块实现原理，请继续往下阅读。如果不想了解，请结束阅读。</p>
<p>当我们编写 JavaScript 代码时，我们可以申明全局变量:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"global"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在浏览器中，大量使用全局变量可不好。如果您在 <code>a.js</code> 中使用了全局变量 s，那么，在 <code>b.js</code> 中也使用全局变量 s，将造成冲突，<code>b.js</code> 中对 s 赋值会改变 <code>a.js</code> 的运行逻辑。</p>
<p>也就是说，JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那 Node.js 是如何实现这一点的?</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js 也并不会增加任何 JavaScript 语法。实现“模块”功能的奥妙就在于 JavaScript 是一种函数式编程语言，它支持闭包。如果我们把一段 JavaScript 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的 <code>hello.js</code> 代码是这样的:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
<span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>Node.js 加载了 hello.js 后，它可以把代码包装一下，变成这样执行:</p>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
  <span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>// hello.js代码结束</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样一来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。如果 Node.js 继续加载其他模块，这些模块中定义的“全局”变量 <code>s</code> 也互不干扰。</p>
<p>所以，Node.js 利用 JavaScript 的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出 <code>module.exports</code> 怎么实现?</p>
<p>这个也很容易实现，Node.js 可以先准备一个对象 <code>module</code>:</p>
<div><pre><code><span>// 准备module对象:</span>
<span>const</span> module <span>=</span> <span>{</span>
  <span>id</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
<span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>module</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>}</span>

  module<span>.</span>exports <span>=</span> greet<span>;</span>
  <span>// hello.js代码结束</span>
  <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>
<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>)</span><span>;</span>
<span>// 保存module:</span>
<span>save</span><span>(</span>module<span>,</span> exported<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，变量 module 是 Node.js 在加载 js 文件前准备的一个变量，并将其传入加载函数，我们在 <code>hello.js</code> 中可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>通过把参数 <code>module</code> 传递给 <code>load()</code> 函数，<code>hello.js</code> 就顺利地把一个变量传递给了 Node.js 执行环境，Node.js 会把 module 变量保存到某个地方。</p>
<p>由于 Node.js 保存了所有导入的 module，当我们用 <code>require()</code> 获取 module 时，Node.js 找到对应的 module，把这个 module 的 <code>exports</code> 变量返回，这样，另一个模块就顺利拿到了模块的输出:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>以上是 Node.js 实现 JavaScript 模块的一个简单的原理介绍。</p>
<h2 id="module-exports-vs-exports" tabindex="-1"> module.exports vs exports</h2>
<p>很多时候，您会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量:</p>
<p>方法一: 对 module.exports 赋值:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>hello</span><span>:</span> hello<span>,</span>
  <span>greet</span><span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>方法二: 直接使用 exports:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

exports<span>.</span>hello <span>=</span> hello<span>;</span>
exports<span>.</span>greet <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是您不可以直接对 exports 赋值:</p>
<div><pre><code><span>// 代码可以执行，但是模块并没有输出任何变量:</span>
exports <span>=</span> <span>{</span>
  <span>hello</span><span>:</span> hello<span>,</span>
  <span>greet</span><span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您对上面的写法感到十分困惑，不要着急，我们来分析 Node.js 的加载机制:</p>
<p>首先，Node.js 会把整个待加载的 hello.js 文件放入一个包装函数 load 中执行。在执行这个 load()函数前，Node.js 准备好了 module 变量:</p>
<div><pre><code><span>const</span> module <span>=</span> <span>{</span>
  <span>id</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>load()</code> 函数最终返回 <code>module.exports</code>:</p>
<div><pre><code><span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>exports<span>,</span> module</span><span>)</span> <span>{</span>
    <span>// hello.js的文件内容</span>
    <span>...</span>
    <span>// load函数返回:</span>
    <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>

<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>.</span>exports<span>,</span> module<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，默认情况下，Node.js 准备的 <code>exports</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code>，于是，我们可以写:</p>
<div><pre><code>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也可以写:</p>
<div><pre><code>module<span>.</span>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
module<span>.</span>exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>换句话说，Node.js 默认给您准备了一个空对象 <code>{}</code>，这样您可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>给 <code>exports</code> 赋值是无效的，因为赋值后，<code>module.exports</code> 仍然是空对象 <code>{}</code>。</p>
<h2 id="结论" tabindex="-1"> 结论</h2>
<p>如果要输出一个键值对象 <code>{}</code>，可以利用 <code>exports</code> 这个已存在的空对象 <code>{}</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对 <code>module.exports</code> 对象赋值。</p>
<p>所以我们可以得出结论: 直接对 <code>module.export</code>s 赋值，可以应对任何情况:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"foo"</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>或者:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>最终，我们强烈建议使用 <code>module.exports = xxx</code> 的方式来输出模块变量，这样，您只需要记忆一种方法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>搭建 Node 开发环境</title>
      <link>https://songjun520.cn/vuepress-blog2/code/node-js/environment.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/node-js/environment.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">搭建 Node 开发环境</source>
      <description>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Song 隆重向大家推荐 Node.js 集成开发环境: Visual Studio Code。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。
</description>
      <category>Node.js</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Song 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>

<div><p>相关信息</p>
<p>有关 VS Code 使用教程请<a href="/software/vscode/">访问这里</a></p>
</div>
<h2 id="运行和调试-javascript" tabindex="-1"> 运行和调试 JavaScript</h2>
<p>在 VS Code 中，我们可以非常方便地运行 JavaScript 文件。</p>
<p>VS Code 以文件夹作为工程目录 (Workspace Dir)，所有的 JavaScript 文件都存放在该目录下。此外，VS Code 在工程目录下还需要一个 <code>.vscode</code> 的配置目录，里面存放里 VS Code 需要的配置文件。</p>
<p>假设我们在 <code>C:\Work\</code> 目录下创建了一个 hello 目录作为工程目录，并编写了一个 <code>hello.js</code> 文件，则该工程目录的结构如下:</p>
<div><pre><code>hello/ &lt;-- workspace dir
|
├─ hello.js &lt;-- JavaScript file
|
└─ .vscode/ &lt;-- VS Code config
      |
      └ launch.json &lt;-- VS Code config file for JavaScript
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以用 VS Code 快速创建 <code>launch.json</code>，然后修改如下:</p>
<div><pre><code><span>{</span>
  <span>"version"</span><span>:</span> <span>"0.2.0"</span><span>,</span>
  <span>"configurations"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"name"</span><span>:</span> <span>"Run hello.js"</span><span>,</span>
      <span>"type"</span><span>:</span> <span>"node"</span><span>,</span>
      <span>"request"</span><span>:</span> <span>"launch"</span><span>,</span>
      <span>"program"</span><span>:</span> <span>"${workspaceRoot}/hello.js"</span><span>,</span>
      <span>"stopOnEntry"</span><span>:</span> <span>false</span><span>,</span>
      <span>"args"</span><span>:</span> <span>[</span><span>]</span><span>,</span>
      <span>"cwd"</span><span>:</span> <span>"${workspaceRoot}"</span><span>,</span>
      <span>"preLaunchTask"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeExecutable"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeArgs"</span><span>:</span> <span>[</span><span>"--nolazy"</span><span>]</span><span>,</span>
      <span>"env"</span><span>:</span> <span>{</span>
        <span>"NODE_ENV"</span><span>:</span> <span>"development"</span>
      <span>}</span><span>,</span>
      <span>"externalConsole"</span><span>:</span> <span>false</span><span>,</span>
      <span>"sourceMaps"</span><span>:</span> <span>false</span><span>,</span>
      <span>"outDir"</span><span>:</span> <span>null</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>有了配置文件，即可使用 VS Code 调试 JavaScript。</p>
<h2 id="视频演示" tabindex="-1"> 视频演示</h2>
<ul>
<li><a href="https://www.bilibili.com/video/av5827351/" target="_blank" rel="noopener noreferrer">视频演示</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装 Node.js</title>
      <link>https://songjun520.cn/vuepress-blog2/code/node-js/install.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/node-js/install.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">安装 Node.js</source>
      <description>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。
</description>
      <category>Node.js</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>

<h2 id="安装-node-js" tabindex="-1"> 安装 Node.js</h2>
<p>目前 Node.js 的 LTS 版本是 16.15.1。首先，从 Node.js 官网下载对应平台的安装程序。点击 LTS 版本的下载按钮。</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></li>
</ul>
<h3 id="安装过程" tabindex="-1"> 安装过程</h3>
<ul>
<li>
<p>在 Windows 上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>
<p>在安装过程中，无需勾选 &quot;Automatically install the necessary tools&quot;。选中此项会在电脑中安装 VS 等日常开发使用不到的软件。</p>
<p>安装完成后，在 Windows 环境下，请打开命令提示符，然后输入 <code>node -v</code> ，如果安装正常，您应该看到 <code>v16.15.1</code> 这样的输出:</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>IEUser<span>></span>node -v
v16.15.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>继续在命令提示符输入 node，此刻您将进入 Node.js 的交互环境。在交互环境下，您可以输入任意 JavaScript 语句，例如 <code>100 + 200</code>，回车后将得到输出结果。</p>
<p>要退出 Node.js 环境，连按两次 <code>Ctrl + C</code> 。</p>
</li>
<li>
<p>在 Mac 或 Linux 环境下，请打开终端，然后输入 <code>node -v</code>，您应该看到如下输出:</p>
<div><pre><code>$ <span>node</span> -v
v16.15.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
</ul>
<h2 id="npm" tabindex="-1"> npm</h2>
<p>npm 是 Node.js 的包管理工具(package manager)。</p>
<p>我们在 Node.js 上开发时，会用到很多别人写的 JavaScript 代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生: 大家都把自己开发的模块打包后放到 npm 官网上，如果要使用，直接通过 npm 安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块 A，而模块 A 又依赖于模块 B，模块 B 又依赖于模块 X 和模块 Y，npm 可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm 究竟在哪?</p>
<p>其实 npm 已经在 Node.js 安装的时候顺带装好了。我们在命令提示符或者终端输入 <code>npm -v</code>，应该看到类似的输出:</p>
<div><pre><code>C:<span>\</span><span>></span>npm -v
<span>8.12</span>.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>如果版本号太小，说明 npm 版本较低，请使用此命令升级到最新版本: <code>npm i -g npm</code>。</p>
</blockquote>
<p>如果直接输入 <code>npm</code>，您会看到类似下面的输出:</p>
<div><pre><code>C:<span>\</span><span>></span> <span>npm</span>
<span>npm</span> <span>&lt;</span>command<span>></span>

Usage:

<span>npm</span> <span>install</span>        <span>install</span> all the dependencies <span>in</span> your project
<span>npm</span> <span>install</span> <span>&lt;</span>foo<span>></span>  <span>add</span> the <span>&lt;</span>foo<span>></span> dependency to your project
    <span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的一大堆文字告诉您，npm 需要附带命令。现在我们不用关心这些命令，后面会一一讲到。目前，您只需要确保 npm 正确安装了，能运行就行。</p>
<h2 id="国内镜像站" tabindex="-1"> 国内镜像站</h2>
<p>大家都知道天朝是有墙的，有的时候，访问国外的 Node.js 服务器可能会十分缓慢以至于您想把它砸了。</p>
<p>所以贴心的马云爸爸提供了淘宝镜像源。你可以将 npm 的源配置为国内镜像源，以在每次安装依赖的时候从国内镜像站拉取镜像。这可以极大的提升安装速度。</p>
<div><p>注</p>
<p>如果官方源的速度还可以的话请尽可能使用官方源。</p>
<p>国内源毕竟是镜像站点，同步官方源的包会出现延迟，所以有时候你可能会遇到 <code>version xxx not found</code> 之类的错误，这是因为所需要的版本还没来得及被镜像站点同步所导致。</p>
<p>你可以通过访问 <code>npmmirror.com/sync/&lt;包名&gt;</code> 来手动同步一个包。</p>
</div>
<p>设置及国内源的命令如下:</p>
<div><pre><code><span>npm</span> config <span>set</span> registry https://registry.npmmirror.com/
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>注意</p>
<p><code>https://registry.npm.taobao.org/</code> 是老的淘宝源地址，现已停止维护，请不要使用!!!</p>
</div>
<h2 id="启用-corepack" tabindex="-1"> 启用 Corepack</h2>
<p>Node.js 自带的包管理工具 npm 并不是那么的强大，其安装速度也很慢，所以社区开发了一些其他的包管理工具如 <code>yarn</code> 和 <code>pnpm</code>，它们有自己的优势。</p>
<p>Mr.Song 推荐使用 pnpm 进行包管理，因为它使用硬链接索引包文件，安装速度更快而且节省磁盘空间。</p>
<p>从 v16 开始，Node.js 引入了 Corepack 工具，并在 package.json 支持了 <code>packageManager</code> 选项以支持第三方管理工具。</p>
<p>你需要通过下方命令启用 Corepack:</p>
<div><pre><code>corepack <span>enable</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样每个项目会自动应用根目录 package.json 中的 <code>packageManager</code> 选项。比如设置 <code>&quot;packageManager&quot;: &quot;pnpm@7.2.1&quot;</code> 的时候，会自动下载并使用 <code>pnpm@7.2.1</code>。</p>
<div><p>设置全局的 packageManager</p>
<p>你可以使用 <code>corepack prepare packageManager@semver</code> 来全局准备一个 packageManager 版本，并使用 <code>--activate</code> 选新娘 全局激活。</p>
<p>比如以下命令下载 <code>pnpm@7.2.1</code> 并将其作为默认的全局包管理器:</p>
<div><pre><code>corepack prepare pnpm@7.2.1 --activate
</code></pre><div aria-hidden="true"><div></div></div></div></div>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>请在本机安装 Node.js 环境，并确保 Node.js 和 npm 能正常运行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://songjun520.cn/vuepress-blog2/code/node-js/intro.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/node-js/intro.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Node.js</source>
      <description>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。
Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。
</description>
      <category>Node.js</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>
<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>

<p>众所周知，在 Netscape 设计出 JavaScript 后的短短几个月，JavaScript 事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过 IE 击败了 Netscape 后一统桌面，结果几年时间，浏览器毫无进步。(2001 年推出的古老的 IE 6 到今天仍然有人在使用! )</p>
<p>没有竞争就没有发展。微软认为 IE6 浏览器已经非常完善，几乎没有可改进之处，然后解散了 IE6 开发团队! 而 Google 却认为支持现代 Web 应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行 JavaScript 的引擎性能还可提升 10 倍。</p>
<p>先是 Mozilla 借助已壮烈牺牲的 Netscape 遗产在 2002 年推出了 Firefox 浏览器，紧接着 Apple 于 2003 年在开源的 KHTML 浏览器的基础上推出了 WebKit 内核的 Safari 浏览器，不过仅限于 Mac 平台。</p>
<p>随后，Google 也开始创建自家的浏览器。他们也看中了 WebKit 内核，于是基于 WebKit 内核推出了 Chrome 浏览器。</p>
<p>Chrome 浏览器是跨 Windows 和 Mac 平台的，并且，Google 认为要运行现代 Web 应用，浏览器必须有一个性能非常强劲的 JavaScript 引擎，于是 Google 自己开发了一个高性能 JavaScript 引擎，名字叫 V8，以 BSD 许可证开源。</p>
<p>现代浏览器大战让微软的 IE 浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队! 回过头再追赶却发现，支持 HTML5 的 WebKit 已经成为手机端的标准了，IE 浏览器从此与主流移动端设备绝缘。</p>
<h2 id="浏览器大战和-node-js-的关系" tabindex="-1"> 浏览器大战和 Node.js 的关系</h2>
<p>话说有个叫 Ryan Dahl 的歪果仁，他的工作是用 C/C++写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发 Web 服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript 引擎。让 Google 投资去优化 V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在 2009 年，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。虽然名字很土，但是，Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</p>
<h2 id="在-node-js-上运行的-javascript-相比其他后端开发语言的优势" tabindex="-1"> 在 Node.js 上运行的 JavaScript 相比其他后端开发语言的优势</h2>
<p>最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</p>
<p>其次，JavaScript 语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉 JavaScript 就是个“玩具语言”。但是，在 Node.js 环境下，通过模块化的 JavaScript 代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的 ECMAScript 6 标准，可以完全满足工程上的需求。</p>
<blockquote>
<p>我还听说过 io.js，这又是什么鬼?</p>
</blockquote>
<p>因为 Node.js 是开源项目，虽然由社区推动，但幕后一直由 Joyent 公司资助。由于一群开发者对 Joyent 公司的策略不满，于 2014 年从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</p>
<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent 公司表示要和解，于是，io.js 项目又决定回归 Node.js。</p>
<p>具体做法是将来 io.js 将首先添加新的特性，如果大家测试用得爽，就把新特性加入 Node.js。Io.js 是“尝鲜版”，而 Node.js 是线上稳定版，相当于 Fedora Linux 和 RHEL 的关系。</p>
<p>本章教程的所有代码都在 Node.js 上调试通过。如果您要尝试 io.js 也是可以的，不过两者如果遇到一些区别请自行查看 io.js 的文档。</p>
<h2 id="node-js-相关链接" tabindex="-1"> Node.js 相关链接</h2>
<ul>
<li>
<p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></p>
</li>
<li>
<p><a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener noreferrer">Node.js 最新文档</a></p>
</li>
<li>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/" target="_blank" rel="noopener noreferrer">Node.js 最新 API 文档</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>第一个 Node 程序</title>
      <link>https://songjun520.cn/vuepress-blog2/code/node-js/program.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/node-js/program.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">第一个 Node 程序</source>
      <description>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。
从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。
</description>
      <category>Node.js</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>

<p>那么问题来了: 文本编辑器到底哪家强?</p>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="/code/windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>如果您的电脑上已经安装了<strong>Sublime Text</strong>，或者<strong>Notepad++</strong>，也可以用来编写 JavaScript 代码，注意用 UTF-8 格式保存。</p>
<p>最方便的，当然是 Mr.Song 强力安利的 VS Code 了。</p>
<p>输入以下代码:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>"Hello, world."</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>第一行总是写上 <code>'use strict';</code> 是因为我们总是以严格模式运行 JavaScript 代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如 <code>C:\Workspace</code>，把文件保存为 <code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到 hello.js 所在目录，然后输入以下命令运行这个程序了:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
Hello, world.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>也可以保存为别的名字，比如 <code>first.js</code>，但是必须要以 <code>.js</code> 结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有 <code>hello.js</code> 这个文件，运行 <code>node hello.js</code> 就会报错:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
module.js:338
    throw err<span>;</span>
          ^
Error: Cannot <span>find</span> module <span>'C:\Workspace\hello.js'</span>
    at Function.Module._resolveFilename
    at Function.Module._load
    at Function.Module.runMain
    at startup
    at node.js
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>报错的意思就是，没有找到 <code>hello.js</code> 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h2 id="命令行模式和-node-js-交互模式" tabindex="-1"> 命令行模式和 Node.js 交互模式</h2>
<p>请注意区分命令行模式和 Node.js 交互模式。</p>
<p>看到类似 <code>C:\&gt;</code> 是在 Windows 提供的命令行模式:</p>
<p><img src="@source/code/node-js/assets/run-node-hello.png" alt="run-node-hello"></p>
<p>在命令行模式下，可以执行 Node.js 进入 Node.js 交互式环境，也可以执行 Node.js <code>hello.js</code> 运行一个 <code>.js</code> 文件。</p>
<p>看到<code>&gt;</code> 是在 Node.js 交互式环境下:</p>
<p><img src="@source/code/node-js/assets/node-interactive-env.png" alt="node-interactive-env"></p>
<p>在 Node.js 交互式环境下，我们可以输入 JavaScript 代码并立刻执行。</p>
<p>此外，在命令行模式运行.js 文件和在 Node.js 交互式环境下直接运行 JavaScript 代码有所不同。Node.js 交互式环境会把每一行 JavaScript 代码的结果自动打印出来，但是，直接运行 JavaScript 文件却不会。</p>
<p>例如，在 Node.js 交互式环境下，输入:</p>
<div><pre><code><span>></span> <span>100</span> + <span>200</span> + <span>300</span><span>;</span>
<span>600</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>直接可以看到结果 600。</p>
<p>但是，写一个 <code>calc.js</code> 的文件，内容如下:</p>
<div><pre><code><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后在命令行模式下执行:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
</code></pre><div aria-hidden="true"><div></div></div></div><p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用 <code>console.log()</code> 打印出来。把 <code>calc.js</code> 改造一下:</p>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>再执行，就可以看到结果:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
<span>600</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="使用严格模式" tabindex="-1"> 使用严格模式</h2>
<p>如果在 JavaScript 文件开头写上 <code>'use strict';</code>，那么 Node.js 在执行该 JavaScript 时将使用严格模式。但是，在服务器环境下，如果有很多 JavaScript 文件，每个文件都写上 <code>'use strict';</code> 很麻烦。我们可以给 Node.js 传递一个参数，让 Node.js 直接为所有 js 文件开启严格模式:</p>
<div><pre><code><span>node</span> --use_strict calc.js
</code></pre><div aria-hidden="true"><div></div></div></div><p>后续代码，如无特殊说明，我们都会直接给 Node.js 传递 <code>--use_strict</code> 参数来开启严格模式。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>用文本编辑器写 JavaScript 程序，然后保存为后缀为 <code>.js</code> 的文件，就可以用 Node.js 直接运行这个程序了。</p>
<p>Node.js 的交互模式和直接运行 <code>.js</code> 文件有什么区别呢?</p>
<p>直接输入 Node.js 进入交互模式，相当于启动了 Node.js 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行 <code>node hello.js</code> 文件相当于启动了 Node.js 解释器，然后一次性把 <code>hello.js</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>
<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node.js 交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27 寸的超大显示器!</p>
]]></content:encoded>
    </item>
    <item>
      <title>React</title>
      <link>https://songjun520.cn/vuepress-blog2/code/react/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/react/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">React</source>
      <category>前端</category>
      <pubDate>Fri, 08 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="创建-react-项目" tabindex="-1"> 创建 React 项目</h2>
<p>使用 <code>create-react-app</code> 工具。</p>
<p>创建普通模板:</p>
<div><pre><code>npx create-react-app xxx
</code></pre><div aria-hidden="true"><div></div></div></div><p>创建 TS 模板:</p>
<div><pre><code>npx create-react-app xxx --template typescript
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="react-文档" tabindex="-1"> React 文档</h2>
<ul>
<li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://react.docschina.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">中文文档</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js</title>
      <link>https://songjun520.cn/vuepress-blog2/code/vue/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/vue/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Vue.js</source>
      <category>基础</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue.js 是世界上主流的前端框架。</p>
<p>官方介绍为：渐近式 JavaScript 框架。一款用于构建 Web 界面，易学易用，性能出色且功能丰富的框架。</p>
<h2 id="vue-js-教程目录" tabindex="-1"> Vue.js 教程目录</h2>
<ul>
<li>
<p><a href="/code/vue/install.html">开发环境安装</a></p>
</li>
<li>
<p><a href="/code/vue/get-started.html">起步上手</a></p>
</li>
<li>
<p><a href="/code/vue/vue.html">Vue 单文件组件说明</a></p>
</li>
</ul>
<h2 id="vue-生态" tabindex="-1"> Vue 生态</h2>
<h3 id="vue-router" tabindex="-1"> Vue Router</h3>
<ul>
<li>
<p><a href="/code/vue/router/">Vue Router 讲解</a></p>
</li>
<li>
<p><a href="/code/vue/router/demo.html">Vue Router Demo</a></p>
</li>
</ul>
<h3 id="vuex" tabindex="-1"> Vuex</h3>
<ul>
<li>
<p><a href="/code/vue/vuex/">Vuex 讲解</a></p>
</li>
<li>
<p><a href="/code/vue/vuex/demo.html">Vuex Demo</a></p>
</li>
</ul>
<h3 id="vue-cli" tabindex="-1"> Vue Cli</h3>
<ul>
<li>
<p><a href="/code/vue/cli/intro.html">Vue Cli 介绍</a></p>
</li>
<li>
<p><a href="/code/vue/cli/quick-dev.html">使用 Vue Cli 进行快速开发</a></p>
</li>
<li>
<p><a href="/code/vue/cli/file.html">Vue Cli 文件处理</a></p>
</li>
</ul>
<h3 id="其他-vue-生态" tabindex="-1"> 其他 Vue 生态</h3>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/basic/vuepress/" target="_blank" rel="noopener noreferrer">VuePress</a>: 静态站点生成器；</li>
<li><a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener noreferrer">Ant Design Vue</a>: 阿里的一套 UI 组件库；</li>
<li><a href="https://bootstrap-vue.js.org/" target="_blank" rel="noopener noreferrer">BootstrapVue</a></li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue.js 介绍</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer">Vue.js API</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://cli.vuejs.org/zh/guide/cli-service.html" target="_blank" rel="noopener noreferrer">Vue CLI 3 介绍</a></p>
</li>
<li>
<p><a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener noreferrer">Vue CLI 3 配置</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="noopener noreferrer">Vue Router 介绍</a></p>
</li>
<li>
<p><a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener noreferrer">Vue Router 配置</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">Vuex 介绍</a></p>
</li>
<li>
<p><a href="https://vuex.vuejs.org/zh/api/" target="_blank" rel="noopener noreferrer">Vuex 配置</a></p>
</li>
</ul>
<h2 id="其他文档" tabindex="-1"> 其他文档</h2>
<ul>
<li>
<p><a href="/code/vue/component.html">各组件使用说明</a></p>
</li>
<li>
<p><a href="/code/vue/compare.html">Vue 与小程序的异同</a></p>
</li>
<li>
<p>VueConf 视频</p>
<ul>
<li>
<p><a href="https://www.yuque.com/vueconf/2019/qg1yms" target="_blank" rel="noopener noreferrer">Vue Beyond Vue Loader</a></p>
</li>
<li>
<p><a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener noreferrer">尤雨溪演讲视频</a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/VueConf2019SH_Evan.pdf" target="_blank" rel="noopener noreferrer">尤雨溪演讲 PPT</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/intro-to-vuepres-1.x.pdf" target="_blank" rel="noopener noreferrer">VuePress 介绍</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.pdf" target="_blank" rel="noopener noreferrer">Vue 单元测试</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/%E4%BD%BF%E7%94%A8Vue%E5%AE%9E%E7%8E%B00%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92-winter.pdf" target="_blank" rel="noopener noreferrer">使用 Vue 实现 0 代码交互</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%20%E5%BC%80%E5%8F%91%20ECharts%20%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener noreferrer">Echart 与 Vue</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%20Beyond%20Vue%20Loader.pdf" target="_blank" rel="noopener noreferrer">Vue Loader</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Mars%E6%A1%86%E6%9E%B6%E5%88%86%E4%BA%AB-vueconf.pdf" target="_blank" rel="noopener noreferrer">基于 Vue 的多端框架</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 与小程序的异同</title>
      <link>https://songjun520.cn/vuepress-blog2/code/vue/compare.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/vue/compare.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Vue 与小程序的异同</source>
      <description>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。
</description>
      <category>Vue</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。</p>

<h2 id="优缺点比较" tabindex="-1"> 优缺点比较</h2>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>小程序</td>
<td>小程序底层由微信框架驱动，每个界面是单独的 JS 文件，页面切换以及全局生命周期丰富完善。小程序具有相当完备的 API。</td>
<td>小程序是由 JSCore 驱动逻辑层，视图层采用 Webview，故没有 DOM 节点的概念，只有渲染出的虚拟节点，所以无法动态删除或添加节点，无法使用一切 DOM 相关 API。小程序组件生命周期不够强大。小程序的 Webview 渲染存在一定的性能问题。小程序视图层与逻辑层通过 Jsbridge 连接，数据传输及渲染有延时。</td>
</tr>
<tr>
<td>vue</td>
<td>Vue 的实质是动态监测并托管 DOM 节点。由于 Vue 是网页开发，拥有 DOM 树，可以使用 DOM 相关 API。Vue 组件拥有更全面的生命周期，同时可以动态渲染组件。Vue 的组件传递数据方式默认为单向绑定</td>
<td>由于 Vue 的组件本质是监测 DOM 树，故其组件只能有一个根节点。同时 Vue 的界面路由依赖于 History API，其界面切换周期与逻辑不够强大。</td>
</tr>
</tbody>
</table>
<h2 id="代码区别" tabindex="-1"> 代码区别</h2>
<p>小程序与 Vue 在代码写法上极其相似，但稍有不同。</p>
<h3 id="数据绑定" tabindex="-1"> 数据绑定</h3>
<h4 id="小程序数据绑定" tabindex="-1"> 小程序数据绑定</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span>class</span><span><span>=</span><span>"</span>text1 {{a}} {{b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span>}}<span>"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div>
<p>小程序在所有内容上都使用 Muscle 语法 (<code>{{Javascript表达式}}</code>) 的写法。</p>
</div>
<h4 id="vue-数据绑定" tabindex="-1"> Vue 数据绑定</h4>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>text1<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>a+<span>'</span> <span>'</span>+ b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span><span>"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>Vue 在标签名属性用 <code>v-bind:prop=&quot;Javascript表达式&quot;</code> 的写法、其简写为 <code>:prop=&quot;&quot;</code>，在标签内容处使用 Muscle 语法。</p>
</div>
<h3 id="条件渲染" tabindex="-1"> 条件渲染</h3>
<h4 id="小程序条件渲染" tabindex="-1"> 小程序条件渲染</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>if</span><span><span>=</span><span>"</span>{{condition1}}<span>"</span></span><span>></span></span>板块只有 condition1 为 true 时才会渲染<span><span><span>&lt;/</span>view</span><span>></span></span>


<span><span><span>&lt;</span>block</span> <span><span>wx:</span>if</span><span><span>=</span><span>"</span>{{condition2}}<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>内容1<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>内容2<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>
    <span><span><span>&lt;</span>view</span><span>></span></span>内容3<span><span><span>&lt;/</span>view</span><span>></span></span>
    <span><span><span>&lt;</span>view</span><span>></span></span>内容4<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>
    这是一个拥有很多兄弟标签的代码块.
    虚拟标签 block 会把其当作一个整体用作条件渲染。
  <span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;/</span>block</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html" target="_blank" rel="noopener noreferrer">小程序条件渲染文档</a></p>
</div>
<h4 id="vue-条件渲染" tabindex="-1"> Vue 条件渲染</h4>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>condition<span>"</span></span><span>></span></span>板块只有 condition 为 true 时才会渲染<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>{{condition2}}<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>内容1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>内容2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>内容3<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>内容4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    Vue 没有相关虚拟标签，且只能监听一个标签。所以只能建立一个没有样式的 div
    标签将多个并列标签抱起来。这样 Vue 就会因监听最外层 div
    会把其当作一个整体用作条件渲染。
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 条件渲染文档</a></p>
</div>
<h3 id="循环渲染" tabindex="-1"> 循环渲染</h3>
<h4 id="小程序循环渲染" tabindex="-1"> 小程序循环渲染</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>for</span><span><span>=</span><span>"</span>{{array}}<span>"</span></span> <span><span>wx:</span>for-item</span><span><span>=</span><span>"</span>element<span>"</span></span> <span><span>wx:</span>for-index</span><span><span>=</span><span>"</span>index<span>"</span></span><span>></span></span>
  {{index}} is {{element}}
<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>实际渲染结果为:</p>
<div><pre><code><span><span><span>&lt;</span>view</span><span>></span></span>1<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>2<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>3<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>4<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>5<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html" target="_blank" rel="noopener noreferrer">小程序循环渲染文档</a></p>
</div>
<h4 id="vue-循环渲染" tabindex="-1"> Vue 循环渲染</h4>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>v-for</span><span><span>=</span><span>"</span>(element,index) in array<span>"</span></span><span>></span></span>
       {{index}} is {{ element }}
    <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 循环渲染文档</a></p>
</div>
<h2 id="生命周期" tabindex="-1"> 生命周期</h2>
<h3 id="页面生命周期" tabindex="-1"> 页面生命周期</h3>
<h4 id="小程序生命周期" tabindex="-1"> 小程序生命周期</h4>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" alt="小程序页面生命周期"></p>
<h4 id="vue-页面生命周期" tabindex="-1"> Vue 页面生命周期</h4>
<p><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">Vue 页面生命周期</a></p>
<h3 id="组件生命周期" tabindex="-1"> 组件生命周期</h3>
<h4 id="小程序组件生命周期" tabindex="-1"> 小程序组件生命周期</h4>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html" target="_blank" rel="noopener noreferrer">小程序组件生命周期</a></p>
<h4 id="vue-组件生命周期" tabindex="-1"> Vue 组件生命周期</h4>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue组件生命周期"></p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" type="image/png"/>
    </item>
    <item>
      <title>组件使用说明</title>
      <link>https://songjun520.cn/vuepress-blog2/code/vue/component.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/vue/component.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">组件使用说明</source>
      <description>Mr.Song 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。
</description>
      <category>Vue</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Mr.Song 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。</p>

<h2 id="常规组件" tabindex="-1"> 常规组件</h2>
<div><p>提示</p>
<p>所有以 <code>Base</code> 开头的组件都包含如下属性:</p>
<p>| 属性 | 必填  |       类型       | 内容      |
| ---- | :---: | :--------------: | --------- | --- |
| myId |  是   | Number 或 String | 组件的 ID |     |</p>
</div>
<p>以下是项目中中常用的组件。</p>
<h3 id="basehead" tabindex="-1"> BaseHead</h3>
<p>页面标题文字</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>页面选项卡文字</td>
</tr>
</tbody>
</table>
<h3 id="basetitle" tabindex="-1"> BaseTitle</h3>
<p>段落间大标题</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>标题文字</td>
<td></td>
</tr>
<tr>
<td>myStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
</tbody>
</table>
<h3 id="basep" tabindex="-1"> BaseP</h3>
<p>段落文字(可带图)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>段落的文字</td>
<td>可以识别连续的空格，使用 <code>\n</code> 表示回车，也可直接使用 <code>&lt;br /&gt;</code> 换行</td>
</tr>
<tr>
<td>head</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>段落的标题</td>
<td></td>
</tr>
<tr>
<td>headStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
<tr>
<td>myStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td>会在段落后渲染一张图片</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的描述文字</td>
<td>会自动在文字前加 <code>▲</code></td>
</tr>
</tbody>
</table>
<h3 id="baseimg" tabindex="-1"> BaseImg</h3>
<p>图片</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的描述文字</td>
<td>会自动在文字前加 ▲</td>
</tr>
</tbody>
</table>
<h3 id="baselist" tabindex="-1"> BaseList</h3>
<p>列表</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>列表内容</td>
<td></td>
</tr>
<tr>
<td>head</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Boolean</td>
<td>列表的标题</td>
<td>默认为 <code>''</code>，设置 <code>false</code> 取消显示列表标题，否则即使不设置也会显示一个空标题</td>
</tr>
<tr>
<td>foot</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>列表的页脚文字</td>
<td>默认为 <code>''</code>,不显示页脚</td>
</tr>
</tbody>
</table>
<h3 id="basegrid" tabindex="-1"> BaseGrid</h3>
<p>九宫格</p>
<p>| 属性    | 必填  |       类型        | 内容             |
| ------- | :---: | :---------------: | ---------------- | ------------------------------------------------------------------------------ |
| content |  是   |    GirdItem[]     | 九宫格单元内容   |
| head    |  否   | String 或 Boolean | 九宫格的标题     | 默认为 <code>''</code>，设置 <code>false</code> 取消显示九宫格标题，否则即使不设置也会显示一个空标题 |
| foot    |  否   |      String       | 九宫格的页脚文字 | 默认为 <code>''</code>,不显示页脚                                                         |</p>
<ul>
<li><strong>GirdItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>icon</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图标地址</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>文字</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>跳转链接</td>
</tr>
</tbody>
</table>
<h3 id="basefoot" tabindex="-1"> BaseFoot</h3>
<p>页脚</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>页脚额外描述文字</td>
<td></td>
</tr>
<tr>
<td>author</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>作者</td>
<td>默认为 <code>Mr.Song</code>，如需取消请传入 <code>''</code></td>
</tr>
<tr>
<td>time</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>最后编辑时间</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basecarousel" tabindex="-1"> BaseCarousel</h3>
<p>轮播图</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center">CarouselItem[]</td>
<td>轮播图组件内容</td>
<td></td>
</tr>
<tr>
<td>vertical</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否竖直显示</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>autoplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否支持自动播放</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>autoplaySpeed</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Number</td>
<td>自动播放时间间隔</td>
<td>默认为 <code>3000</code></td>
</tr>
<tr>
<td>speed</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Number</td>
<td>切换速度</td>
<td>默认为 <code>500</code></td>
</tr>
<tr>
<td>dotDisplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否显示指示点</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>arrowDisplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否显示切换箭头</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>easing</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>切换动画</td>
<td>默认为 <code>easeInOutQuart</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>CarouselItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>caption</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>轮播图的主标题</td>
<td>请填入核心内容</td>
</tr>
<tr>
<td>subCaption</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>轮播图的副标题</td>
<td>主标题的进一步解释</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td>所有轮播图图片长宽比例应该相同，推荐值 <code>16: 9</code></td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>轮播图点击时的跳转路径</td>
<td>支持相对路径绝对路径以及 http、https 链接</td>
</tr>
<tr>
<td>enSubhead</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>轮播图的英文副标题</td>
<td></td>
</tr>
<tr>
<td>alt</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片失效时的显示文字</td>
<td>不填会默认初始化为文字 <code>轮播图背景</code></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>页面右下角补充说明</td>
<td>仅在 large 及以上屏幕上显示</td>
</tr>
<tr>
<td>black</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否采用黑色文字</td>
<td>默认文字色为白色</td>
</tr>
</tbody>
</table>
<h3 id="basephone" tabindex="-1"> BasePhone</h3>
<p>生成拨打电话提示，该组件仅为兼容小程序。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>number</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String 或 Number</td>
<td>电话号码</td>
</tr>
</tbody>
</table>
<h2 id="以下是以便复用的不常用组件" tabindex="-1"> 以下是以便复用的不常用组件</h2>
<h3 id="nav-组件" tabindex="-1"> Nav 组件</h3>
<p>网页导航栏</p>
<h3 id="slide-组件" tabindex="-1"> Slide 组件</h3>
<p>网页侧边栏</p>
<h3 id="footer-组件" tabindex="-1"> Footer 组件</h3>
<p>网页页脚</p>
<h3 id="basemenu-组件" tabindex="-1"> BaseMenu 组件</h3>
<p>生成竖直菜单</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td style="text-align:center">是</td>
<td style="text-align:center">MenuItem[]</td>
<td>菜单内容</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>MenuItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>菜单项的标识符</td>
<td>不可重复</td>
</tr>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>菜单的文字</td>
<td></td>
</tr>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Boolean</td>
<td>菜单的图标</td>
<td>填入 <code>true</code> 不显示图标但是图标区留空</td>
</tr>
<tr>
<td>children</td>
<td style="text-align:center">否</td>
<td style="text-align:center">MenuItem[]</td>
<td>子菜单</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basepage-组件" tabindex="-1"> BasePage 组件</h3>
<p>用于渲染小程序 json 生成页面</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>pagedata</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>小程序页面 json 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="docview-组件" tabindex="-1"> DocView 组件</h3>
<p>用于自动渲染转码的 HTML</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>docContent</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>Markdown 转 HTML 内容</td>
</tr>
</tbody>
</table>
<h3 id="basecard-组件" tabindex="-1"> BaseCard 组件</h3>
<p>卡片样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>卡片的标题</td>
<td></td>
</tr>
<tr>
<td>price</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Number</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Array</td>
<td>卡片详情</td>
<td>数组的每一项是卡片详情的每一项内容，支持 rawHtml</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>卡片跳转的地址</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basetimeaxis-组件" tabindex="-1"> BaseTimeAxis 组件</h3>
<p>生成时间轴</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeList</td>
<td style="text-align:center">是</td>
<td style="text-align:center">TimeListItem[]</td>
<td>Markdown 转 HTML 内容</td>
</tr>
</tbody>
</table>
<div><p>注意</p>
<p>※ 必须将该组件直接放置在 <code>div.container</code> 中! 否则会造成显示错乱。</p>
</div>
<ul>
<li><strong>TimeListItem</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>时间线的标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>时间线的段落文字</td>
<td>可输入 rawhtml，支持 <code>\n</code> 与连续空格</td>
</tr>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>时间线的图标</td>
<td>可输入 rawhtml</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>点击当前选项卡跳转的地址</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="mydoc-组件" tabindex="-1"> MyDoc 组件</h3>
<p>用于自动生成 HTML 页面</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>baselength</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Number</td>
<td>MarkDown 基准路径字符数</td>
</tr>
</tbody>
</table>
<h3 id="backtop-组件" tabindex="-1"> BackTop 组件</h3>
<p>一个返回顶部按钮，当滚动距离超过 300px 时显示会显示在右下角</p>
<h3 id="loadingicon" tabindex="-1"> LoadingIcon</h3>
<p>一个自定义的齿轮加载图标</p>
<h3 id="passwordmodal" tabindex="-1"> PasswordModal</h3>
<p>密码弹出框</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>验证地址</td>
<td>填入绝对路径，不需要填写 php 文件后缀名</td>
</tr>
<tr>
<td>userNameKey</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>用户名的自动填充键值</td>
<td>填写后会提示输入用户名，默认不输入</td>
</tr>
<tr>
<td>passwordKey</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>密码的自动填充键值</td>
<td>默认为 <code>password</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>快速上手 Vue.js</title>
      <link>https://songjun520.cn/vuepress-blog2/code/vue/get-started.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/vue/get-started.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">快速上手 Vue.js</source>
      <category>Vue</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="vue-js-是什么" tabindex="-1"> Vue.js 是什么</h2>
<p><a href="https://learning.dcloud.io/#/?vid=0" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<h2 id="起步" tabindex="-1"> 起步</h2>
<p><a href="https://learning.dcloud.io/#/?vid=1" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<div><p>提示</p>
<p>您应当已了解关于 HTML、CSS 和 JavaScript 的中级知识。</p>
</div>
<p><a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener noreferrer">安装</a></p>
<p>尝试 Vue.js 最简单的方法是使用 <a href="https://jsfiddle.net/chrisvfritz/50wL7mdz/" target="_blank" rel="noopener noreferrer">JSFiddle 上的 Hello World 例子</a>。您可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者您也可以创建一个 <code>.html</code> 文件，然后通过如下方式引入 Vue:</p>
<div><pre><code><span>&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>或者:</p>
<div><pre><code><span>&lt;!-- 生产环境版本，优化了尺寸和速度 --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/npm/vue<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>注意</p>
<p>请注意 Mr.Song <strong>不推荐</strong> 新手直接使用 <code>vue-cli</code>，尤其是在您还不熟悉基于 Node.js 的构建工具时。</p>
</div>
<h2 id="声明式渲染" tabindex="-1"> 声明式渲染</h2>
<p><a href="https://learning.dcloud.io/#/?vid=3" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue!"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们已经成功创建了第一个 Vue 应用! 现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式的</strong>。也就是说如果 <code>data</code> 中的 <code>message</code> 值被改变，那么视图层中的 <code>message</code> 马上会更新。</p>
<p>除了文本插值，我们还可以像这样来绑定元素特性:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-2<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>span</span> <span><span>v-bind:</span>title</span><span><span>=</span><span>"</span>message<span>"</span></span><span>></span></span>
    鼠标悬停几秒钟查看此处动态绑定的提示信息!
  <span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app2 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-2"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"页面加载于 "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们遇到了一点新东西。您看到的 <code>v-bind</code> 特性被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue 提供的特殊特性。可能您已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是: “将这个元素节点的 <code>title</code> 特性和 Vue 实例的 <code>message</code> 属性保持一致”。</p>
<h2 id="条件与循环" tabindex="-1"> 条件与循环</h2>
<p><a href="https://learning.dcloud.io/#/?vid=8" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>控制切换一个元素是否显示也相当简单:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-3<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-if</span><span><span>=</span><span>"</span>seen<span>"</span></span><span>></span></span>现在您看到我了<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app3 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-3"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>seen</span><span>:</span> <span>true</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您改变 <code>seen</code> 的值，文字的显示与否(也就是 <code>&lt;p&gt;</code> 标签的存在与否)也会进行切换。</p>
<p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM <strong>结构</strong>。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener noreferrer">过渡效果</a>。</p>
<p>还有其它很多指令，每个都有特殊的功能。例如，<code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-4<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ol</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>todo in todos<span>"</span></span><span>></span></span>{{ todo.text }}<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app4 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-4"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>todos</span><span>:</span> <span>[</span>
      <span>{</span> <span>text</span><span>:</span> <span>"学习 JavaScript"</span> <span>}</span><span>,</span>
      <span>{</span> <span>text</span><span>:</span> <span>"学习 Vue"</span> <span>}</span><span>,</span>
      <span>{</span> <span>text</span><span>:</span> <span>"整个牛项目"</span> <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="处理用户输入" tabindex="-1"> 处理用户输入</h2>
<p><a href="https://learning.dcloud.io/#/?vid=11" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>为了让用户和您的应用进行交互，我们可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-5<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>reverseMessage<span>"</span></span><span>></span></span>反转消息<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app5 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-5"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue.js!"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>reverseMessage</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>message <span>=</span> <span>this</span><span>.</span>message<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意在 <code>reverseMessage</code> 方法中，每次点击按钮的时候，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，您编写的代码只需要关注逻辑层面即可。</p>
<p>Vue 还提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-6<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>v-model</span><span><span>=</span><span>"</span>message<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app6 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-6"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue!"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，在输入框做出的更改会同步到 js 的数据中。</p>
<h2 id="组件化应用构建" tabindex="-1"> 组件化应用构建</h2>
<p><a href="https://learning.dcloud.io/#/?vid=12" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树:</p>
<p><img src="@source/code/vue/assets/components.png" alt="Component Tree"></p>
<p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单:</p>
<div><pre><code><span>// 定义名为 todo-item 的新组件</span>
Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>template</span><span>:</span> <span>"&lt;li>这是个待办项&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>现在您可以用它构建另一个组件模板:</p>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span>&lt;!-- 创建一个 todo-item 组件的实例 --></span>
  <span><span><span>&lt;</span>todo-ite</span> <span>/></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener noreferrer">prop</a>:</p>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>// todo-item 组件现在接受一个</span>
  <span>// "prop"，类似于一个自定义特性。</span>
  <span>// 这个 prop 名为 todo。</span>
  <span>props</span><span>:</span> <span>[</span><span>"todo"</span><span>]</span><span>,</span>
  <span>template</span><span>:</span> <span>"&lt;li>{{ todo.text }}&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-7<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ol</span><span>></span></span>
    <span>&lt;!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    --></span>
    <span><span><span>&lt;</span>todo-item</span>
      <span>v-for</span><span><span>=</span><span>"</span>item in groceryList<span>"</span></span>
      <span><span>v-bind:</span>todo</span><span><span>=</span><span>"</span>item<span>"</span></span>
      <span><span>v-bind:</span>key</span><span><span>=</span><span>"</span>item.id<span>"</span></span>
    <span>/></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>props</span><span>:</span> <span>[</span><span>"todo"</span><span>]</span><span>,</span>
  <span>template</span><span>:</span> <span>"&lt;li>{{ todo.text }}&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> app7 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-7"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>groceryList</span><span>:</span> <span>[</span>
      <span>{</span> <span>id</span><span>:</span> <span>0</span><span>,</span> <span>text</span><span>:</span> <span>"蔬菜"</span> <span>}</span><span>,</span>
      <span>{</span> <span>id</span><span>:</span> <span>1</span><span>,</span> <span>text</span><span>:</span> <span>"奶酪"</span> <span>}</span><span>,</span>
      <span>{</span> <span>id</span><span>:</span> <span>2</span><span>,</span> <span>text</span><span>:</span> <span>"随便其它什么人吃的东西"</span> <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。</p>
<p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">后续教程</a>中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>app-nav</span> <span>/></span></span>
  <span><span><span>&lt;</span>app-view</span><span>></span></span>
    <span><span><span>&lt;</span>app-sidebar</span> <span>/></span></span>
    <span><span><span>&lt;</span>app-content</span> <span>/></span></span>
  <span><span><span>&lt;/</span>app-view</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="与自定义元素的关系" tabindex="-1"> 与自定义元素的关系</h3>
<p>您可能已经注意到 Vue 组件非常类似于<strong>自定义元素</strong>——它是 <a href="https://www.w3.org/wiki/WebComponents/" target="_blank" rel="noopener noreferrer">Web 组件规范</a>的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener noreferrer">Slot API</a> 与 <code>is</code> 特性。但是，还是有几个关键差别:</p>
<ol>
<li>
<p>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</p>
</li>
<li>
<p>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</p>
</li>
</ol>
<p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，<a href="https://custom-elements-everywhere.com/#vue" target="_blank" rel="noopener noreferrer">依然有很好的互操作性</a>。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p>
<h2 id="创建一个-vue-实例" tabindex="-1"> 创建一个 Vue 实例</h2>
<p><a href="https://learning.dcloud.io/#/?vid=2" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的:</p>
<div><pre><code><span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>// 选项</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener noreferrer">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<p>当创建一个 Vue 实例时，您可以传入一个<strong>选项对象</strong>。这篇教程主要描述的就是如何使用这些选项来创建您想要的行为。作为参考，您也可以在 <a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer">API 文档</a> 中浏览完整的选项列表。</p>
<p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的:</p>
<div><pre><code>根实例
└─ TodoList
├─ TodoItem
│ ├─ DeleteTodoButton
│ └─ EditTodoButton
└─ TodoListFooter
├─ ClearTodosButton
└─ TodoListStatistics
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们会在稍后的<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">组件系统</a>章节具体展开。不过现在，您只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。</p>
<h2 id="数据与方法" tabindex="-1"> 数据与方法</h2>
<p><a href="https://learning.dcloud.io/#/?vid=3" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的属性加入到 Vue 的<strong>响应式系统</strong>中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<div><pre><code><span>// 我们的数据对象</span>
<span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>

<span>// 该对象被加入到一个 Vue 实例中</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> data<span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>// 获得这个实例上的属性</span>
<span>// 返回源数据中对应的字段</span>
vm<span>.</span>a <span>==</span> data<span>.</span>a<span>;</span> <span>// => true</span>

<span>// 设置属性也会影响到原始数据</span>
vm<span>.</span>a <span>=</span> <span>2</span><span>;</span>
data<span>.</span>a<span>;</span> <span>// => 2</span>

<span>// ……反之亦然</span>
data<span>.</span>a <span>=</span> <span>3</span><span>;</span>
vm<span>.</span>a<span>;</span> <span>// => 3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的属性才是<strong>响应式</strong>的。也就是说如果您添加一个新的属性，比如:</p>
<div><pre><code>vm<span>.</span>b <span>=</span> <span>"hi"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果您知道您会在晚些时候需要一个属性，但是一开始它为空或不存在，那么您仅需要设置一些初始值。比如:</p>
<div><pre><code><span>data</span><span>:</span> <span>{</span>
  <span>newTodoText</span><span>:</span> <span>''</span><span>,</span>
  <span>visitCount</span><span>:</span> <span>0</span><span>,</span>
  <span>hideCompletedTodos</span><span>:</span> <span>false</span><span>,</span>
  <span>todos</span><span>:</span> <span>[</span><span>]</span><span>,</span>
  <span>error</span><span>:</span> <span>null</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的属性，也意味着响应系统无法再<em>追踪</em>变化。</p>
<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>"bar"</span><span>,</span>
<span>}</span><span>;</span>

Object<span>.</span><span>freeze</span><span>(</span>obj<span>)</span><span>;</span>

<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> obj<span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ foo }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span>&lt;!-- 这里的 `foo` 不会更新!  --></span>
  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>foo = <span>'</span>baz<span>'</span><span>"</span></span><span>></span></span>Change it<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 <code>$</code>，以便与用户定义的属性区分开来。例如:</p>
<div><pre><code><span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#example"</span><span>,</span>
  <span>data</span><span>:</span> data<span>,</span>
<span>}</span><span>)</span><span>;</span>

vm<span>.</span>$data <span>===</span> data<span>;</span> <span>// => true</span>
vm<span>.</span>$el <span>===</span> document<span>.</span><span>getElementById</span><span>(</span><span>"example"</span><span>)</span><span>;</span> <span>// => true</span>

<span>// $watch 是一个实例方法</span>
vm<span>.</span><span>$watch</span><span>(</span><span>"a"</span><span>,</span> <span>function</span> <span>(</span><span>newValue<span>,</span> oldValue</span><span>)</span> <span>{</span>
  <span>// 这个回调将在 `vm.a` 改变后调用</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以后您可以在 <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener noreferrer">API 参考</a>中查阅到完整的实例属性和方法的列表。</p>
<h2 id="实例生命周期钩子" tabindex="-1"> 实例生命周期钩子</h2>
<p><a href="https://learning.dcloud.io/#/?vid=4" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 <a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener noreferrer"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码:</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>a</span><span>:</span> <span>1</span><span>,</span>
  <span>}</span><span>,</span>
  <span>created</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// `this` 指向 vm 实例</span>
    console<span>.</span><span>log</span><span>(</span><span>"a is: "</span> <span>+</span> <span>this</span><span>.</span>a<span>)</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
<span>// => "a is: 1"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted" target="_blank" rel="noopener noreferrer"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated" target="_blank" rel="noopener noreferrer"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed" target="_blank" rel="noopener noreferrer"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<div><p>提示</p>
<p>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener noreferrer">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
</div>
<h2 id="生命周期图示" tabindex="-1"> 生命周期图示</h2>
<p>下图展示了实例的生命周期。您不需要立马弄明白所有的东西，不过随着您的不断学习和使用，它的参考价值会越来越高。</p>
<p><img src="@source/code/vue/assets/lifecycle.png" alt="Vue 实例生命周期"></p>
]]></content:encoded>
    </item>
    <item>
      <title>开发环境安装</title>
      <link>https://songjun520.cn/vuepress-blog2/code/vue/install.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/vue/install.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">开发环境安装</source>
      <category>Vue</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="环境准备" tabindex="-1"> 环境准备</h2>
<h3 id="vs-code-安装" tabindex="-1"> VS Code 安装</h3>
<ul>
<li><a href="/software/vscode/install.html">安装 VS Code</a></li>
</ul>
<h4 id="开发指南" tabindex="-1"> 开发指南</h4>
<ol>
<li>
<p>使用 VS Code 打开项目文件夹。</p>
<div><p>提示</p>
<p>请打开 VS Code 选择菜单栏中的 “文件-打开文件夹”，或在文件夹上 “右键——使用 VS Code 打开” 或在文件夹内部空白处 “右键——使用 VS Code 打开”。</p>
</div>
</li>
<li>
<p>打开终端(快捷键 <code>Ctrl + `</code> )。</p>
</li>
<li>
<p>在终端中输入相关指令即可执行相关功能。</p>
</li>
</ol>
<h3 id="git-安装" tabindex="-1"> Git 安装</h3>
<ul>
<li><a href="/software/git/install.html">安装 Git</a></li>
</ul>
<h3 id="node-js-环境安装" tabindex="-1"> Node.js 环境安装</h3>
<p>请先安装 Node.js 并将 npm 与 Node.js 添加至 path。</p>
<ul>
<li>
<p><a href="/code/node-js/install.html">安装 Node.js</a></p>
</li>
<li>
<p><a href="/code/windows/add-path.html">添加到 path</a></p>
</li>
</ul>
<h2 id="初始化版本库、下载网页代码并安装-npm-模块" tabindex="-1"> 初始化版本库、下载网页代码并安装 npm 模块</h2>
<ol>
<li>
<p>打开文件管理器窗口找到合适位置，并在地址栏输入 cmd，以在当前界面打开终端。</p>
</li>
<li>
<p>使用 <code>git clone git@github.com:Mister-Hope/vue-template.git</code> 克隆模板。</p>
</li>
<li>
<p>使用 VS Code 打开刚刚克隆出来的文件夹，按下 <code>Ctrl + `</code> 打开终端。</p>
</li>
<li>
<p>使用 <code>npm install</code> 命令安装模块。</p>
</li>
</ol>
<div><p>提示</p>
<p>npm 模块介绍</p>
<p>此处待补充。</p>
</div>
<h2 id="开发工具安装" tabindex="-1"> 开发工具安装</h2>
<p>Vue 官方提供的浏览器插件 VueTools 可以更好的帮助开发。</p>
<p>使用 VPN 用 Chrome 打开<a href="https://chrome.google.com/webstore/detail/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener noreferrer">安装网址</a>，安装 VueTools 开发工具</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 单文件组件</title>
      <link>https://songjun520.cn/vuepress-blog2/code/vue/vue.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/vue/vue.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Vue 单文件组件</source>
      <category>Vue</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍" tabindex="-1"> 介绍</h2>
<p>Vue 的单文件组件 (即 <code>*.vue</code> 文件，简称 <strong>SFC</strong>) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>greeting</span><span>:</span> <span>"Hello World!"</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>greeting<span>"</span></span><span>></span></span>{{ greeting }}<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.greeting</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如你所见，Vue 的单文件组件是 HTML、CSS 和 JavaScript 三种元素的自然延伸。<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 三个块在同一个文件中封装、组合了组件的视图、逻辑和样式。</p>
<h2 id="总览" tabindex="-1"> 总览</h2>
<h2 id="总览-overview" tabindex="-1"> 总览 {#overview}</h2>
<p>一个 Vue 单文件组件 (SFC)，通常使用 <code>*.vue</code> 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。</p>
<p>每一个 <code>*.vue</code> 文件都由三种顶层语块构成：<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>，以及一些其他的自定义块：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>example<span>"</span></span><span>></span></span>{{ msg }}<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>msg</span><span>:</span> <span>"Hello world!"</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.example</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;</span>custom1</span><span>></span></span>
  This could be e.g. documentation for the component.
<span><span><span>&lt;/</span>custom1</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="相应语言块-language-blocks" tabindex="-1"> 相应语言块 {#language-blocks}</h2>
<h3 id="template-template" tabindex="-1"> <code>&lt;template&gt;</code> {#template}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个顶层 <code>&lt;template&gt;</code> 块。</p>
</li>
<li>
<p>语块包裹的内容将会被提取、传递给 <code>@vue/compiler-dom</code>，预编译为 JavaScript 渲染函数，并附在导出的组件上作为其 <code>render</code> 选项。</p>
</li>
</ul>
<h3 id="script-script" tabindex="-1"> <code>&lt;script&gt;</code> {#script}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script&gt;</code> 块。(使用 <a href="/api/sfc-script-setup.html" target="_blank" rel="noopener noreferrer"><code>&lt;script setup&gt;</code></a> 的情况除外)</p>
</li>
<li>
<p>这个脚本代码块将作为 ES 模块执行。</p>
</li>
<li>
<p><strong>默认导出</strong>应该是 Vue 的组件选项对象，可以是一个对象字面量或是 <a href="/api/general.html#definecomponent" target="_blank" rel="noopener noreferrer">defineComponent</a> 函数的返回值。</p>
</li>
</ul>
<h3 id="script-setup-script-setup" tabindex="-1"> <code>&lt;script setup&gt;</code> {#script-setup}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script setup&gt;</code>。(不包括一般的 <code>&lt;script&gt;</code>)</p>
</li>
<li>
<p>这个脚本块将被预处理为组件的 <code>setup()</code> 函数，这意味着它将<strong>为每一个组件实例</strong>都执行。<code>&lt;script setup&gt;</code> 中的顶层绑定都将自动暴露给模板。要了解更多细节，请看 <a href="/api/sfc-script-setup" target="_blank" rel="noopener noreferrer"><code>&lt;script setup&gt;</code> 的专门文档</a>。</p>
</li>
</ul>
<h3 id="style-style" tabindex="-1"> <code>&lt;style&gt;</code> {#style}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件可以包含多个 <code>&lt;style&gt;</code> 标签。</p>
</li>
<li>
<p>一个 <code>&lt;style&gt;</code> 标签可以使用 <code>scoped</code> 或 <code>module</code> attribute (查看 <a href="/api/sfc-css-features" target="_blank" rel="noopener noreferrer">SFC 样式功能</a>了解更多细节) 来帮助封装当前组件的样式。使用了不同封装模式的多个 <code>&lt;style&gt;</code> 标签可以被混合入同一个组件。</p>
</li>
</ul>
<h3 id="自定义块-custom-blocks" tabindex="-1"> 自定义块 {#custom-blocks}</h3>
<p>在一个 <code>*.vue</code> 文件中可以为任何项目特定需求使用额外的自定义块。举个例子，一个用作写文档的 <code>&lt;docs&gt;</code> 块。这里是一些自定义块的真实用例：</p>
<ul>
<li><a href="https://gridsome.org/docs/querying-data/" target="_blank" rel="noopener noreferrer">Gridsome：<code>&lt;page-query&gt;</code></a></li>
<li><a href="https://github.com/wheatjs/vite-plugin-vue-gql" target="_blank" rel="noopener noreferrer">vite-plugin-vue-gql：<code>&lt;gql&gt;</code></a></li>
<li><a href="https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block" target="_blank" rel="noopener noreferrer">vue-i18n：<code>&lt;i18n&gt;</code></a></li>
</ul>
<p>自定义块的处理需要依赖工具链。如果你想要在构建中集成你的自定义语块，请参见<a href="/guide/scaling-up/tooling.html#sfc-custom-block-integrations" target="_blank" rel="noopener noreferrer">相关工具链指南</a>获取更多细节。</p>
<h2 id="自动名称推导-automatic-name-inference" tabindex="-1"> 自动名称推导 {#automatic-name-inference}</h2>
<p>SFC 在以下场景中会根据<strong>文件名</strong>自动推导其组件名：</p>
<ul>
<li>开发警告信息格式</li>
<li>DevTools 审阅</li>
<li>递归组件自引用。例如一个名为 <code>FooBar.vue</code> 的组件可以在模板中通过 <code>&lt;FooBar/&gt;</code> 引用自己。(同名情况下) 这比明确注册/导入的组件优先级低。</li>
</ul>
<h2 id="预处理器-pre-processors" tabindex="-1"> 预处理器 {#pre-processors}</h2>
<p>代码块可以使用 <code>lang</code> 这个 attribute 来声明预处理器语言，最常见的用例就是对 <code>&lt;script&gt;</code> 块使用 TypeScript：</p>
<div><pre><code>&lt;script lang=&quot;ts&quot;&gt;
  // use TypeScript
&lt;/script&gt;
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>lang</code> 在任意块上都能使用，比如我们可以在 <code>&lt;style&gt;</code> 标签上使用 <a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">SASS</a> 或是 <code>&lt;template&gt;</code> 上使用 <a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="noopener noreferrer">Pug</a>：</p>
<div><pre><code>&lt;template lang=&quot;pug&quot;&gt;
p {{ msg }}
&lt;/template&gt;

&lt;style lang=&quot;scss&quot;&gt;
  $primary-color: #333;
  body {
    color: $primary-color;
  }
&lt;/style&gt;
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意对各种不同的预处理的集成会导致工具链的不同，你应该查看相应的工具链文档了解细节：</p>
<ul>
<li><a href="https://vitejs.dev/guide/features.html#css-pre-processors" target="_blank" rel="noopener noreferrer">Vite</a></li>
<li><a href="https://cli.vuejs.org/guide/css.html#pre-processors" target="_blank" rel="noopener noreferrer">Vue CLI</a></li>
<li><a href="https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors" target="_blank" rel="noopener noreferrer">webpack + vue-loader</a></li>
</ul>
<h2 id="src-导入-src-imports" tabindex="-1"> Src 导入 {#src-imports}</h2>
<p>如果你更喜欢将 <code>*.vue</code> 组件分散到多个文件中，可以为一个语块使用 <code>src</code> 这个 attribute 来导入一个外部文件：</p>
<div><pre><code><span><span><span>&lt;</span>template</span> <span>src</span><span><span>=</span><span>"</span>./template.html<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>style</span> <span>src</span><span><span>=</span><span>"</span>./style.css<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./script.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>请注意 <code>src</code> 导入和 Webpack 的模块请求遵循相同的路径解析规则，这意味着：</p>
<ul>
<li>相对路径需要以 <code>./</code> 开头</li>
<li>你也可以从 npm 依赖中导入资源</li>
</ul>
<div><pre><code><span>&lt;!-- 从所安装的 "todomvc-app-css" npm 包中导入一个文件 --></span>
<span><span><span>&lt;</span>style</span> <span>src</span><span><span>=</span><span>"</span>todomvc-app-css/index.css<span>"</span></span> <span>/></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>src</code> 导入对自定义语块也同样适用：</p>
<div><pre><code><span><span><span>&lt;</span>unit-test</span> <span>src</span><span><span>=</span><span>"</span>./unit-test.js<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>unit-test</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="注释-comments" tabindex="-1"> 注释 {#comments}</h2>
<p>在每一个语块中你都可以按照相应语言 (HTML、CSS、JavaScript 和 Pug 等等) 的语法书写注释。对于顶层注释，请使用 HTML 的注释语法 <code>&lt;!-- comment contents here --&gt;</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>网页入门</title>
      <link>https://songjun520.cn/vuepress-blog2/code/website/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/website/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">网页入门</source>
      <description>网页需要三件套: HTML、CSS 和 JavaScript。

HTML 定义了网页的内容
CSS 描述了网页的样式
JavaScript 编写网页的行为

</description>
      <category>前端</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>

<div><p>提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>
</div>
<div><p>网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2 id="html" tabindex="-1"> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="/code/website/html/">HTML 教程</a></li>
</ul>
<h2 id="css" tabindex="-1"> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="/code/website/css/">CSS 教程</a></li>
</ul>
<h2 id="emmet" tabindex="-1"> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="/code/website/emmet/">Emmet 用法介绍</a></li>
</ul>
<h2 id="javascript" tabindex="-1"> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="/code/website/js.html">JS 教程</a></li>
</ul>
<h3 id="typescript" tabindex="-1"> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="/code/language/typescript/">TypeScript 教程</a></li>
</ul>
<h2 id="node-js" tabindex="-1"> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="/code/node-js/">Node.js 教程</a></li>
</ul>
<h2 id="历史前端框架" tabindex="-1"> 历史前端框架</h2>
<h3 id="jquery" tabindex="-1"> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 MVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="/code/website/jQuery/">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="bootstrap4" tabindex="-1"> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2 id="现代前端框架" tabindex="-1"> 现代前端框架</h2>
<h3 id="vue" tabindex="-1"> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 与 React、Angular 一起合称前端三大框架。</p>
<ul>
<li>
<p><a href="/code/vue/">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3 id="react" tabindex="-1"> React</h3>
<ul>
<li><a href="/code/react/">React 教程</a></li>
</ul>
<h2 id="其他文档" tabindex="-1"> 其他文档</h2>
<ul>
<li><a href="/code/website/https.html">HTTPS 介绍</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Http 与 Https 介绍</title>
      <link>https://songjun520.cn/vuepress-blog2/code/website/https.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/website/https.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Http 与 Https 介绍</source>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是-http-协议" tabindex="-1"> 什么是 HTTP 协议</h2>
<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>
<p><img src="@source/code/website/assets/http1.jpg" alt="Http 漫画"></p>
<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>
<p><img src="@source/code/website/assets/http2.jpg" alt="Http 漫画"></p>
<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>
<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>
<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>
<p><img src="@source/code/website/assets/http3.jpg" alt="Http 漫画"></p>
<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>
<p><img src="@source/code/website/assets/http4.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http5.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http6.jpg" alt="Http 漫画"></p>
<p>如何进行加密呢?</p>
<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p><img src="@source/code/website/assets/http7.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http8.jpg" alt="Http 漫画"></p>
<p>这样做是不是就绝对安全了呢? 并不是。</p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<p><img src="@source/code/website/assets/http9.jpg" alt="Http 漫画"></p>
<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>
<p><img src="@source/code/website/assets/http10.jpg" alt="Http 漫画"></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>
<p><img src="@source/code/website/assets/http11.jpg" alt="Http 漫画"></p>
<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>
<p><img src="@source/code/website/assets/http12.jpg" alt="Http 漫画"></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>
<p><img src="@source/code/website/assets/http13.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http14.jpg" alt="Http 漫画"></p>
<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>
<p><img src="@source/code/website/assets/http15.jpg" alt="Http 漫画"></p>
<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>
<p><img src="@source/code/website/assets/http16.jpg" alt="Http 漫画"></p>
<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>
<p><img src="@source/code/website/assets/http17.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http18.jpg" alt="Http 漫画"></p>
<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>
<p>到底什么是证书呢? 证书包含如下信息:</p>
<p><img src="@source/code/website/assets/http19.jpg" alt="Http 漫画"></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下:</p>
<ol>
<li>
<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>
<p><img src="@source/code/website/assets/http20.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>
<p><img src="@source/code/website/assets/http21.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p><img src="@source/code/website/assets/http22.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>
<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>
<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>
<p><img src="@source/code/website/assets/http23.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>
<p><img src="@source/code/website/assets/http24.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>
<p><img src="@source/code/website/assets/http25.jpg" alt="Http 漫画"></p>
</li>
</ol>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>
<p><img src="@source/code/website/assets/http26.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http27.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http28.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http29.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http30.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http31.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http32.jpg" alt="Http 漫画"></p>
<div><p>相关信息</p>
<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 教程</title>
      <link>https://songjun520.cn/vuepress-blog2/code/website/js.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/website/js.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">JavaScript 教程</source>
      <category>JavaScript</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="初学者教程" tabindex="-1"> 初学者教程</h2>
<ul>
<li><a href="/code/language/js/guide/">快速上手</a></li>
</ul>
<h3 id="javascript-手册" tabindex="-1"> JavaScript 手册</h3>
<ul>
<li><a href="/code/language/js/">JavaScript 学习教程</a></li>
</ul>
<h3 id="在线教程" tabindex="-1"> 在线教程</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="es6" tabindex="-1"> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="/code/language/js/es6/">ES6 教程</a></li>
</ul>
<div><p>提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="/code/language/js/guide/">JS 快速入门章节</a> 了解 JavaScript，或 <a href="/code/language/js/">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>基础知识</title>
      <link>https://songjun520.cn/vuepress-blog2/code/windows/</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/windows/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">基础知识</source>
      <description>以下是有关于 Windows 10 系统的一些基础知识。
</description>
      <category>基础</category>
      <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是有关于 Windows 10 系统的一些基础知识。</p>

<ul>
<li>
<p><a href="/code/windows/add-path.html">添加到 path</a></p>
</li>
<li>
<p><a href="/code/windows/shortcut-key.html">Windows 快捷键</a></p>
</li>
<li>
<p><a href="/code/windows/hidden-file.html">显示文件后缀名与隐藏文件</a></p>
</li>
<li>
<p><a href="/code/windows/cmd.html">快速打开 CMD</a></p>
</li>
<li>
<p><a href="/code/windows/notepad.html">记事本的遗留问题</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>环境变量的添加</title>
      <link>https://songjun520.cn/vuepress-blog2/code/windows/add-path.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/windows/add-path.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">环境变量的添加</source>
      <category>基础</category>
      <pubDate>Sun, 08 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>以 Windows 10 系统为例，直接在左下角搜索栏中输入“系统变量”</p>
<p><img src="@source/code/windows/assets/pathSearch.png" alt="搜索"></p>
<p>在弹出的框中点击环境变量</p>
<p><img src="@source/code/windows/assets/path.png" alt="系统变量"></p>
<p>在弹出的新窗口中找到 path，选中并点击编辑</p>
<p><img src="@source/code/windows/assets/pathDetail.png" alt="系统变量"></p>
<p>点击添加输入想要添加到 path 的路径或者执行文件名即可</p>
<p><img src="@source/code/windows/assets/pathAdd.png" alt="系统变量"></p>
]]></content:encoded>
    </item>
    <item>
      <title>打开命令行</title>
      <link>https://songjun520.cn/vuepress-blog2/code/windows/cmd.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/windows/cmd.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">打开命令行</source>
      <description>打开命令行 (命令提示符) 有多种方式。

运行 - cmd: Win + R 打开运行，然后敲入 cmd 后回车。
搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。
开始菜单 - Windows 系统 - 命令提示符。

如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 cmd 并回车。
</description>
      <category>基础</category>
      <pubDate>Sun, 08 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>打开命令行 (命令提示符) 有多种方式。</p>
<ol>
<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>
<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>
<li>开始菜单 - Windows 系统 - 命令提示符。</li>
</ol>
<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>

<p><img src="@source/code/windows/assets/cmd.png" alt="示意图"></p>
<p>这样就会快速打开一个路径为当前文件夹的命令提示符窗口。</p>
]]></content:encoded>
    </item>
    <item>
      <title>显示文件后缀名与隐藏文件</title>
      <link>https://songjun520.cn/vuepress-blog2/code/windows/hidden-file.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/windows/hidden-file.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">显示文件后缀名与隐藏文件</source>
      <category>基础</category>
      <pubDate>Tue, 15 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>显示文件后缀名与隐藏文件</p>
<p><img src="@source/code/windows/assets/hidden-file.png" alt="如何显示隐藏的文件与文件夹"></p>
]]></content:encoded>
    </item>
    <item>
      <title>记事本的遗留问题</title>
      <link>https://songjun520.cn/vuepress-blog2/code/windows/notepad.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/windows/notepad.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">记事本的遗留问题</source>
      <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>在编写代码的时候，临时的软件选择需要注意。</p>
<p>请注意，绝对不能用 Word 和写字板。Word 和写字板保存的不是纯文本文件。</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<p>原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了几个特殊字符(UTF-8 BOM，即 0xefbbbf)，您会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。</p>
<p>这个弱智行为从 Windows XP 影响到 Windows 10，在最新的 Windows 10 版本(20H2) 中，才得到解决。</p>
<div><p>提示</p>
<p>如果实在是临时急用，需要用记事本替代改一下代码，也要一定注意，保存文件时使用 ANSI 编码，并且暂时不要输入(包含)中文。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>常用快捷键</title>
      <link>https://songjun520.cn/vuepress-blog2/code/windows/shortcut-key.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/code/windows/shortcut-key.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">常用快捷键</source>
      <description>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。
</description>
      <category>基础</category>
      <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>

<h2 id="最常用且最有用的" tabindex="-1"> 最常用且最有用的</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="通用键" tabindex="-1"> 通用键</h2>
<ul>
<li><code>F1</code>: 显示帮助；</li>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>F11</code>: 全屏；</li>
<li><code>Shift</code> + <code>F10</code>: 打开当前活动项目的快捷菜单(相当于鼠标右键)；</li>
<li><code>ALT</code> 激活当前程序的菜单栏(使用对应字母选择)；</li>
<li><code>Backspace</code>: 退格——删除前一个字符、文件视图下——返回上一级；</li>
<li><code>Enter</code>: 执行或进入；</li>
<li><code>Win</code> 或 <code>CTRL</code> + <code>ESC</code>: 打开开始菜单；</li>
<li><code>DELETE</code>: 删除被选中的项目，如果是文件，将被放入回收站；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
</ul>
<h2 id="程序窗口" tabindex="-1"> 程序窗口</h2>
<ul>
<li><code>Win</code> + <code>Tab</code>: 最近任务和多桌面视图；</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>Alt</code> + <code>加下划线的字母</code> 执行与该字母匹配的命令(或选择选项)；</li>
<li><code>Win</code> + <code>↑</code>: 显示最小化的窗口 → 最大化窗口；</li>
<li><code>Win</code> + <code>←</code>: 将窗口最大化到屏幕的左侧；</li>
<li><code>Win</code> + <code>→</code>: 将窗口最大化到屏幕的右侧；</li>
<li><code>Win</code> + <code>↓</code>: 缩小窗口 → 最小化窗口；</li>
<li><code>Win</code> + <code>Home</code>: 最小化除活动窗口之外的所有窗口；</li>
<li><code>ALT</code> + <code>SPACEBAR</code>: 打开程序最左上角的菜单；</li>
<li><code>Win</code> + <code>Shift</code> + <code>↑</code>: 将窗口拉伸到屏幕的顶部和底部；</li>
<li><code>Win</code> + <code>Shift</code> + <code>←</code> 或 <code>Win</code> + <code>Shift</code> + <code>→</code>: 将窗口从一个监视器移动到另一个监视器；</li>
</ul>
<h2 id="文件浏览" tabindex="-1"> 文件浏览</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>Shift</code> + <code>DELETE</code>: 删除被选中的项目，如果是文件，将被直接删除而不是放入回收站；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="编辑模式" tabindex="-1"> 编辑模式</h2>
<ul>
<li><code>CTRL</code> + <code>O</code>: 打开文件；</li>
<li><code>CTRL</code> + <code>S</code>: 保存；</li>
<li><code>CTRL</code> + <code>方向键</code>: 滚动屏幕；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Z</code>: 撤销；</li>
<li><code>CTRL</code> + <code>Y</code>: 重做；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>E</code>: 搜索/助理；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>P</code>: 打印；</li>
</ul>
<div><p>提示</p>
<p>单击鼠标左键选择光标位置，按住 <code>Shift</code> 再次在另一处单击鼠标左键，即可选中两光标间的所有文字。鼠标左键单击拖动选中内容即可移动选中内容在文档中的位置。</p>
</div>
<h2 id="系统" tabindex="-1"> 系统</h2>
<ul>
<li><code>CTRL</code> + <code>Shift</code> + <code>ESC</code>: 打开任务管理器;</li>
<li><code>CTRL</code> + <code>ALT</code> + <code>DELETE</code>: 进入安全选项；</li>
<li><code>Win</code> + <code>D</code>: 显示桌面；</li>
<li><code>Win</code> + <code>E</code>: 打开资源管理器；</li>
<li><code>Win</code> + <code>L</code>: 锁定计算机或切换用户；</li>
<li><code>Win</code> + <code>M</code>: 最小化所有窗口(和显示桌面不同，自行感受)；</li>
<li><code>Win</code> + <code>Shift</code> + <code>M</code>: 将最小化的窗口还原到桌面；</li>
<li><code>Win</code> + <code>R</code>: 打开“运行”对话框；</li>
<li><code>Win</code> + <code>A</code>: 打开通知中心；</li>
<li><code>Win</code> + <code>I</code>: 打开系统设置；</li>
<li><code>Win</code> + <code>X</code>: 打开 Windows 主选项菜单；</li>
<li><code>Win</code> + <code>P</code>: 选择投影模式；</li>
<li><code>Win</code> + <code>数字</code>: 启动任务栏上快捷启动项数字位置处的程序；</li>
<li><code>Win</code> + <code>B</code> 选中桌面右下方工具栏；</li>
<li><code>Win</code> + <code>BREAK</code>: 打开“系统属性”对话框</li>
<li><code>Win</code> + <code>T</code>: 循环切换任务栏上的程序；</li>
<li><code>Shift</code> + <code>Win</code> + <code>数字</code>: 打开任务栏上快捷启动项数字位置处程序的新实例；</li>
<li><code>Alt</code> + <code>Win</code> + <code>数字</code>: 显示任务栏上快捷启动项数字位置处程序的跳转列表；</li>
<li><code>ALT</code> + <code>ESC</code>: 保留程序的显示状态切换当前程序(最小化状态将被保留)(加 Shift 反向)；</li>
</ul>
<h2 id="输入法" tabindex="-1"> 输入法</h2>
<ul>
<li><code>CTRL</code> + <code>Space</code>: 切换中英文输入法；</li>
<li><code>Win</code> + <code>Space</code>: 切换输入法；</li>
</ul>
<h2 id="屏幕截图" tabindex="-1"> 屏幕截图</h2>
<ul>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Win</code> + <code>PRINT SCREEN</code>: 将当前屏幕截图保存在图片文件夹中；</li>
<li><code>ALT</code> + <code>PRINT SCREEN</code>: 将当前活动程序窗口以图像方式拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 教程</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 教程</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/linux/bash/intro.html">简介</a></p>
</li>
<li>
<p><a href="/linux/bash/grammar.html">基本语法</a></p>
</li>
<li>
<p><a href="/linux/bash/expansion.html">模式扩展</a></p>
</li>
<li>
<p><a href="/linux/bash/quotation.html">引号和转义</a></p>
</li>
<li>
<p><a href="/linux/bash/variable.html">变量</a></p>
</li>
<li>
<p><a href="/linux/bash/string.html">字符串操作</a></p>
</li>
<li>
<p><a href="/linux/bash/arithmetic.html">算术运算</a></p>
</li>
<li>
<p><a href="/linux/bash/readline.html">行操作</a></p>
</li>
<li>
<p><a href="/linux/bash/stack.html">目录堆栈</a></p>
</li>
<li>
<p><a href="/linux/bash/script.html">脚本入门</a></p>
</li>
<li>
<p><a href="/linux/bash/read.html">read 命令</a></p>
</li>
<li>
<p><a href="/linux/bash/condition.html">条件判断</a></p>
</li>
<li>
<p><a href="/linux/bash/loop.html">循环</a></p>
</li>
<li>
<p><a href="/linux/bash/function.html">函数</a></p>
</li>
<li>
<p><a href="/linux/bash/array.html">数组</a></p>
</li>
<li>
<p><a href="/linux/bash/set.html">set 命令</a></p>
</li>
<li>
<p><a href="/linux/bash/debug.html">脚本除错</a></p>
</li>
<li>
<p><a href="/linux/bash/mktemp.html">mktemp 命令，trap 命令</a></p>
</li>
<li>
<p><a href="/linux/bash/startup.html">启动环境</a></p>
</li>
<li>
<p><a href="/linux/bash/prompt.html">命令提示符</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的算术运算</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/arithmetic.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/arithmetic.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 的算术运算</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="算术表达式" tabindex="-1"> 算术表达式</h2>
<p><code>((...))</code> 语法可以进行整数的算术运算。</p>
<div><pre><code>$ <span><span>((</span>foo <span>=</span> <span>5</span> <span>+</span> <span>5</span><span>))</span></span>
$ <span>echo</span> <span>$foo</span>
<span>10</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div><pre><code><span><span>((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>
<span><span>((</span> <span>2</span><span>+</span><span>2</span> <span>))</span></span>
<span><span>((</span> <span>2</span> <span>+</span> <span>2</span> <span>))</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>+</span> <span>2</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>
<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>-</span> <span>3</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>: 加法</li>
<li><code>-</code>: 减法</li>
<li><code>*</code>: 乘法</li>
<li><code>/</code>: 除法(整除)</li>
<li><code>%</code>: 余数</li>
<li><code>**</code>: 指数</li>
<li><code>++</code>: 自增运算(前缀或后缀)</li>
<li><code>--</code>: 自减运算(前缀或后缀)</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>5</span> <span>/</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div><pre><code>$ <span>i</span><span>=</span><span>0</span>
$ <span>echo</span> <span>$i</span>
<span>0</span>
$ <span>echo</span> <span><span>$((</span>i<span>++</span><span>))</span></span>
<span>0</span>
$ <span>echo</span> <span>$i</span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>++</span>i<span>))</span></span>
<span>2</span>
$ <span>echo</span> <span>$i</span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>
<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>4</span> <span>))</span></span>
<span>20</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code> 结构可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>(</span><span>5</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>3</span><span>))</span></span>
<span>75</span>
<span># 等同于</span>
$ <span>echo</span> <span><span>$((</span><span>$((</span><span>5</span><span>**</span><span>2</span><span>))</span></span> * <span>3</span><span>))</span>
<span>75</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这个语法只能计算整数，否则会报错。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span><span>$((</span><span>1.5</span> <span>+</span> <span>1</span><span>))</span></span>
bash: 语法错误
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>
<div><pre><code>$ <span>number</span><span>=</span><span>2</span>
$ <span>echo</span> <span><span>$((</span>$number <span>+</span> <span>1</span><span>))</span></span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>
<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> "hello" <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
$ <span>echo</span> <span><span>$((</span> "hello" <span>*</span> <span>2</span><span>))</span></span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>hello</span><span>=</span><span>3</span>
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span> <span>))</span></span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>
<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>
<div><pre><code>$ <span>echo</span> $<span>[</span><span>2</span>+2<span>]</span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="数值的进制" tabindex="-1"> 数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>
<li><code>0number</code>: 八进制数。</li>
<li><code>0xnumber</code>: 十六进制数。</li>
<li><code>base#number</code>: <code>base</code> 进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>0xff</span><span>))</span></span>
<span>255</span>
$ <span>echo</span> <span><span>$((</span><span>2</span>#<span>11111111</span><span>))</span></span>
<span>255</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>
<h2 id="位运算" tabindex="-1"> 位运算</h2>
<p><code>$((...))</code> 支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>
<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>
<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>>></span><span>2</span><span>))</span></span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>&lt;&lt;</span><span>2</span><span>))</span></span>
<span>64</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>17</span><span>&amp;</span><span>3</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>|</span><span>3</span><span>))</span></span>
<span>19</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>^</span><span>3</span><span>))</span></span>
<span>18</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="逻辑运算" tabindex="-1"> 逻辑运算</h2>
<p><code>$((...))</code> 支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>: 小于</li>
<li><code>&gt;</code>: 大于</li>
<li><code>&lt;=</code>: 小于或相等</li>
<li><code>&gt;=</code>: 大于或相等</li>
<li><code>==</code>: 相等</li>
<li><code>!=</code>: 不相等</li>
<li><code>&amp;&amp;</code>: 逻辑与</li>
<li><code>||</code>: 逻辑或</li>
<li><code>!</code>: 逻辑否</li>
<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span> <span>(</span><span>3</span> <span>></span> <span>2</span><span>)</span> <span>||</span> <span>(</span><span>4</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>))</span></span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>
<div><pre><code>$ <span>a</span><span>=</span><span>0</span>
$ <span>echo</span> <span><span>$((</span>a<span>&lt;</span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span>a<span>></span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="赋值运算" tabindex="-1"> 赋值运算</h2>
<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>a<span>=</span><span>1</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span>$a</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>: 简单赋值。</li>
<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>5</span>
$ <span>echo</span> <span><span>$((</span>foo<span>*=</span><span>2</span><span>))</span></span>
<span>10</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div><pre><code><span>echo</span> <span><span>$((</span> a<span>&lt;</span><span>1</span> <span>?</span> <span>(</span>a<span>+=</span><span>1</span><span>)</span> <span>:</span> <span>(</span>a<span>-=</span><span>1</span><span>)</span> <span>))</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="求值运算" tabindex="-1"> 求值运算</h2>
<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>foo <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>,</span> <span>3</span> <span>*</span> <span>4</span><span>))</span></span>
<span>12</span>
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>
<h2 id="expr-命令" tabindex="-1"> expr 命令</h2>
<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>
<div><pre><code>$ <span>expr</span> <span>3</span> + <span>2</span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>expr</code> 命令支持变量替换。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>3</span>
$ <span>expr</span> <span>$foo</span> + <span>2</span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>
<div><pre><code>$ <span>expr</span> <span>3.5</span> + <span>2</span>
expr: 非整数参数
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数组</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/array.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/array.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">数组</source>
      <description>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>

<h2 id="创建数组" tabindex="-1"> 创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div><pre><code>ARRAY<span>[</span>INDEX<span>]</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>
<p>下面创建一个三个成员的数组。</p>
<div><pre><code>array<span>[</span><span>0</span><span>]</span><span>=</span>val
array<span>[</span><span>1</span><span>]</span><span>=</span>val
array<span>[</span><span>2</span><span>]</span><span>=</span>val
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>数组也可以采用一次性赋值的方式创建。</p>
<div><pre><code><span>ARRAY</span><span>=</span><span>(</span>value1 value2 <span>..</span>. valueN<span>)</span>

<span># 等同于</span>

<span>ARRAY</span><span>=</span><span>(</span>
  value1
  value2
  value3
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div><pre><code><span>array</span><span>=</span><span>(</span>a b c<span>)</span>
<span>array</span><span>=</span><span>(</span><span>[</span><span>2</span><span>]</span><span>=</span>c <span>[</span><span>0</span><span>]</span><span>=</span>a <span>[</span><span>1</span><span>]</span><span>=</span>b<span>)</span>

<span>days</span><span>=</span><span>(</span>Sun Mon Tue Wed Thu Fri Sat<span>)</span>
<span>days</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span>Sun <span>[</span><span>1</span><span>]</span><span>=</span>Mon <span>[</span><span>2</span><span>]</span><span>=</span>Tue <span>[</span><span>3</span><span>]</span><span>=</span>Wed <span>[</span><span>4</span><span>]</span><span>=</span>Thu <span>[</span><span>5</span><span>]</span><span>=</span>Fri <span>[</span><span>6</span><span>]</span><span>=</span>Sat<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>只为某些值指定位置，也是可以的。</p>
<div><pre><code><span>names</span><span>=</span><span>(</span>hatter <span>[</span><span>5</span><span>]</span><span>=</span>duchess alice<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div><pre><code><span>mp3s</span><span>=</span><span>(</span> *.mp3 <span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>
<div><pre><code><span>declare</span> -a ARRAYNAME
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>
<div><pre><code><span>read</span> -a dice
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>
<h2 id="读取数组" tabindex="-1"> 读取数组</h2>
<h3 id="读取单个元素" tabindex="-1"> 读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div><pre><code><span>echo</span> <span>${array<span>[</span>i<span>]</span>}</span>     <span># i 是索引</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>
<div><pre><code>$ array<span>[</span><span>0</span><span>]</span><span>=</span>a

$ <span>echo</span> <span>${array<span>[</span>0<span>]</span>}</span>
a

$ <span>echo</span> <span>$array</span><span>[</span><span>0</span><span>]</span>
a<span>[</span><span>0</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>
<h3 id="读取所有成员" tabindex="-1"> 读取所有成员</h3>
<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>"<span>${names<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>
<div><pre><code>$ <span>activities</span><span>=</span><span>(</span> swimming <span>"water skiing"</span> canoeing <span>"white-water rafting"</span> surfing <span>)</span>
$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>@<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>*<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>*<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming water skiing canoeing white-water rafting surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span> <span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"${activities[@]"</span> diving <span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>
<h3 id="默认位置" tabindex="-1"> 默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>
<div><pre><code>$ <span>declare</span> -a foo
$ <span>foo</span><span>=</span>A
$ <span>echo</span> <span>${foo<span>[</span>0<span>]</span>}</span>
A
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo}</span>
a
$ <span>echo</span> <span>$foo</span>
a
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>
<h2 id="数组的长度" tabindex="-1"> 数组的长度</h2>
<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>
<div><pre><code><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>
<span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>*<span>]</span>}</span>
<span>1</span>

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>@<span>]</span>}</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo
$ <span>echo</span> <span>${<span>#</span>a<span>[</span>100<span>]</span>}</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>
<h2 id="提取数组序号" tabindex="-1"> 提取数组序号</h2>
<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div><pre><code>$ <span>arr</span><span>=</span><span>(</span><span>[</span><span>5</span><span>]</span><span>=</span>a <span>[</span><span>9</span><span>]</span><span>=</span>b <span>[</span><span>23</span><span>]</span><span>=</span>c<span>)</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>*<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>
<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>
<div><pre><code><span>arr</span><span>=</span><span>(</span>a b c d<span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span>
  <span>echo</span> <span>${arr<span>[</span>i<span>]</span>}</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="提取数组成员" tabindex="-1"> 提取数组成员</h2>
<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>
<div><pre><code>$ <span>food</span><span>=</span><span>(</span> apples bananas cucumbers dates eggs fajitas grapes <span>)</span>
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>1}</span>
bananas
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>3}</span>
bananas cucumbers dates
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>
<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>
<div><pre><code>$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>4}</span>
eggs fajitas grapes
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>
<h2 id="追加数组成员" tabindex="-1"> 追加数组成员</h2>
<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c

$ <span>foo</span><span>+=</span><span>(</span>d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="删除数组" tabindex="-1"> 删除数组</h2>
<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f

$ <span>unset</span> foo<span>[</span><span>2</span><span>]</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ foo<span>[</span><span>1</span><span>]</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div><pre><code>foo<span>[</span><span>1</span><span>]</span><span>=</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>foo</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
b c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code> 可以清空整个数组。</p>
<div><pre><code>$ <span>unset</span> ARRAY

$ <span>echo</span> <span>${ARRAY<span>[</span>*<span>]</span>}</span>
<span>&lt;</span>--no output--<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="关联数组" tabindex="-1"> 关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code> 可以声明关联数组。</p>
<div><pre><code><span>declare</span> -A colors
colors<span>[</span><span>"red"</span><span>]</span><span>=</span><span>"#ff0000"</span>
colors<span>[</span><span>"green"</span><span>]</span><span>=</span><span>"#00ff00"</span>
colors<span>[</span><span>"blue"</span><span>]</span><span>=</span><span>"#0000ff"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div><pre><code><span>echo</span> <span>${colors<span>[</span>"blue"<span>]</span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>条件判断</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/condition.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/condition.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">条件判断</source>
      <description>本章介绍 Bash 脚本的条件判断语法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>

<h2 id="if-结构" tabindex="-1"> if 结构</h2>
<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div><pre><code><span>if</span> commands<span>;</span> <span>then</span>
  commands
<span>[</span>elif commands<span>;</span> <span>then</span>
  commands<span>..</span>.<span>]</span>
<span>[</span>else
  commands<span>]</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>
<div><pre><code><span>if</span> <span>test</span> <span>$USER</span> <span>=</span> <span>"foo"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Hello foo."</span>
<span>else</span>
  <span>echo</span> <span>"You are not foo."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div><pre><code><span>if</span> <span>true</span>
<span>then</span>
  <span>echo</span> <span>'hello world'</span>
<span>fi</span>

<span>if</span> <span>false</span>
<span>then</span>
  <span>echo</span> <span>'it is false'</span> <span># 本行不会执行</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>
<div><pre><code>$ <span>if</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world

$ <span>if</span> <span>false</span><span>;</span> <span>then</span> <span>echo</span> <span>"It's true."</span><span>;</span> <span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>
<div><pre><code>$ <span>if</span> <span>echo</span> <span>'hi'</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hi
hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>
<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>
<div><pre><code>$ <span>if</span> <span>false</span><span>;</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>
<p><code>elif</code> 部分可以有多个。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>if</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>1</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"2"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>2</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>3</span>
<span>else</span>
    <span>echo</span> 输入不符合要求
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>
<h2 id="test-命令" tabindex="-1"> test 命令</h2>
<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>
<div><pre><code><span># 写法一</span>
<span>test</span> expression

<span># 写法二</span>
<span>[</span> expression <span>]</span>

<span># 写法三</span>
<span>[</span><span>[</span> expression <span>]</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>
<div><pre><code>$ <span>test</span> -f /etc/hosts
$ <span>echo</span> <span>$?</span>
<span>0</span>

$ <span>[</span> -f /etc/hosts <span>]</span>
$  <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>
<div><pre><code><span># 写法一</span>
<span>if</span> <span>test</span> -e /tmp/foo.txt <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法二</span>
<span>if</span> <span>[</span> -e /tmp/foo.txt <span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法三</span>
<span>if</span> <span>[</span><span>[</span> -e /tmp/foo.txt <span>]</span><span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="判断表达式" tabindex="-1"> 判断表达式</h2>
<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="文件判断" tabindex="-1"> 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>
<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>
<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>
<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>
<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>
<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>
<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>
<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>
<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>
<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>
<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>
<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>
<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>
<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>
<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>
<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>FILE</span><span>=~</span>/.bashrc

<span>if</span> <span>[</span> -e <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span> -f <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a regular file."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -d <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a directory."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -r <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is readable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -w <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is writable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -x <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is executable/searchable."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"<span>$FILE</span> does not exist"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p>
<h3 id="字符串判断" tabindex="-1"> 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>
<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>ANSWER</span><span>=</span>maybe

<span>if</span> <span>[</span> -z <span>"<span>$ANSWER</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"There is no answer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"yes"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is YES."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"no"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is NO."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"maybe"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is MAYBE."</span>
<span>else</span>
  <span>echo</span> <span>"The answer is UNKNOWN."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p>
<h3 id="整数判断" tabindex="-1"> 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span> -z <span>"<span>$INT</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is empty."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>$INT</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is zero."</span>
<span>else</span>
  <span>if</span> <span>[</span> <span>$INT</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is negative."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is positive."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> <span><span>$((</span>INT <span>%</span> <span>2</span><span>))</span></span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is even."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is odd."</span>
  <span>fi</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="正则判断" tabindex="-1"> 正则判断</h3>
<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>
<div><pre><code><span>[</span><span>[</span> string1 <span>=~</span> regex <span>]</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is an integer."</span>
  <span>exit</span> <span>0</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test-判断的逻辑运算" tabindex="-1"> test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>
<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>
<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>
</ul>
<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>MIN_VAL</span><span>=</span><span>1</span>
<span>MAX_VAL</span><span>=</span><span>100</span>

<span>INT</span><span>=</span><span>50</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span><span>[</span> <span>$INT</span> -ge <span>$MIN_VAL</span> <span>&amp;&amp;</span> <span>$INT</span> -le <span>$MAX_VAL</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is within <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
  <span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is out of range."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>
<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>
<div><pre><code><span>if</span> <span>[</span> <span>!</span> <span>\</span><span>(</span> <span>$INT</span> -ge <span>$MIN_VAL</span> -a <span>$INT</span> -le <span>$MAX_VAL</span> <span>\</span><span>)</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is outside <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
<span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is in range."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="算术判断" tabindex="-1"> 算术判断</h3>
<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>
<div><pre><code><span>if</span> <span><span>((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span><span>;</span> <span>then</span>
  <span>echo</span> <span>"true"</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>
<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span><span>1</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>fi</span>
It is true.
$ <span>if</span> <span><span>((</span><span>0</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>else</span> <span>echo</span> <span>"it is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>
<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>5</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"foo is <span>$foo</span>"</span><span>;</span> <span>fi</span>
foo is <span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>0</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span><span>else</span> <span>echo</span> <span>"It is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是用算术条件改写的数值判断脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span><span>((</span>INT <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is zero."</span>
  <span>else</span>
    <span>if</span> <span><span>((</span>INT <span>&lt;</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is negative."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is positive."</span>
    <span>fi</span>
    <span>if</span> <span><span>((</span> <span>((</span>INT <span>%</span> <span>2</span><span>))</span></span> <span>==</span> <span>0</span><span>))</span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is even."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is odd."</span>
    <span>fi</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href="/linux/bash/arithmetic.html">Bash 的算术运算</a> 一章。</p>
<h3 id="普通命令的逻辑运算" tabindex="-1"> 普通命令的逻辑运算</h3>
<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
command1 <span>||</span> command2
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>
<div><pre><code><span>mkdir</span> temp <span>&amp;&amp;</span> <span>cd</span> temp
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div><pre><code><span>[</span> -d temp <span>]</span> <span>||</span> <span>mkdir</span> temp
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div><pre><code><span>[</span> <span>!</span> -d temp <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>
<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span> <span>&amp;&amp;</span> <span>[</span> condition <span>]</span><span>;</span> <span>then</span>
  <span>command</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面是一个示例。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>filename</span><span>=</span><span>$1</span>
<span>word1</span><span>=</span><span>$2</span>
<span>word2</span><span>=</span><span>$3</span>

<span>if</span> <span>grep</span> <span>$word1</span> <span>$filename</span> <span>&amp;&amp;</span> <span>grep</span> <span>$word2</span> <span>$filename</span>
<span>then</span>
  <span>echo</span> <span>"<span>$word1</span> and <span>$word2</span> are both in <span>$filename</span>."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>
<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>"<span>$dir_name</span>"</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 等同于</span>

<span>if</span> <span>[</span><span>[</span> <span>!</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"No such directory: '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>cd</span> <span>"<span>$dir_name</span>"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Cannot cd to '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>rm</span> *<span>;</span> <span>then</span>
  <span>echo</span> <span>"File deletion failed. Check results"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="case-结构" tabindex="-1"> case 结构</h2>
<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>
<div><pre><code><span>case</span> expression <span>in</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  <span>..</span>.
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>1</span> <span>)</span> <span>echo</span> <span>1</span>
    <span>;</span><span>;</span>
  <span>2</span> <span>)</span> <span>echo</span> <span>2</span>
    <span>;</span><span>;</span>
  <span>3</span> <span>)</span> <span>echo</span> <span>3</span>
    <span>;</span><span>;</span>
  * <span>)</span> <span>echo</span> 输入不符合要求
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>
<p>下面是另一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>OS</span><span>=</span><span><span>$(</span><span>uname</span> -s<span>)</span></span>

<span>case</span> <span>"<span>$OS</span>"</span> <span>in</span>
  FreeBSD<span>)</span> <span>echo</span> <span>"This is FreeBSD"</span> <span>;</span><span>;</span>
  Darwin<span>)</span> <span>echo</span> <span>"This is Mac OSX"</span> <span>;</span><span>;</span>
  AIX<span>)</span> <span>echo</span> <span>"This is AIX"</span> <span>;</span><span>;</span>
  Minix<span>)</span> <span>echo</span> <span>"This is Minix"</span> <span>;</span><span>;</span>
  Linux<span>)</span> <span>echo</span> <span>"This is Linux"</span> <span>;</span><span>;</span>
  *<span>)</span> <span>echo</span> <span>"Failed to identify this OS"</span> <span>;</span><span>;</span>
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>: 匹配 <code>a</code>。</li>
<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>
<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>
<li><code>???)</code>: 匹配 3 个字符的单词。</li>
<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>
<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个字母或数字 > "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span> <span>|</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span> <span>)</span> <span>echo</span> <span>"输入了字母 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  <span>[</span><span>0</span>-9<span>]</span> <span>)</span>                     <span>echo</span> <span>"输入了数字 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  * <span>)</span>                         <span>echo</span> <span>"输入不符合要求"</span>
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>
<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>read</span> -n <span>1</span> -p <span>"Type a character > "</span>
<span>echo</span>
<span>case</span> <span>$REPLY</span> <span>in</span>
  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is upper case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is lower case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:alpha:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is alphabetic."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:digit:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a digit."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:graph:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a visible character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:punct:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a punctuation symbol."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:space:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a whitespace character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:xdigit:<span>]</span><span>]</span><span>)</span>   <span>echo</span> <span>"'<span>$REPLY</span>' is a hexadecimal digit."</span> <span>;</span><span>;</span><span>&amp;</span>
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，会得到下面的结果。</p>
<div><pre><code>$ test.sh
Type a character <span>></span> a
<span>'a'</span> is lower case.
<span>'a'</span> is alphabetic.
<span>'a'</span> is a visible character.
<span>'a'</span> is a hexadecimal digit.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener noreferrer">The Linux command-line</a>, William Shotts</li>
<li><a href="https://www.pcwdld.com/linux-commands-cheat-sheet" target="_blank" rel="noopener noreferrer">Linux Commands Cheat Sheet</a> (一个很简短的 CheatSheet)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>脚本除错</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/debug.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/debug.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">脚本除错</source>
      <description>本章介绍如何对 Shell 脚本除错。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>

<h2 id="常见错误" tabindex="-1"> 常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>dir_name</span><span>=</span>/path/not/exist

<span>cd</span> <span>$dir_name</span>
<span>rm</span> *
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div><pre><code><span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>echo</span> <span>rm</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash-的-x-参数" tabindex="-1"> <code>bash</code> 的 <code>-x</code> 参数</h2>
<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本 <code>script.sh</code>。</p>
<div><pre><code><span># script.sh</span>
<span>echo</span> hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>
<div><pre><code>$ <span>bash</span> -x script.sh
+ <span>echo</span> hello world
hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>
<div><pre><code><span>#! /bin/bash -x</span>
<span># trouble: script to demonstrate common errors</span>

<span>number</span><span>=</span><span>1</span>
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>1</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number is equal to 1."</span>
<span>else</span>
  <span>echo</span> <span>"Number is not equal to 1."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>
<div><pre><code>$ trouble
+ <span>number</span><span>=</span><span>1</span>
+ <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
+ <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>
<div><pre><code>$ <span>export</span> <span><span>PS4</span></span><span>=</span><span>'$LINENO + '</span>
$ trouble
<span>5</span> + <span>number</span><span>=</span><span>1</span>
<span>7</span> + <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
<span>8</span> + <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href="/linux/bash/set.html">set 命令</a> 一章。</p>
<h2 id="环境变量" tabindex="-1"> 环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3 id="lineno" tabindex="-1"> LINENO</h3>
<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"This is line <span>$LINENO</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>
<div><pre><code>$ ./test.sh
This is line <span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="funcname" tabindex="-1"> FUNCNAME</h3>
<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>

<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>

func1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>
<div><pre><code>$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>
<h3 id="bash-source" tabindex="-1"> BASH_SOURCE</h3>
<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>
<h3 id="bash-lineno" tabindex="-1"> BASH_LINENO</h3>
<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>

  func2
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: <span>BASH_LINENO</span> is <span>7</span>
func1: FUNCNAME is func1
func1: <span>BASH_SOURCE</span> is main.sh
func2: <span>BASH_LINENO</span> is <span>8</span>
func2: FUNCNAME is func2
func2: <span>BASH_SOURCE</span> is lib1.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的模式扩展</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/expansion.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/expansion.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 的模式扩展</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div><pre><code>$ <span>set</span> -o noglob
<span># 或者</span>
$ <span>set</span> -f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面的命令可以重新打开扩展。</p>
<div><pre><code>$ <span>set</span> +o noglob
<span># 或者</span>
$ <span>set</span> +f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="波浪线扩展" tabindex="-1"> 波浪线扩展</h2>
<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>
<div><pre><code>$ <span>echo</span> ~
/home/me
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>
<div><pre><code><span># 进入 /home/me/foo 目录</span>
$ <span>cd</span> ~/foo
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>
<div><pre><code>$ <span>echo</span> ~foo
/home/foo

$ <span>echo</span> ~root
/root
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>
<div><pre><code>$ <span>echo</span> ~nonExistedUser
~nonExistedUser
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>
<div><pre><code>$ <span>cd</span> ~/foo
$ <span>echo</span> ~+
/home/me/foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="字符扩展" tabindex="-1"> <code>?</code> 字符扩展</h2>
<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> ?.txt
a.txt b.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> ??.txt
ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div><pre><code><span># 当前目录有 a.txt 文件</span>
$ <span>echo</span> ?.txt
a.txt

<span># 当前目录为空目录</span>
$ <span>echo</span> ?.txt
?.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>
<h2 id="字符扩展-1" tabindex="-1"> <code>*</code> 字符扩展</h2>
<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> *.txt
a.txt b.txt ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>
<div><pre><code><span>ls</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> a*.txt
a.txt ab.txt

$ <span>ls</span> *b*
b.txt ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>
<div><pre><code><span># 显示所有隐藏文件</span>
$ <span>echo</span> .*
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>
<div><pre><code><span>echo</span> .<span>[</span><span>!</span>.<span>]</span>*
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div><pre><code><span># 当前目录不存在 c 开头的文件</span>
$ <span>echo</span> c*.txt
c*.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>
<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>
<div><pre><code><span># 子目录有一个 a.txt</span>
<span># 无效的写法</span>
$ <span>ls</span> *.txt

<span># 有效的写法</span>
$ <span>ls</span> */*.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>
<h2 id="方括号扩展" tabindex="-1"> 方括号扩展</h2>
<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt b.txt

<span># 只存在文件 a.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div><pre><code><span># 不存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
ls: 无法访问<span>'[ab].txt'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>
<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>
<div><pre><code><span># 存在 aaa、bbb、aba 三个文件</span>
$ <span>ls</span> ?<span>[</span><span>!</span>a<span>]</span>?
aba bbb
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>
<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展" tabindex="-1"> [start-end] 扩展</h2>
<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 c.txt</span>
$ <span>ls</span> <span>[</span>a-c<span>]</span>.txt
a.txt
b.txt
c.txt

<span># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ <span>ls</span> report<span>[</span><span>0</span>-9<span>]</span>.txt
report1.txt
report2.txt
report3.txt
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>: 所有小写字母。</li>
<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>
<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>
<div><pre><code>$ <span>echo</span> report<span>[</span><span>!</span><span>1</span>–3<span>]</span>.txt
report4.txt report5.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>
<h2 id="大括号扩展" tabindex="-1"> 大括号扩展</h2>
<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1,2</span>,3<span>}</span>
<span>1</span> <span>2</span> <span>3</span>

$ <span>echo</span> d<span>{</span>a,e,i,u,o<span>}</span>g
dag deg <span>dig</span> dug dog

$ <span>echo</span> Front-<span>{</span>A,B,C<span>}</span>-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div><pre><code>$ <span>ls</span> <span>{</span>a,b,c<span>}</span>.txt
ls: 无法访问<span>'a.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'b.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'c.txt'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1</span> , <span>2</span><span>}</span>
<span>{</span><span>1</span> , <span>2</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div><pre><code>$ <span>cp</span> a.log<span>{</span>,.bak<span>}</span>

<span># 等同于</span>
<span># cp a.log a.log.bak</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>大括号可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>j<span>{</span>p,pe<span>}</span>g,png<span>}</span>
jpg jpeg png

$ <span>echo</span> a<span>{</span>A<span>{</span><span>1,2</span><span>}</span>,B<span>{</span><span>3,4</span><span>}</span><span>}</span>b
aA1b aA2b aB3b aB4b
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,d*<span>}</span>
<span>cat</span> dawg dg <span>dig</span> dog doug dug
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,dog<span>}</span>
<span>cat</span> dog
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div><pre><code><span># 不存在 a.txt 和 b.txt</span>
$ <span>echo</span> <span>[</span>ab<span>]</span>.txt
<span>[</span>ab<span>]</span>.txt

$ <span>echo</span> <span>{</span>a,b<span>}</span>.txt
a.txt b.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>
<h2 id="start-end-扩展-1" tabindex="-1"> {start..end} 扩展</h2>
<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span>
a b c

$ <span>echo</span> d<span>{</span>a<span>..</span>d<span>}</span>g
dag dbg dcg ddg

$ <span>echo</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>1</span> <span>2</span> <span>3</span> <span>4</span>

$ <span>echo</span> Number_<span>{</span><span>1</span><span>..</span><span>5</span><span>}</span>
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这种简写形式支持逆序。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>c<span>..</span>a<span>}</span>
c b a

$ <span>echo</span> <span>{</span><span>5</span><span>..</span><span>1</span><span>}</span>
<span>5</span> <span>4</span> <span>3</span> <span>2</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a1<span>..</span>3c<span>}</span>
<span>{</span>a1<span>..</span>3c<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div><pre><code>$ <span>echo</span> .<span>{</span>mp<span>{</span><span>3</span><span>..</span><span>4</span><span>}</span>,m4<span>{</span>a,b,p,v<span>}</span><span>}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>
<div><pre><code><span>mkdir</span> <span>{</span><span>2007</span><span>..</span><span>2009</span><span>}</span>-<span>{</span>01<span>..</span><span>12</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>01<span>..</span><span>5</span><span>}</span>
01 02 03 04 05

$ <span>echo</span> <span>{</span>001<span>..</span><span>5</span><span>}</span>
001 002 003 004 005
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>0</span><span>..</span><span>8</span><span>..</span><span>2</span><span>}</span>
<span>0</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span><span>{</span><span>1</span><span>..</span><span>3</span><span>}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="变量扩展" tabindex="-1"> 变量扩展</h2>
<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href="/linux/bash/variable.html">Bash 变量</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>SHELL</span>}</span>
/bin/bash
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>!</span>S*}</span>
<span>SECONDS</span> <span>SHELL</span> <span>SHELLOPTS</span> <span>SHLVL</span> SSH_AGENT_PID <span>SSH_AUTH_SOCK</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>
<h2 id="子命令扩展" tabindex="-1"> 子命令扩展</h2>
<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>date</span><span>)</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>`</span><span>date</span><span>`</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展" tabindex="-1"> 算术扩展</h2>
<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href="/linux/bash/arithmetic.html">Bash 的算术运算</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="字符类" tabindex="-1"> 字符类</h2>
<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>
<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>
<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>
<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>
</ul>
<p>请看下面的例子。</p>
<div><pre><code><span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>
<div><pre><code><span>echo</span> <span>[</span><span>!</span><span>[</span>:digit:<span>]</span><span>]</span>*
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div><pre><code><span># 不存在以大写字母开头的文件</span>
$ <span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点" tabindex="-1"> 使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p>(1)<strong>通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div><pre><code>$ <span>ls</span> a*.txt
ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>
<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div><pre><code><span># 不存在 r 开头的文件名</span>
$ <span>echo</span> r*
r*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>
<p>下面是另一个例子。</p>
<div><pre><code>$ <span>ls</span> *.csv
ls: *.csv: No such <span>file</span> or directory
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>
<p>(3)<strong>只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div><pre><code><span>ls</span> */*.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>
<p>(4)<strong>文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div><pre><code>$ <span>touch</span> <span>'fo*'</span>
$ <span>ls</span>
fo*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>
<h2 id="量词语法" tabindex="-1"> 量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>
<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>.<span>)</span>txt
abctxt abc.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>def<span>)</span>
abc abcdef
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>|</span>.php<span>)</span>
abc.php abc.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>)</span>
abc.txt abc.txt.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div><pre><code><span># 没有 abc 开头的文件名</span>
$ <span>ls</span> abc?<span>(</span>def<span>)</span>
ls: 无法访问<span>'abc?(def)'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>
<h2 id="shopt-命令" tabindex="-1"> shopt 命令</h2>
<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code> 命令的使用方法如下。</p>
<div><pre><code><span># 打开某个参数</span>
$ <span>shopt</span> -s <span>[</span>optionname<span>]</span>

<span># 关闭某个参数</span>
$ <span>shopt</span> -u <span>[</span>optionname<span>]</span>

<span># 查询某个参数关闭还是打开</span>
$ <span>shopt</span> <span>[</span>optionname<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol>
<li>
<p><strong>dotglob 参数</strong></p>
<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div><pre><code>$ <span>ls</span> *
abc.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>
<div><pre><code>$ <span>shopt</span> -s dotglob
$ <span>ls</span> *
abc.txt .config
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
<li>
<p><strong>nullglob 参数</strong></p>
<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div><pre><code>$ <span>rm</span> b*
rm: 无法删除<span>'b*'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>
<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>
<div><pre><code>$ <span>shopt</span> -s nullglob
$ <span>rm</span> b*
rm: 缺少操作数
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>
</li>
<li>
<p><strong>failglob 参数</strong></p>
<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div><pre><code>$ <span>shopt</span> -s failglob
$ <span>rm</span> b*
bash: 无匹配: b*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>
</li>
<li>
<p><strong>extglob 参数</strong></p>
<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div><pre><code><span>shopt</span> -u extglob
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong>nocaseglob 参数</strong></p>
<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>
<div><pre><code>$ <span>shopt</span> -s nocaseglob
$ <span>ls</span> /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span>(</span>x86<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>
</li>
<li>
<p><strong>globstar 参数</strong></p>
<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div><pre><code>a.txt
sub1/b.txt
sub1/sub2/c.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>
<p>默认情况下，只能写成下面这样。</p>
<div><pre><code>$ <span>ls</span> *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>
<div><pre><code>$ <span>shopt</span> -s globstar
$ <span>ls</span> **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
</ol>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener noreferrer">Think You Understand Wildcards? Think Again</a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener noreferrer">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 函数</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/function.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/function.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 函数</source>
      <description>本章介绍 Bash 函数的用法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 函数的用法。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div><pre><code><span># 第一种</span>
<span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>

<span># 第二种</span>
<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div><pre><code><span>hello</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>"Hello <span>$1</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div><pre><code>$ hello world
hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div><pre><code><span>today</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> -n <span>"Today's date is: "</span>
  <span>date</span> +<span>"%A, %B %-d, %Y"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>
<div><pre><code><span>unset</span> -f functionName
</code></pre><div aria-hidden="true"><div></div></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>
<div><pre><code><span>declare</span> -f
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>
<p><code>declare</code> 命令还支持查看单个函数的定义。</p>
<div><pre><code><span>declare</span> -f functionName
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>
<div><pre><code><span>declare</span> -F
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="参数变量" tabindex="-1"> 参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>
<li><code>$0</code>: 函数所在的脚本名。</li>
<li><code>$#</code>: 函数的参数总数。</li>
<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>下面是一个示例脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>function</span> <span>alice</span> <span>{</span>
  <span>echo</span> <span>"alice: <span>$@</span>"</span>
  <span>echo</span> <span>"<span>$0</span>: <span>$1</span> <span>$2</span> <span>$3</span> <span>$4</span>"</span>
  <span>echo</span> <span>"<span>$#</span> arguments"</span>

<span>}</span>

alice <span>in</span> wonderland
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行该脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
alice: <span>in</span> wonderland
test.sh: <span>in</span> wonderland
<span>2</span> arguments
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div><pre><code><span>function</span> <span>log_msg</span> <span>{</span>
  <span>echo</span> <span>"[<span><span>`</span><span>date</span> <span>'+ %F %T'</span><span>`</span></span> ]: <span>$@</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>使用方法如下。</p>
<div><pre><code>$ log_msg <span>"This is sample log message"</span>
<span>[</span> <span>2018</span>-08-16 <span>19</span>:56:34 <span>]</span>: This is sample log message
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="return-命令" tabindex="-1"> return 命令</h2>
<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div><pre><code><span>function</span> <span>func_return_value</span> <span>{</span>
  <span>return</span> <span>10</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>
<div><pre><code>$ func_return_value
$ <span>echo</span> <span>"Value returned by function is: <span>$?</span>"</span>
Value returned by <span>function</span> is: <span>10</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>
<div><pre><code><span>function</span> <span>name</span> <span>{</span>
  commands
  <span>return</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="全局变量和局部变量-local-命令" tabindex="-1"> 全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div><pre><code><span>foo</span><span>=</span><span>1</span>

<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>2</span>
<span>}</span>

<span>echo</span> <span>$foo</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>
<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>local</span> foo
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/" target="_blank" rel="noopener noreferrer">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的基本语法</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/grammar.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/grammar.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 的基本语法</source>
      <description>本章介绍 Bash 的最基本语法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>

<h2 id="echo-命令" tabindex="-1"> echo 命令</h2>
<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>
<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div><pre><code>$ <span>echo</span> hello world
hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div><pre><code>$ <span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>
<h3 id="n-参数" tabindex="-1"> <code>-n</code> 参数</h3>
<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div><pre><code>$ <span>echo</span> -n hello world
hello world$
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>
<div><pre><code>$ <span>echo</span> a<span>;</span><span>echo</span> b
a
b

$ <span>echo</span> -n a<span>;</span><span>echo</span> b
ab
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>
<h3 id="e-参数" tabindex="-1"> <code>-e</code> 参数</h3>
<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>
<div><pre><code>$ <span>echo</span> <span>"Hello<span title="\n">\n</span>World"</span>
Hello<span>\</span>nWorld

<span># 双引号的情况</span>
$ <span>echo</span> -e <span>"Hello<span title="\n">\n</span>World"</span>
Hello
World

<span># 单引号的情况</span>
$ <span>echo</span> -e <span>'Hello\nWorld'</span>
Hello
World
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\n</code> 解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式" tabindex="-1"> 命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div><pre><code><span>command</span> <span>[</span> arg1 <span>..</span>. <span>[</span> argN <span>]</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>
<div><pre><code><span>ls</span> -l
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div><pre><code><span># 短形式</span>
$ <span>ls</span> -r

<span># 长形式</span>
$ <span>ls</span> --reverse
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div><pre><code>$ <span>echo</span> foo bar

<span># 等同于</span>
$ <span>echo</span> foo <span>\</span>
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="空格" tabindex="-1"> 空格</h2>
<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>
<div><pre><code><span>command</span> foo bar
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div><pre><code>$ <span>echo</span> this is a     <span>test</span>
this is a <span>test</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号" tabindex="-1"> 分号</h2>
<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div><pre><code><span>clear</span><span>;</span> <span>ls</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="命令的组合符-和" tabindex="-1"> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div><pre><code>Command1 <span>&amp;&amp;</span> Command2
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>
<div><pre><code>Command1 <span>||</span> Command2
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>
<p>下面是一些例子。</p>
<div><pre><code><span>cat</span> filelist.txt <span>;</span> <span>ls</span> -l filelist.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>
<div><pre><code><span>cat</span> filelist.txt <span>&amp;&amp;</span> <span>ls</span> -l filelist.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>
<div><pre><code><span>mkdir</span> foo <span>||</span> <span>mkdir</span> bar
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>
<h2 id="type-命令" tabindex="-1"> type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>
<p><code>type</code> 命令用来判断命令的来源。</p>
<div><pre><code>$ <span>type</span> <span>echo</span>
<span>echo</span> is a shell <span>builtin</span>
$ <span>type</span> <span>ls</span>
<span>ls</span> is hashed <span>(</span>/bin/ls<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>
<p><code>type</code> 命令本身也是内置命令。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>
<div><pre><code>$ <span>type</span> -a <span>echo</span>
<span>echo</span> is shell <span>builtin</span>
<span>echo</span> is /usr/bin/echo
<span>echo</span> is /bin/echo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>
<div><pre><code>$ <span>type</span> -t <span>bash</span>
<span>file</span>
$ <span>type</span> -t <span>if</span>
keyword
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>
<h2 id="快捷键" tabindex="-1"> 快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href="/linux/bash/readline.html">行操作</a> 一章。</p>
<ul>
<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>: 向上滚动。</li>
<li><code>Shift + PageDown</code>: 向下滚动。</li>
<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 简介</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/intro.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/intro.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 简介</source>
      <description>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>

<h2 id="shell-的含义" tabindex="-1"> Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="shell-的种类" tabindex="-1"> Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell(sh)</li>
<li>Bourne Again shell(bash)</li>
<li>C Shell(csh)</li>
<li>TENEX C Shell(tcsh)</li>
<li>Korn shell(ksh)</li>
<li>Z Shell(zsh)</li>
<li>Friendly Interactive Shell(fish)</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div><pre><code><span>cat</span> /etc/shells
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="命令行环境" tabindex="-1"> 命令行环境</h2>
<h3 id="终端模拟器" tabindex="-1"> 终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="命令行提示符" tabindex="-1"> 命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>
<div><pre><code><span>[</span>user@hostname<span>]</span> $
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>
<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>
<h3 id="进入和退出方法" tabindex="-1"> 进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>
<div><pre><code><span>bash</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>
<div><pre><code><span>exit</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>
<div><pre><code>$ <span>pwd</span>
/home/me
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div><pre><code>$ pwe
bash: pwe: 未找到命令
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="shell-和-bash-的历史" tabindex="-1"> Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>
<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>
<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989 年，Bash 发布 1.0 版。</p>
<p>1996 年，Bash 发布 2.0 版。</p>
<p>2004 年，Bash 发布 3.0 版。</p>
<p>2009 年，Bash 发布 4.0 版。</p>
<p>2019 年，Bash 发布 5.0 版。</p>
<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div><pre><code>$ <span>bash</span> --version
GNU bash，版本 <span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release <span>(</span>x86_64-pc-linux-gnu<span>)</span>

<span># 或者</span>
$ <span>echo</span> <span>$BASH_VERSION</span>
<span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>循环</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/loop.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/loop.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">循环</source>
      <description>Bash 提供三种循环语法 for、while 和 until。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>

<h2 id="while-循环" tabindex="-1"> while 循环</h2>
<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div><pre><code><span>while</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -lt <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>
<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>
<div><pre><code><span>while</span> <span>true</span>
<span>do</span>
  <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>
<p><code>while</code> 循环写成一行，也是可以的。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>
<div><pre><code><span>while</span> <span>echo</span> <span>'ECHO'</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, looping ...'</span><span>;</span> <span>done</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>
<h2 id="until-循环" tabindex="-1"> until 循环</h2>
<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div><pre><code><span>until</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>
<div><pre><code><span>until</span> condition
<span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>until</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, until looping ...'</span><span>;</span> <span>done</span>
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
^C
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>until</span> <span>[</span> <span>"<span>$number</span>"</span> -ge <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>
<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div><pre><code><span>until</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div><pre><code><span>while</span> <span>!</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>
<h2 id="for-in-循环" tabindex="-1"> <code>for...in</code> 循环</h2>
<p><code>for...in</code> 循环用于遍历列表的每一项。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list
<span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> word1 word2 word3<span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> *.png<span>;</span> <span>do</span>
  <span>ls</span> -l <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>count</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>cat</span> ~/.bash_profile<span>)</span></span><span>;</span> <span>do</span>
  <span>count</span><span>=</span><span><span>$((</span>count <span>+</span> <span>1</span><span>))</span></span>
  <span>echo</span> <span>"Word <span>$count</span> (<span>$i</span>) contains <span><span>$(</span><span>echo</span> -n $i <span>|</span> <span>wc</span> -c<span>)</span></span> characters"</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div><pre><code><span>for</span> filename<span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>

<span># 等同于</span>

<span>for</span> <span>filename</span> <span>in</span> <span>"<span>$@</span>"</span> <span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>
<h2 id="for-循环" tabindex="-1"> for 循环</h2>
<p><code>for</code> 循环还支持 C 语言的循环语法。</p>
<div><pre><code><span>for</span> <span><span>((</span> expression1<span>;</span> expression2<span>;</span> expression3 <span>))</span></span><span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>
<p>它等同于下面的 <code>while</code> 循环。</p>
<div><pre><code><span><span>((</span> expression1 <span>))</span></span>
<span>while</span> <span><span>((</span> expression2 <span>))</span></span><span>;</span> <span>do</span>
  commands
  <span><span>((</span> expression3 <span>))</span></span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code><span>for</span> <span><span>((</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span><span>5</span><span>;</span> i<span>=</span>i<span>+</span><span>1</span> <span>))</span></span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>
<p><code>for</code> 条件部分的三个语句，都可以省略。</p>
<div><pre><code><span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span>
<span>do</span>
  <span>read</span> var
  <span>if</span> <span>[</span> <span>"<span>$var</span>"</span> <span>=</span> <span>"."</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>
<h2 id="break-continue" tabindex="-1"> break，continue</h2>
<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>number</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span>
<span>do</span>
  <span>echo</span> <span>"number is <span>$number</span>"</span>
  <span>if</span> <span>[</span> <span>"<span>$number</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>while</span> <span>read</span> -p <span>"What file do you want to test?"</span> filename
<span>do</span>
  <span>if</span> <span>[</span> <span>!</span> -e <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"The file does not exist."</span>
    <span>continue</span>
  <span>fi</span>

  <span>echo</span> <span>"You entered a valid file.."</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>
<h2 id="select-结构" tabindex="-1"> select 结构</h2>
<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>
<div><pre><code><span>select</span> name
<span>[</span>in list<span>]</span>
<span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>
<ol>
<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体 <code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># select.sh</span>

<span>select</span> <span>brand</span> <span>in</span> Samsung Sony iphone symphony Walton
<span>do</span>
  <span>echo</span> <span>"You have chosen <span>$brand</span>"</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div><pre><code>$ ./select.sh
<span>1</span><span>)</span> Samsung
<span>2</span><span>)</span> Sony
<span>3</span><span>)</span> iphone
<span>4</span><span>)</span> symphony
<span>5</span><span>)</span> Walton
<span>#?</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Which Operating System do you like?"</span>

<span>select</span> <span>os</span> <span>in</span> Ubuntu LinuxMint Windows8 Windows7 WindowsXP
<span>do</span>
  <span>case</span> <span>$os</span> <span>in</span>
    <span>"Ubuntu"</span><span>|</span><span>"LinuxMint"</span><span>)</span>
      <span>echo</span> <span>"I also use <span>$os</span>."</span>
    <span>;</span><span>;</span>
    <span>"Windows8"</span> <span>|</span> <span>"Windows10"</span> <span>|</span> <span>"WindowsXP"</span><span>)</span>
      <span>echo</span> <span>"Why don't you try Linux?"</span>
    <span>;</span><span>;</span>
    *<span>)</span>
      <span>echo</span> <span>"Invalid entry."</span>
      <span>break</span>
    <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/" target="_blank" rel="noopener noreferrer">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>mktemp 命令，trap 命令</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/mktemp.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/mktemp.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">mktemp 命令，trap 命令</source>
      <description>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 /tmp 目录里面创建文件或目录，这样做有很多弊端，使用 mktemp 命令是最安全的做法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>

<h2 id="临时文件的安全问题" tabindex="-1"> 临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在 <code>/tmp</code> 目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code> 目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div><pre><code>$ <span>touch</span> /tmp/info.txt
$ <span>ls</span> -l /tmp/info.txt
-rw-r--r-- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>17</span>:12 /tmp/info.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令在 <code>/tmp</code> 目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件(使用 <code>trap</code> 命令)。</li>
</ul>
</blockquote>
<h2 id="mktemp-命令的用法" tabindex="-1"> mktemp 命令的用法</h2>
<p><code>mktemp</code> 命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行 <code>mktemp</code> 命令，就能生成一个临时文件。</p>
<div><pre><code>$ mktemp
/tmp/tmp.4GcsWSG4vj

$ <span>ls</span> -l /tmp/tmp.4GcsWSG4vj
-rw------- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>12</span>:49 /tmp/tmp.4GcsWSG4vj
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，<code>mktemp</code> 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用 <code>mktemp</code> 命令的用法如下。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>为了确保临时文件创建成功，<code>mktemp</code> 命令后面最好使用 OR 运算符 (<code>||</code>)，保证创建失败时退出脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>为了保证脚本退出时临时文件被删除，可以使用 <code>trap</code> 命令指定退出时的清除操作。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="mktemp-命令的参数" tabindex="-1"> mktemp 命令的参数</h2>
<p><code>-d</code> 参数可以创建一个临时目录。</p>
<div><pre><code>$ mktemp -d
/tmp/tmp.Wcau5UjmN6
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>-p</code> 参数可以指定临时文件所在的目录。默认是使用 <code>$TMPDIR</code> 环境变量指定的目录，如果这个变量没设置，那么使用 <code>/tmp</code> 目录。</p>
<div><pre><code>$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>-t</code> 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 <code>X</code> 字符，表示随机字符，建议至少使用六个 <code>X</code>。默认的文件名模板是 <code>tmp.</code> 后接十个随机字符。</p>
<div><pre><code>$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="trap-命令" tabindex="-1"> trap 命令</h2>
<p><code>trap</code> 命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT(中断)，即按 <code>Ctrl + C</code> 所产生的信号。<code>trap</code> 命令的 <code>-l</code> 参数，可以列出所有的系统信号。</p>
<div><pre><code>$ <span>trap</span> -l
 <span>1</span><span>)</span> SIGHUP  <span>2</span><span>)</span> SIGINT  <span>3</span><span>)</span> SIGQUIT  <span>4</span><span>)</span> SIGILL  <span>5</span><span>)</span> SIGTRAP
 <span>6</span><span>)</span> SIGABRT  <span>7</span><span>)</span> SIGBUS  <span>8</span><span>)</span> SIGFPE  <span>9</span><span>)</span> SIGKILL <span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV <span>12</span><span>)</span> SIGUSR2 <span>13</span><span>)</span> SIGPIPE <span>14</span><span>)</span> SIGALRM <span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT <span>17</span><span>)</span> SIGCHLD <span>18</span><span>)</span> SIGCONT <span>19</span><span>)</span> SIGSTOP <span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN <span>22</span><span>)</span> SIGTTOU <span>23</span><span>)</span> SIGURG <span>24</span><span>)</span> SIGXCPU <span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM <span>27</span><span>)</span> SIGPROF <span>28</span><span>)</span> SIGWINCH <span>29</span><span>)</span> SIGIO <span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS <span>34</span><span>)</span> SIGRTMIN <span>35</span><span>)</span> SIGRTMIN+1 <span>36</span><span>)</span> SIGRTMIN+2 <span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN+4 <span>39</span><span>)</span> SIGRTMIN+5 <span>40</span><span>)</span> SIGRTMIN+6 <span>41</span><span>)</span> SIGRTMIN+7 <span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN+9 <span>44</span><span>)</span> SIGRTMIN+10 <span>45</span><span>)</span> SIGRTMIN+11 <span>46</span><span>)</span> SIGRTMIN+12 <span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN+14 <span>49</span><span>)</span> SIGRTMIN+15 <span>50</span><span>)</span> SIGRTMAX-14 <span>51</span><span>)</span> SIGRTMAX-13 <span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11 <span>54</span><span>)</span> SIGRTMAX-10 <span>55</span><span>)</span> SIGRTMAX-9 <span>56</span><span>)</span> SIGRTMAX-8 <span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6 <span>59</span><span>)</span> SIGRTMAX-5 <span>60</span><span>)</span> SIGRTMAX-4 <span>61</span><span>)</span> SIGRTMAX-3 <span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1 <span>64</span><span>)</span> SIGRTMAX
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>trap</code> 的命令格式如下。</p>
<div><pre><code><span>trap</span> <span>[</span>动作<span>]</span> <span>[</span>信号1<span>]</span> <span>[</span>信号2<span>]</span> <span>..</span>.
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP: 编号 1，脚本与所在的终端脱离联系。</li>
<li>INT: 编号 2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT: 编号 3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL: 编号 9，该信号用于杀死进程。</li>
<li>TERM: 编号 15，这是 <code>kill</code> 命令发出的默认信号。</li>
<li>EXIT: 编号 0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code> 命令响应 <code>EXIT</code> 信号的写法如下。</p>
<div><pre><code><span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，脚本遇到 <code>EXIT</code> 信号时，就会执行 <code>rm -f &quot;$TMPFILE&quot;</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>ls</span> /etc <span>></span> <span>$TMPFILE</span>
<span>if</span> <span>grep</span> -qi <span>"kernel"</span> <span>$TMPFILE</span><span>;</span> <span>then</span>
  <span>echo</span> <span>'find'</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，不管是脚本正常执行结束，还是用户按 <code>Ctrl + C</code> 终止，都会产生 <code>EXIT</code> 信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code> 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果 <code>trap</code> 需要触发多条命令，可以封装一个 Bash 函数。</p>
<div><pre><code><span>function</span> <span>egress</span> <span>{</span>
  command1
  command2
  command3
<span>}</span>

<span>trap</span> egress EXIT
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html" target="_blank" rel="noopener noreferrer">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html" target="_blank" rel="noopener noreferrer">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener noreferrer">Sending and Trapping Signals</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令提示符</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/prompt.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/prompt.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">命令提示符</source>
      <description>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>

<h2 id="环境变量-ps1" tabindex="-1"> 环境变量 PS1</h2>
<p>命令提示符通常是美元符号 <code>$</code>，对于根用户则是井号 <code>#</code>。这个符号是环境变量 <code>PS1</code> 决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div><pre><code><span>echo</span> <span>$PS1</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后 的 <code>PS1</code>，可以放在用户的 Bash 配置文件 <code>.bashrc</code> 里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>: 响铃，计算机发出一记声音。</li>
<li><code>\d</code>: 以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>: 本机的主机名。</li>
<li><code>\H</code>: 完整的主机名。</li>
<li><code>\j</code>: 运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>: 当前终端设备名。</li>
<li><code>\n</code>: 一个换行符。</li>
<li><code>\r</code>: 一个回车符。</li>
<li><code>\s</code>: Shell 的名称。</li>
<li><code>\t</code>: 24 小时制的 <code>hours:minutes:seconds</code> 格式表示当前时间。</li>
<li><code>\T</code>: 12 小时制的当前时间。</li>
<li><code>\@</code>: 12 小时制的 <code>AM/PM</code> 格式表示当前时间。</li>
<li><code>\A</code>: 24 小时制的 <code>hours:minutes</code> 表示当前时间。</li>
<li><code>\u</code>: 当前用户名。</li>
<li><code>\v</code>: Shell 的版本号。</li>
<li><code>\V</code>: Shell 的版本号和发布号。</li>
<li><code>\w</code>: 当前的工作路径。</li>
<li><code>\W</code>: 当前目录名。</li>
<li><code>\!</code>: 当前命令在命令历史中的编号。</li>
<li><code>\#</code>: 当前 shell 会话中的命令数。</li>
<li><code>\$</code>: 普通用户显示为 <code>$</code> 字符，根用户显示为 <code>#</code> 字符。</li>
<li><code>\[</code>: 非打印字符序列的开始标志。</li>
<li><code>\]</code>: 非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code> 这个提示符定义，显示出来就是 <code>[user@host ~]$</code> (具体的显示内容取决于您的系统)。</p>
<div><pre><code><span>[</span>user@host ~<span>]</span>$ <span>echo</span> <span>$PS1</span>
<span>[</span><span>\</span>u@<span>\</span>h <span>\</span>W<span>]</span><span>\</span>$
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>改写 <code>PS1</code> 变量，就可以改变这个命令提示符。</p>
<div><pre><code>$ <span><span>PS1</span></span><span>=</span><span>"\A \h \$ "</span>
<span>17</span>:33 <span>host</span> $
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>注意，<code>$</code> 后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="颜色" tabindex="-1"> 颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>: 黑色</li>
<li><code>\033[1;30m</code>: 深灰色</li>
<li><code>\033[0;31m</code>: 红色</li>
<li><code>\033[1;31m</code>: 浅红色</li>
<li><code>\033[0;32m</code>: 绿色</li>
<li><code>\033[1;32m</code>: 浅绿色</li>
<li><code>\033[0;33m</code>: 棕色</li>
<li><code>\033[1;33m</code>: 黄色</li>
<li><code>\033[0;34m</code>: 蓝色</li>
<li><code>\033[1;34m</code>: 浅蓝色</li>
<li><code>\033[0;35m</code>: 粉红</li>
<li><code>\033[1;35m</code>: 浅粉色</li>
<li><code>\033[0;36m</code>: 青色</li>
<li><code>\033[1;36m</code>: 浅青色</li>
<li><code>\033[0;37m</code>: 浅灰色</li>
<li><code>\033[1;37m</code>: 白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将 <code>PS1</code> 设成下面的代码。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码 <code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$\[\033[00m\]'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>: 蓝色</li>
<li><code>\033[1;44m</code>: 黑色</li>
<li><code>\033[0;41m</code>: 红色</li>
<li><code>\033[1;45m</code>: 粉红</li>
<li><code>\033[0;42m</code>: 绿色</li>
<li><code>\033[1;46m</code>: 青色</li>
<li><code>\033[0;43m</code>: 棕色</li>
<li><code>\033[1;47m</code>: 浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;41m\]&lt;\u@\h \W>\$\[\033[0m\] '</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="环境变量-ps2-ps3-ps4" tabindex="-1"> 环境变量 PS2，PS3，PS4</h2>
<p>除了 <code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量 <code>PS2</code> 是命令行折行输入时系统的提示符，默认为 <code>&gt;</code>。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
> world"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令中，输入 <code>hello</code> 以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是 <code>PS2</code> 定义的 <code>&gt;</code>。</p>
<p>环境变量 <code>PS3</code> 是使用 <code>select</code> 命令时，系统输入菜单的提示符。</p>
<p>环境变量 <code>PS4</code> 默认为 <code>+</code>。它是使用 Bash 的 <code>-x</code> 参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"hello world"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>使用 <code>-x</code> 参数执行这个脚本。</p>
<div><pre><code>$ <span>bash</span> -x test.sh
+ <span>echo</span> <span>'hello world'</span>
hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，输出的第一行前面有一个 <code>+</code>，这就是变量 <code>PS4</code> 定义的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>引号和转义</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/quotation.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/quotation.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">引号和转义</source>
      <description>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>

<h2 id="转义" tabindex="-1"> 转义</h2>
<p>某些字符在 Bash 里面有特殊含义(比如<code>$</code>、<code>&amp;</code>、<code>*</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>$date</span>

$
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，输出 <code>$date</code> 不会有任何结果，因为 <code>$</code> 是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”(escape)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>$date</span>
<span>$date</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令中，只有在特殊字符 <code>$</code> 前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线 (<code>\\</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>\</span>
<span>\</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>: 响铃</li>
<li><code>\b</code>: 退格</li>
<li><code>\n</code>: 换行</li>
<li><code>\r</code>: 回车</li>
<li><code>\t</code>: 制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<div><pre><code>$ <span>echo</span> a<span>\</span>tb
atb

$ <span>echo</span> -e <span>"a<span title="\t">\t</span>b"</span>
a        b
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，命令行直接输出不可打印字符，Bash 不能正确解释。必须把它们放在引号之中，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p>
<div><pre><code>$ <span>mv</span> <span>\</span>
/path/to/foo <span>\</span>
/path/to/bar

<span># 等同于</span>
$ <span>mv</span> /path/to/foo /path/to/bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号" tabindex="-1"> 单引号</h2>
<p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号 (<code>*</code>)、美元符号( <code>$</code>)、反斜杠 (<code>\</code>)等。</p>
<div><pre><code>$ <span>echo</span> <span>'*'</span>
*

$ <span>echo</span> <span>'$USER'</span>
<span>$USER</span>

$ <span>echo</span> <span>'$((2+2))'</span>
<span><span>$((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>

$ <span>echo</span> <span>'$(echo foo)'</span>
<span><span>$(</span><span>echo</span> foo<span>)</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号 (<code>$</code>)，然后再对里层的单引号转义。</p>
<div><pre><code><span># 不正确</span>
$ <span>echo</span> it<span>'s

# 不正确
$ echo '</span>it<span>\</span>'s<span>'

# 正确
$ echo $'</span>it<span>\</span>'s'
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<div><pre><code>$ <span>echo</span> <span>"it's"</span>
it's
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="双引号" tabindex="-1"> 双引号</h2>
<p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外: 美元符号(<code>$</code>)、反引号(<code>`</code>)和反斜杠(<code>\</code>)。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"*"</span>
*
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，通配符 <code>*</code> 放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"<span>$SHELL</span>"</span>
/bin/bash

$ <span>echo</span> <span>"<span><span>`</span><span>date</span><span>`</span></span>"</span>
Mon Jan <span>27</span> <span>13</span>:33:18 CST <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<div><pre><code>$ <span>echo</span> <span>"I'd say: <span title="\&quot;">\"</span>hello!<span title="\&quot;">\"</span>"</span>
I'd say: <span>"hello!"</span>

$ <span>echo</span> <span>"<span title="\\">\\</span>"</span>
<span>\</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
world"</span>
hello
world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code> 命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p>
<div><pre><code><span>ls</span> <span>"two words.txt"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>two words.txt</code> 是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<div><pre><code>$ <span>echo</span> <span>"this is a     test"</span>
this is a     <span>test</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<div><pre><code><span># 单行输出</span>
$ <span>echo</span> <span><span>$(</span><span>cal</span><span>)</span></span>
一月 <span>2020</span> 日 一 二 三 四 五 六 <span>1</span> <span>2</span> <span>3</span> <span>..</span>. <span>31</span>

<span># 原始格式输出</span>
$ <span>echo</span> <span>"<span><span>$(</span><span>cal</span><span>)</span></span>"</span>
      一月 <span>2020</span>
日 一 二 三 四 五 六
          <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>
 <span>5</span>  <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span>
<span>12</span> <span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span>
<span>19</span> <span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span>
<span>26</span> <span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果 <code>$(cal)</code> 不放在双引号之中，<code>echo</code> 就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="here-文档" tabindex="-1"> Here 文档</h2>
<p>Here 文档(here document)是一种输入多行字符串的方法，格式如下。</p>
<div><pre><code><span>&lt;&lt;</span> <span>token
text
token</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>它的格式分成开始标记(<code>&lt;&lt; token</code>)和结束标记(<code>token</code>)。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;html>
&lt;head>
    &lt;title>
    The title of your page
    &lt;/title>
&lt;/head>

&lt;body>
    Your page content goes here.
&lt;/body>
&lt;/html>
_EOF_</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>_example_
<span>$foo</span>
"<span>$foo</span>"
'<span>$foo</span>'
_example_</span>

hello world
<span>"hello world"</span>
<span>'hello world'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>$foo</code> 发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>'_example_'
$foo
"$foo"
'$foo'
_example_</span>

<span>$foo</span>
<span>"<span>$foo</span>"</span>
<span>'$foo'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，Here 文档的开始标记(<code>_example_</code>)放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>command</span> <span>&lt;&lt;</span> <span>token
  string
token</span>

<span># 等同于</span>

$ <span>echo</span> string <span>|</span> <span>command</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，Here 文档相当于 <code>echo</code> 命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如 <code>echo</code> 命令就不能用 Here 文档作为参数。</p>
<div><pre><code>$ <span>echo</span> <span>&lt;&lt;</span> <span>_example_
hello
_example_</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子不会有任何输出，因为 Here 文档对于 <code>echo</code> 命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="here-字符串" tabindex="-1"> Here 字符串</h2>
<p>Here 文档还有一个变体，叫做 Here 字符串(Here string)，使用三个小于号(<code>&lt;&lt;&lt;</code>)表示。</p>
<div><pre><code><span>&lt;&lt;&lt;</span> string
</code></pre><div aria-hidden="true"><div></div></div></div><p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 <code>cat</code> 命令只接受标准输入传入的字符串。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;&lt;</span> <span>'hi there'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'hi there'</span> <span>|</span> <span>cat</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<div><pre><code>$ md5sum <span>&lt;&lt;&lt;</span> <span>'ddd'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'ddd'</span> <span>|</span> md5sum
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>md5sum</code> 命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即 <code>md5sum ddd</code> 里面的 <code>ddd</code> 会被解释成文件名。这时就可以用 Here 字符串，将字符串传给 <code>md5sum</code> 命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>read 命令</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/read.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/read.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">read 命令</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="用法" tabindex="-1"> 用法</h2>
<p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用 <code>read</code> 命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code> 命令的格式如下。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法中，<code>options</code> 是参数选项，<code>variable</code> 是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量 <code>REPLY</code> 会包含用户输入的一整行数据。</p>
<p>下面是一个例子 <code>demo.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>read</span> text
<span>echo</span> <span>"您的输入: <span>$text</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量 <code>text</code>，在下一行显示出来。</p>
<div><pre><code>$ <span>bash</span> demo.sh
输入一些文本 <span>></span> 您好，世界
您的输入: 您好，世界
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>read</code> 可以接受用户输入的多个值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> Please, enter your firstname and lastname
<span>read</span> FN LN
<span>echo</span> <span>"Hi! <span>$LN</span>, <span>$FN</span> !"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>read</code> 根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于 <code>read</code> 命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果 <code>read</code> 命令之后没有定义变量名，那么环境变量 <code>REPLY</code> 会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>read</code> 命令除了读取键盘输入，可以用来读取文件。</p>
<div><pre><code><span>while</span> <span>read</span> myline
<span>do</span>
  <span>echo</span> <span>"<span>$myline</span>"</span>
<span>done</span> <span>&lt;</span> <span>$filename</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的例子通过 <code>read</code> 命令，读取一个文件的内容。<code>done</code> 命令后面的定向符 <code>&lt;</code>，将文件导向 <code>read</code> 命令，每次读取一行，存入变量 <code>myline</code>，直到文件读取完毕。</p>
<h2 id="参数" tabindex="-1"> 参数</h2>
<p><code>read</code> 命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-t</code> 参数</strong></p>
<p><code>read</code> 命令的 <code>-t</code> 参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>if</span> <span>read</span> -t <span>3</span> response<span>;</span> <span>then</span>
  <span>echo</span> <span>"用户已经输入了"</span>
<span>else</span>
  <span>echo</span> <span>"用户没有输入"</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，输入命令会等待 3 秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code> 根据命令的返回值，转入 <code>else</code> 代码块，继续往下执行。</p>
<p>环境变量 <code>TMOUT</code> 也可以起到同样作用，指定 <code>read</code> 命令等待用户输入的时间(单位为秒)。</p>
<div><pre><code><span>TMOUT</span><span>=</span><span>3</span>
<span>read</span> response
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子也是等待 3 秒，如果用户还没有输入，就会超时。</p>
</li>
<li>
<p><strong><code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数指定用户输入的提示信息。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，先显示 <code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
</li>
<li>
<p><strong><code>-a</code> 参数</strong></p>
<p><code>-a</code> 参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<div><pre><code>$ <span>read</span> -a people
alice duchess dodo
$ <span>echo</span> <span>${people<span>[</span>2<span>]</span>}</span>
dodo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，用户输入被赋值给一个数组 <code>people</code>，这个数组的 2 号成员就是 <code>dodo</code>。</p>
</li>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<div><pre><code>$ <span>read</span> -n <span>3</span> letter
abcdefghij
$ <span>echo</span> <span>$letter</span>
abc
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>letter</code> 只包含 3 个字母。</p>
</li>
<li>
<p><strong>-e 参数</strong></p>
<p><code>-e</code> 参数允许用户输入的时候，使用 <code>readline</code> 库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> Please input the path to the file:

<span>read</span> -e fileName

<span>echo</span> <span>$fileName</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>read</code> 命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是 <code>read</code> 命令的输入默认不支持 <code>readline</code> 库的功能。<code>-e</code> 参数就可以允许用户使用自动补全。</p>
</li>
<li>
<p><strong>其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>: 定义字符串 <code>delimiter</code> 的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>: raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>: 使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>: 使用文件描述符 <code>fd</code> 作为输入。</li>
</ul>
</li>
</ol>
<h2 id="ifs-变量" tabindex="-1"> IFS 变量</h2>
<p><code>read</code> 命令读取的值，默认是以空格分隔。可以通过自定义环境变量 <code>IFS</code>(内部字段分隔符，Internal Field Separator 的缩写)，修改分隔标志。</p>
<p><code>IFS</code> 的默认值是空格、Tab 符号、换行符号，通常取第一个(即空格)。</p>
<p>如果把 <code>IFS</code> 定义成冒号(<code>:</code>)或分号(<code>;</code>)，就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>

<span>FILE</span><span>=</span>/etc/passwd

<span>read</span> -p <span>"Enter a username > "</span> user_name
<span>file_info</span><span>=</span><span>"<span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>"</span>

<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
  <span>echo</span> <span>"User = '<span>$user</span>'"</span>
  <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
  <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
  <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
  <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
  <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
  <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>IFS</code> 设为冒号，然后用来分解 <code>/etc/passwd</code> 文件的一行。<code>IFS</code> 的赋值命令和 <code>read</code> 命令写在一行，这样的话，<code>IFS</code> 的改变仅对后面的命令生效，该命令执行后 <code>IFS</code> 会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<div><pre><code><span>OLD_IFS</span><span>=</span><span>"<span>$IFS</span>"</span>
<span><span>IFS</span></span><span>=</span><span>":"</span>
<span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
<span><span>IFS</span></span><span>=</span><span>"<span>$OLD_IFS</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>另外，上面例子中，<code>&lt;&lt;&lt;</code> 是 Here 字符串，用于将变量值转为标准输入，因为 <code>read</code> 命令只能解析标准输入。</p>
<p>如果 <code>IFS</code> 设为空字符串，就等同于将整行读入一个变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>input</span><span>=</span><span>"/path/to/txt/file"</span>
<span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r line
<span>do</span>
  <span>echo</span> <span>"<span>$line</span>"</span>
<span>done</span> <span>&lt;</span> <span>"<span>$input</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的命令可以逐行读取文件，每一行存入变量 <code>line</code>，打印出来以后再读取下一行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 行操作</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/readline.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/readline.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 行操作</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<div><pre><code><span>set</span> -o <span>vi</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>下面的命令可以改回 Emacs 快捷键。</p>
<div><pre><code><span>set</span> -o emacs
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果想永久性更改编辑模式(Emacs / Vi)，可以将命令写在 <code>~/.inputrc</code> 文件，这个文件是 Readline 的配置文件。</p>
<div><pre><code><span>set</span> editing-mode <span>vi</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<div><pre><code><span>bash</span> --noediting
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>--noediting</code> 参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="光标移动" tabindex="-1"> 光标移动</h2>
<p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>: 移到行首。</li>
<li><code>Ctrl + b</code>: 向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>: 移到行尾。</li>
<li><code>Ctrl + f</code>: 向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>: 移动到当前单词的词尾。</li>
<li><code>Alt + b</code>: 移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="清除屏幕" tabindex="-1"> 清除屏幕</h2>
<p><code>Ctrl + l</code> 快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与 <code>clear</code> 命令作用相同。</p>
<h2 id="编辑操作" tabindex="-1"> 编辑操作</h2>
<p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>: 删除光标位置的字符(delete)。</li>
<li><code>Ctrl + w</code>: 删除光标前面的单词。</li>
<li><code>Ctrl + t</code>: 光标位置的字符与它前面一位的字符交换位置(transpose)。</li>
<li><code>Alt + t</code>: 光标位置的词与它前面一位的词交换位置(transpose)。</li>
<li><code>Alt + l</code>: 将光标位置至词尾转为小写(lowercase)。</li>
<li><code>Alt + u</code>: 将光标位置至词尾转为大写(uppercase)。</li>
</ul>
<p>使用 <code>Ctrl + d</code> 的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>: 剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>: 剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>: 剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>: 剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>: 在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="自动补全" tabindex="-1"> 自动补全</h2>
<p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入 <code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为 <code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以 <code>$</code> 开头，则按下 Tab 键会补全变量；如果以 <code>~</code> 开头，则补全用户名；如果以 <code>@</code> 开头，则补全主机名(hostname)，主机名以列在 <code>/etc/hosts</code> 文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab: 完成自动补全。</li>
<li><code>Alt + ?</code>: 列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>: 尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>: 先按 <code>Ctrl + x</code>，再按 <code>/</code>，等同于 <code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>: 命令补全。</li>
<li><code>Ctrl + x !</code>: 先按 <code>Ctrl + x</code>，再按 <code>!</code>，等同于 <code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>: 用户名补全。</li>
<li><code>Ctrl + x ~</code>: 先按 <code>Ctrl + x</code>，再按 <code>~</code>，等同于 <code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>: 变量名补全。</li>
<li><code>Ctrl + x $</code>: 先按 <code>Ctrl + x</code>，再按 <code>$</code>，等同于 <code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>: 主机名补全。</li>
<li><code>Ctrl + x @</code>: 先按 <code>Ctrl + x</code>，再按 <code>@</code>，等同于 <code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>: 在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>: 尝试用 <code>.bash_history</code> 里面以前执行命令，进行补全。</li>
</ul>
<p>上面的 <code>Alt</code> 键也可以用 ESC 键代替。</p>
<h2 id="操作历史" tabindex="-1"> 操作历史</h2>
<h3 id="基本用法" tabindex="-1"> 基本用法</h3>
<p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入 <code>~/.bash_history</code> 文件，该文件默认储存 500 个操作。</p>
<p>环境变量 <code>HISTFILE</code> 总是指向这个文件。</p>
<div><pre><code>$ <span>echo</span> <span>$HISTFILE</span>
/home/me/.bash_history
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>有了操作历史以后，就可以使用方向键的 <code>↑</code> 和 <code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<div><pre><code>$ <span>echo</span> Hello World
Hello World

$ <span>echo</span> Goodbye
Goodbye

$ <span>!</span>e
<span>echo</span> Goodbye
Goodbye
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>!e</code> 表示找出操作历史之中，最近的那一条以 <code>e</code> 开头的命令并执行。Bash 会先输出那一条命令 <code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code> 也会执行最近一条以 <code>echo</code> 开头的命令。</p>
<div><pre><code>$ <span>!</span>echo
<span>echo</span> Goodbye
Goodbye

$ <span>!</span>echo H
<span>echo</span> Goodbye H
Goodbye H

$ <span>!</span>echo H G
<span>echo</span> Goodbye H G
Goodbye H G
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>!string</code> 语法只会匹配命令，不会匹配参数。所以 <code>!echo H</code> 不会执行 <code>echo Hello World</code>，而是会执行 <code>echo Goodbye</code>，并把参数 <code>H</code> 附加在这条命令之后。同理，<code>!echo H G</code> 也是等同于 <code>echo Goodbye</code> 命令之后附加 <code>H G</code>。</p>
<p>最后，按下 <code>Ctrl + r</code> 会显示操作历史，可以用方向键上下移动，选择其中要执行的命令。也可以键入命令的首字母，Shell 就会自动在历史文件中，查询并显示匹配的结果。</p>
<h3 id="history-命令" tabindex="-1"> history 命令</h3>
<p><code>history</code> 命令能显示操作历史，即 <code>.bash_history</code> 文件的内容。</p>
<div><pre><code>$ <span>history</span>
<span>..</span>.
<span>498</span> <span>echo</span> Goodbye
<span>499</span> <span>ls</span> ~
<span>500</span> <span>cd</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>使用该命令，而不是直接读取 <code>.bash_history</code> 文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量 <code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<div><pre><code>$ <span>export</span> <span>HISTTIMEFORMAT</span><span>=</span><span>'%F %T  '</span>
$ <span>history</span>
<span>1</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>cat</span> /etc/issue
<span>2</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>clear</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>%F</code> 相当于 <code>%Y - %m - %d</code>，<code>%T</code> 相当于 <code>%H : %M : %S</code>。</p>
<p>只要设置 <code>HISTTIMEFORMAT</code> 这个环境变量，就会在 <code>.bash_history</code> 文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>如果不希望保存本次操作的历史，可以设置环境变量 <code>HISTSIZE</code> 等于 0。</p>
<div><pre><code><span>export</span> <span><span>HISTSIZE</span></span><span>=</span><span>0</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果 <code>HISTSIZE=0</code> 写入用户主目录的 <code>~/.bashrc</code> 文件，那么就不会保留该用户的操作历史。如果写入 <code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合 <code>grep</code> 命令搜索操作历史。</p>
<div><pre><code><span>history</span> <span>|</span> <span>grep</span> /usr/bin
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令返回 <code>.bash_history</code> 文件里面，那些包含 <code>/usr/bin</code> 的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用 <code>感叹号 + 编号</code> 执行该命令。如果想要执行 <code>.bash_history</code> 里面的第 8 条命令，可以像下面这样操作。</p>
<div><pre><code><span>!</span><span>8</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>history</code> 命令的 <code>-c</code> 参数可以清除操作历史。</p>
<div><pre><code><span>history</span> -c
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="相关快捷键" tabindex="-1"> 相关快捷键</h3>
<p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>: 显示上一个命令，与向上箭头效果相同(previous)。</li>
<li><code>Ctrl + n</code>: 显示下一个命令，与向下箭头效果相同(next)。</li>
<li><code>Alt + &lt;</code>: 显示第一个命令。</li>
<li><code>Alt + &gt;</code>: 显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>: 执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>: 执行上一个命令。</li>
<li><code>!n</code>: 执行历史文件里面行号为 <code>n</code> 的命令。</li>
<li><code>!-n</code>: 执行当前命令之前 <code>n</code> 条的命令。</li>
<li><code>!string</code>: 执行最近一个以指定字符串 <code>string</code> 开头的命令。</li>
<li><code>!?string</code>: 执行最近一条包含字符串 <code>string</code> 的命令。</li>
<li><code>^string1^string2</code>: 执行最近一条包含 <code>string1</code> 的命令，将其替换成 <code>string2</code>。</li>
</ul>
<h2 id="其他快捷键" tabindex="-1"> 其他快捷键</h2>
<ul>
<li><code>Ctrl + j</code>: 等同于回车键(LINEFEED)。</li>
<li><code>Ctrl + m</code>: 等同于回车键(CARRIAGE RETURN)。</li>
<li><code>Ctrl + o</code>: 等同于回车键，并展示操作历史的下一个命令。</li>
<li><code>Ctrl + v</code>: 将下一个输入的特殊字符变成字面量，比如回车变成 <code>^M</code>。</li>
<li><code>Ctrl + [</code>: 等同于 ESC。</li>
<li><code>Alt + .</code>: 插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>: 等同于 <code>Alt + .</code>。</li>
</ul>
<p>上面的 <code>Alt + .</code> 快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<div><pre><code><span>mkdir</span> foo_bar
<span>cd</span> <span>#按下 Alt + .</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，在 <code>cd</code> 命令后按下 <code>Alt + .</code>，就会自动插入 <code>foo_bar</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 脚本入门</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/script.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/script.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 脚本入门</source>
      <description>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。
脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>

<h2 id="shebang-行" tabindex="-1"> Shebang 行</h2>
<p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 <code>#!</code> 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code> 后面就是脚本解释器的位置，Bash 脚本的解释器一般是 <code>/bin/sh</code> 或 <code>/bin/bash</code>。</p>
<div><pre><code><span>#!/bin/sh</span>
<span># 或者</span>
<span>#!/bin/bash</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>#!</code> 与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录 <code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令使用 <code>env</code> 命令(这个命令总是在 <code>/usr/bin</code> 目录)，返回 Bash 可执行文件的位置。<code>env</code> 命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是 <code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<div><pre><code>./script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，<code>script.sh</code> 是脚本文件名。脚本通常使用 <code>.sh</code> 后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<div><pre><code>$ /bin/sh ./script.sh
<span># 或者</span>
$ <span>bash</span> ./script.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="执行权限和路径" tabindex="-1"> 执行权限和路径</h2>
<p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<div><pre><code><span># 给所有用户执行权限</span>
$ <span>chmod</span> +x script.sh

<span># 给所有用户读权限和执行权限</span>
$ <span>chmod</span> +rx script.sh
<span># 或者</span>
$ <span>chmod</span> <span>755</span> script.sh

<span># 只给脚本拥有者读权限和执行权限</span>
$ <span>chmod</span> u+rx script.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>脚本的权限通常设为 <code>755</code> (拥有者有所有权限，其他人有读和执行权限)或者 <code>700</code>(只有拥有者可以执行)。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径(比如 <code>path/script.sh</code>)。如果将脚本放在环境变量 <code>$PATH</code> 指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个 <code>~/bin</code> 子目录，专门存放可执行脚本，然后把 <code>~/bin</code> 加入 <code>$PATH</code>。</p>
<div><pre><code><span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span>:~/bin
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令改变环境变量 <code>$PATH</code>，将 <code>~/bin</code> 添加到 <code>$PATH</code> 的末尾。可以将这一行加到 <code>~/.bashrc</code> 文件里面，然后重新加载一次 <code>.bashrc</code>，这个配置就可以生效了。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<div><pre><code>script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令没有指定脚本路径，因为 <code>script.sh</code> 在 <code>$PATH</code> 指定的目录中。</p>
<h2 id="env-命令" tabindex="-1"> env 命令</h2>
<p><code>env</code> 命令总是指向 <code>/usr/bin/env</code> 文件，或者说，这个二进制文件总是在目录 <code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code> 这个语法的意思是，让 Shell 查找 <code>$PATH</code> 环境变量里面第一个匹配的 <code>NAME</code>。如果您不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code> 的意思就是，返回 <code>bash</code> 可执行文件的位置，前提是 <code>bash</code> 的路径是在 <code>$PATH</code> 里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env node</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>env</code> 命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>: 不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>: 从环境变量中删除一个变量。</li>
<li><code>--help</code>: 显示帮助。</li>
<li><code>--version</code>: 输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<div><pre><code><span>env</span> -i /bin/sh
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="注释" tabindex="-1"> 注释</h2>
<p>Bash 脚本中，<code>#</code> 表示注释，可以放在行首，也可以放在行尾。</p>
<div><pre><code><span># 本行是注释</span>
<span>echo</span> <span>'Hello World!'</span>

<span>echo</span> <span>'Hello World!'</span> <span># 井号后面的部分也是注释</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="脚本参数" tabindex="-1"> 脚本参数</h2>
<p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<div><pre><code>script.sh word1 word2 word3
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，<code>script.sh</code> 是一个脚本文件，<code>word1</code>、<code>word2</code> 和 <code>word3</code> 是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>: 脚本文件名，即 <code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>: 对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>: 参数的总数。</li>
<li><code>$@</code>: 全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 全部的参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>注意，如果命令是 <code>command -o foo bar</code>，那么 <code>-o</code> 是 <code>$1</code>，<code>foo</code> 是 <code>$2</code>，<code>bar</code> 是 <code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># script.sh</span>

<span>echo</span> <span>"全部参数: "</span> <span>$@</span>
<span>echo</span> <span>"命令行参数数量: "</span> <span>$#</span>
<span>echo</span> <span>'$0 = '</span> <span>$0</span>
<span>echo</span> <span>'$1 = '</span> <span>$1</span>
<span>echo</span> <span>'$2 = '</span> <span>$2</span>
<span>echo</span> <span>'$3 = '</span> <span>$3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行结果如下。</p>
<div><pre><code>$ ./script.sh a b c
全部参数: a b c
命令行参数数量: <span>3</span>
<span>$0</span> <span>=</span>  script.sh
<span>$1</span> <span>=</span>  a
<span>$2</span> <span>=</span>  b
<span>$3</span> <span>=</span>  c
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>用户可以输入任意数量的参数，利用 <code>for</code> 循环，可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>$@</code> 返回一个全部参数的列表，然后使用 <code>for</code> 循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<div><pre><code>./script.sh <span>"a b"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，Bash 会认为 <code>&quot;a b&quot;</code> 是一个参数，<code>$1</code> 会返回 <code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift-命令" tabindex="-1"> shift 命令</h2>
<p><code>shift</code> 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数 (<code>$1</code>)，使得后面的参数向前一位，即 <code>$2</code> 变成 <code>$1</code>、<code>$3</code> 变成 <code>$2</code>、<code>$4</code> 变成 <code>$3</code>，以此类推。</p>
<p><code>while</code> 循环结合 <code>shift</code> 命令，也可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"一共输入了 <span>$#</span> 个参数"</span>

<span>while</span> <span>[</span> <span>"<span>$1</span>"</span> <span>!=</span> <span>""</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"剩下 <span>$#</span> 个参数"</span>
  <span>echo</span> <span>"参数: <span>$1</span>"</span>
  <span>shift</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>shift</code> 命令每次移除当前第一个参数，从而通过 <code>while</code> 循环遍历所有参数。</p>
<p><code>shift</code> 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 <code>1</code>。</p>
<div><pre><code><span>shift</span> <span>3</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令移除前三个参数，原来的 <code>$4</code> 变成 <code>$1</code>。</p>
<h2 id="getopts-命令" tabindex="-1"> getopts 命令</h2>
<p><code>getopts</code> 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 <code>while</code> 循环一起使用，取出脚本所有的带有前置连词线 (<code>-</code>) 的参数。</p>
<div><pre><code><span>getopts</span> optstring name
</code></pre><div aria-hidden="true"><div></div></div></div><p>它带有两个参数。第一个参数 <code>optstring</code> 是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数 <code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有 <code>-a</code> 可以带有参数值，而 <code>-l</code> 和 <code>-h</code> 是开关参数，那么 <code>getopts</code> 的第一个参数写成 <code>lha:</code>，顺序不重要。注意，<code>a</code> 后面有一个冒号，表示该参数带有参数值，<code>getopts</code> 规定带有参数值的配置项参数，后面必须带有一个冒号 (<code>:</code>)。<code>getopts</code> 的第二个参数 <code>name</code> 是一个变量名，用来保存当前取到的配置项参数，即 <code>l</code>、<code>h</code> 或 <code>a</code>。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>while</span> <span>getopts</span> <span>'lha:'</span> OPTION<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>$OPTION</span>"</span> <span>in</span>
    l<span>)</span>
      <span>echo</span> <span>"linuxconfig"</span>
      <span>;</span><span>;</span>

    h<span>)</span>
      <span>echo</span> <span>"h stands for h"</span>
      <span>;</span><span>;</span>

    a<span>)</span>
      <span>avalue</span><span>=</span><span>"<span>$OPTARG</span>"</span>
      <span>echo</span> <span>"The value provided is <span>$OPTARG</span>"</span>
      <span>;</span><span>;</span>
    ?<span>)</span>
      <span>echo</span> <span>"script usage: <span><span>$(</span><span>basename</span> $0<span>)</span></span> [-l] [-h] [-a somevalue]"</span> <span>></span><span>&amp;2</span>
      <span>exit</span> <span>1</span>
      <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
<span>shift</span> <span>"<span><span>$((</span>$OPTIND <span>-</span> <span>1</span><span>))</span></span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>while</code> 循环不断执行 <code>getopts 'lha:' OPTION</code> 命令，每次执行就会读取一个连词线参数(以及对应的参数值)，然后进入循环体。变量 <code>OPTION</code> 保存的是，当前处理的那一个连词线参数(即 <code>l</code>、<code>h</code> 或 <code>a</code>)。如果用户输入了没有指定的参数(比如 <code>-x</code>)，那么 <code>OPTION</code> 等于 <code>?</code>。循环体内使用 <code>case</code> 判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如 <code>-a foo</code>，那么处理 <code>a</code> 参数的时候，环境变量 <code>$OPTARG</code> 保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code> 就会执行失败，从而退出 <code>while</code> 循环。比如，<code>getopts</code> 可以解析 <code>command -l foo</code>，但不可以解析 <code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如 <code>command -lh</code>，<code>getopts</code> 也可以正确处理。</p>
<p>变量 <code>$OPTIND</code> 在 <code>getopts</code> 开始执行前是 <code>1</code>，然后每次执行就会加 <code>1</code>。等到退出 <code>while</code> 循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code> 就是已经处理的连词线参数个数，使用 <code>shift</code> 命令将这些参数移除，保证后面的代码可以用 <code>$1</code>、<code>$2</code> 等处理命令的主参数。</p>
<h2 id="配置项参数终止符" tabindex="-1"> 配置项参数终止符 <code>--</code></h2>
<p>变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符 <code>--</code>。</p>
<div><pre><code><span>myPath</span><span>=</span><span>"~/docs"</span>
<span>ls</span> -- <span>$myPath</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>--</code> 强制变量 <code>$myPath</code> 只能当作实体参数(即路径名)解释。</p>
<p>如果变量不是路径名，就会报错。</p>
<div><pre><code>$ <span>myPath</span><span>=</span><span>"-l"</span>
$ <span>ls</span> -- <span>$myPath</span>
ls: 无法访问<span>'-l'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>myPath</code> 的值为 <code>-l</code>，不是路径。但是，<code>--</code> 强制 <code>$myPath</code> 只能作为路径解释，导致报错“不存在该路径”。</p>
<h2 id="exit-命令" tabindex="-1"> exit 命令</h2>
<p><code>exit</code> 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<div><pre><code><span>exit</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code> 命令后面可以跟参数，该参数就是退出状态。</p>
<div><pre><code><span># 退出值为0(成功)</span>
$ <span>exit</span> <span>0</span>

<span># 退出值为1(失败)</span>
$ <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code> 表示正常，<code>1</code> 表示发生错误，<code>2</code> 表示用法不对，<code>126</code> 表示不是可执行脚本，<code>127</code> 表示命令没有发现。如果脚本被信号 <code>N</code> 终止，则退出值为 <code>128 + N</code>。简单来说，只要退出值非 0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>if</span> <span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> <span>!=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"根用户才能执行当前脚本"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>id -u</code> 命令返回用户的 ID，一旦用户的 ID 不等于 <code>0</code>(根用户的 ID)，脚本就会退出，并且退出码为 <code>1</code>，表示运行失败。</p>
<p><code>exit</code> 与 <code>return</code> 命令的差别是，<code>return</code> 命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code> 是整个脚本的退出，如果在函数之中调用 <code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="命令执行结果" tabindex="-1"> 命令执行结果</h2>
<p>命令执行结束后，会有一个返回值。<code>0</code> 表示执行成功，非 <code>0</code> (通常是 <code>1</code>)表示执行失败。环境变量 <code>$?</code> 可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<div><pre><code><span>cd</span> <span>$some_directory</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"无法切换目录!"</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>cd $some_directory</code> 这个命令如果执行成功(返回值等于 <code>0</code>)，就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为 <code>1</code>，表示执行失败。</p>
<p>由于 <code>if</code> 可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<div><pre><code><span>if</span> <span>cd</span> <span>$some_directory</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"Could not change directory! Aborting."</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>更简洁的写法是利用两个逻辑运算符 <code>&amp;&amp;</code>(且)和 <code>||</code>(或)。</p>
<div><pre><code><span># 第一步执行成功，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 第一步执行失败，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="source-命令" tabindex="-1"> source 命令</h2>
<p><code>source</code> 命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<div><pre><code><span>source</span> .bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>source</code> 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code> 命令执行脚本时，不需要 <code>export</code> 变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>
<span>echo</span> <span>$foo</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面脚本输出 <code>$foo</code> 变量的值。</p>
<div><pre><code><span># 当前 Shell 新建一个变量 foo</span>
$ <span>foo</span><span>=</span><span>1</span>

<span># 打印输出 1</span>
$ <span>source</span> test.sh
<span>1</span>

<span># 打印输出空字符串</span>
$ <span>bash</span> test.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，当前 Shell 的变量 <code>foo</code> 并没有 <code>export</code>，所以直接执行无法读取，但是 <code>source</code> 执行可以读取。</p>
<p><code>source</code> 命令的另一个用途，是在脚本内部加载外部库。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>source</span> ./lib.sh

function_from_lib
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本在内部使用 <code>source</code> 命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code> 有一个简写形式，可以使用一个点 (<code>.</code>) 来表示。</p>
<div><pre><code><span>.</span> .bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="别名-alias-命令" tabindex="-1"> 别名，alias 命令</h2>
<p><code>alias</code> 命令用来为一个命令指定别名，这样更便于记忆。下面是 <code>alias</code> 的格式。</p>
<div><pre><code><span>alias</span> <span>NAME</span><span>=</span>DEFINITION
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>NAME</code> 是别名的名称，<code>DEFINITION</code> 是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为 <code>grep</code> 命令起一个 <code>search</code> 的别名。</p>
<div><pre><code><span>alias</span> <span>search</span><span>=</span>grep
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>alias</code> 也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个 <code>today</code> 的命令。</p>
<div><pre><code>$ <span>alias</span> <span>today</span><span>=</span><span>'date +"%A, %B %-d, %Y"'</span>
$ today
星期一, 一月 <span>6</span>, <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>有时为了防止误删除文件，可以指定 <code>rm</code> 命令的别名。</p>
<div><pre><code><span>alias</span> <span>rm</span><span>=</span><span>'rm -i'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令指定 <code>rm</code> 命令是 <code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code> 定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<div><pre><code>$ <span>alias</span> <span>echo</span><span>=</span><span>'echo It says: '</span>
$ <span>echo</span> hello world
It says: hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，别名定义了 <code>echo</code> 命令的前两个参数，等同于修改了 <code>echo</code> 命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在 <code>~/.bashrc</code> 的末尾。另外，只能为命令定义别名，为其他部分(比如很长的路径)定义别名是无效的。</p>
<p>直接调用 <code>alias</code> 命令，可以显示所有别名。</p>
<div><pre><code><span>alias</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>unalias</code> 命令可以解除别名。</p>
<div><pre><code><span>unalias</span> lt
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options" target="_blank" rel="noopener noreferrer">How to use getopts to parse a script options</a>, Egidio Docile</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>set 命令</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/set.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/set.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">set 命令</source>
      <description>set 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 set 的基本用法，帮助您写出更安全的 Bash 脚本。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<div><pre><code><span>bash</span> script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，<code>script.sh</code> 是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code> 命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">官方手册</a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行 <code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<div><pre><code><span>set</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-u" tabindex="-1"> set -u</h2>
<p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>$a</code> 是一个不存在的变量。执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh

bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 <code>$a</code>，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code> 就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -u

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>运行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code> 还有另一种写法 <code>-o nounset</code>，两者是等价的。</p>
<div><pre><code><span>set</span> -o nounset
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-x" tabindex="-1"> set -x</h2>
<p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -x

<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
+ <span>echo</span> bar
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，执行 <code>echo bar</code> 之前，该命令会先打印出来，行首以 <code>+</code> 表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code> 还有另一种写法 <code>-o xtrace</code>。</p>
<div><pre><code><span>set</span> -o xtrace
</code></pre><div aria-hidden="true"><div></div></div></div><p>脚本当中如果要关闭命令输出，可以使用 <code>set +x</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>1</span>

<span>set</span> -x
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number equals 1"</span>
<span>else</span>
  <span>echo</span> <span>"Number does not equal 1"</span>
<span>fi</span>
<span>set</span> +x
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="bash-的错误处理" tabindex="-1"> Bash 的错误处理</h2>
<p>如果脚本里面有运行失败的命令(返回值非 <code>0</code>)，Bash 默认会继续执行后面的命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

foo
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面脚本中，<code>foo</code> 是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行3: foo: 未找到命令
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<div><pre><code><span>command</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的写法表示只要 <code>command</code> 有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<div><pre><code><span># 写法一</span>
<span>command</span> <span>||</span> <span>{</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>}</span>

<span># 写法二</span>
<span>if</span> <span>!</span> <span>command</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>

<span># 写法三</span>
<span>command</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-e" tabindex="-1"> set -e</h2>
<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行4: foo: 未找到命令
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>可以看到，第 4 行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code> 根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭 <code>set -e</code>，该命令执行结束后，再重新打开 <code>set -e</code>。</p>
<div><pre><code><span>set</span> +e
command1
command2
<span>set</span> -e
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>set +e</code> 表示关闭 <code>-e</code> 选项，<code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p>
<p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>set</span> -e

foo <span>||</span> <span>true</span>
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>true</code> 使得这一行语句总是会执行成功，后面的 <code>echo bar</code> 会执行。</p>
<p><code>-e</code> 还有另一种写法 <code>-o errexit</code>。</p>
<div><pre><code><span>set</span> -o errexit
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-o-pipefail" tabindex="-1"> set -o pipefail</h2>
<p><code>set -e</code> 有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符 (<code>|</code>) 组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p>
<p>请看下面这个例子。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>foo</code> 是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p>
<p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -eo pipefail

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>运行后，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，<code>echo bar</code> 没有执行。</p>
<h2 id="其他参数" tabindex="-1"> 其他参数</h2>
<p><code>set</code> 命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>: 等同于 <code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>: 等同于 <code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>: 等同于 <code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
</ul>
<p>上面的 <code>-f</code> 和 <code>-v</code> 参数，可以分别使用 <code>set +f</code>、<code>set +v</code> 关闭。</p>
<h2 id="set-命令总结" tabindex="-1"> set 命令总结</h2>
<p>上面重点介绍的 <code>set</code> 命令的四个参数，一般都放在一起使用。</p>
<div><pre><code><span># 写法一</span>
<span>set</span> -euxo pipefail

<span># 写法二</span>
<span>set</span> -eux
<span>set</span> -o pipefail
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<div><pre><code><span>bash</span> -euxo pipefail script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="shopt-命令" tabindex="-1"> shopt 命令</h2>
<p><code>shopt</code> 命令用来调整 Shell 的参数，跟 <code>set</code> 命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code> 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 <code>shopt</code> 是 Bash 特有的。</p>
<p>直接输入 <code>shopt</code> 可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<div><pre><code><span>shopt</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>shopt</code> 命令后面跟着参数名，可以查询该参数是否打开。</p>
<div><pre><code>$ <span>shopt</span> globstar
globstar  off
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子表示 <code>globstar</code> 参数默认是关闭的。</p>
<ol>
<li>
<p><strong><code>-s</code></strong></p>
<p><code>-s</code> 用来打开某个参数。</p>
<div><pre><code><span>shopt</span> -s optionNameHere
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong><code>-u</code></strong></p>
<p><code>-u</code> 用来关闭某个参数。</p>
<div><pre><code><span>shopt</span> -u optionNameHere
</code></pre><div aria-hidden="true"><div></div></div></div><p>举例来说，<code>histappend</code> 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<div><pre><code><span>shopt</span> -u histappend
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong><code>-q</code></strong></p>
<p><code>-q</code> 的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态 (<code>$?</code>) 表示查询结果。如果状态为 <code>0</code>，表示该参数打开；如果为 <code>1</code>，表示该参数关闭。</p>
<div><pre><code>$ <span>shopt</span> -q globstar
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令查询 <code>globstar</code> 参数是否打开。返回状态为 <code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供 <code>if</code> 条件结构使用。</p>
<div><pre><code><span>if</span> <span>shopt</span> -q globstar<span>;</span> <span>then</span>
  <span>..</span>.
<span>if</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
</ol>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">The Set built-in</a></li>
<li><a href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/" target="_blank" rel="noopener noreferrer">Safer bash scripts with 'set -euxo pipefail’</a></li>
<li><a href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/" target="_blank" rel="noopener noreferrer">Writing Robust Bash Shell Scripts</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录堆栈</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/stack.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/stack.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">目录堆栈</source>
      <description>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>

<h2 id="cd" tabindex="-1"> cd -</h2>
<p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code> 命令可以返回前一次的目录。</p>
<div><pre><code><span># 当前目录是 /path/to/foo</span>
$ <span>cd</span> bar

<span># 重新回到 /path/to/foo</span>
$ <span>cd</span> -
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，用户原来所在的目录是 <code>/path/to/foo</code>，进入子目录 <code>bar</code> 以后，使用 <code>cd -</code> 可以回到原来的目录。</p>
<h2 id="pushd-popd" tabindex="-1"> pushd，popd</h2>
<p>如果希望记忆多重目录，可以使用 <code>pushd</code> 命令和 <code>popd</code> 命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code> 命令的用法类似 <code>cd</code> 命令，可以进入指定的目录。</p>
<div><pre><code><span>pushd</span> <span>dirname</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令会进入目录 <code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用 <code>pushd</code> 命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用 <code>pushd</code> 命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code> 命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录(即原来的第二条目录)。</p>
<p>下面是一个例子。</p>
<div><pre><code><span># 当前处在主目录，堆栈为空</span>
$ <span>pwd</span>
/home/me

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>pushd</span> ~/foo

<span># 进入 /etc</span>
<span># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span>pushd</span> /etc

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>popd</span>

<span># 进入 /home/me</span>
<span># 当前堆栈为 /home/me</span>
$ <span>popd</span>

<span># 目录不变，当前堆栈为空</span>
$ <span>popd</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这两个命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 的参数表示仅操作堆栈，不改变目录。</p>
<div><pre><code><span>popd</span> -n
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
</li>
<li>
<p><strong>整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录(从 0 开始)，作为操作对象。这时不会切换目录。</p>
<div><pre><code><span># 从栈顶算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> +3

<span># 从栈底算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> -3

<span># 删除从栈顶算起的3号目录(从0开始)</span>
$ <span>popd</span> +3

<span># 删除从栈底算起的3号目录(从0开始)</span>
$ <span>popd</span> -3
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子的整数编号都是从 0 开始计算，<code>popd +0</code> 是删除第一个目录，<code>popd +1</code> 是删除第二个，<code>popd -0</code> 是删除最后一个目录，，<code>popd -1</code> 是删除倒数第二个。</p>
</li>
<li>
<p><strong>目录参数</strong></p>
<p><code>pushd</code> 可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<div><pre><code><span>pushd</span> <span>dir</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>popd</code> 没有这个参数。</p>
</li>
</ol>
<h2 id="dirs-命令" tabindex="-1"> dirs 命令</h2>
<p><code>dirs</code> 命令可以显示目录堆栈的内容，一般用来查看 <code>pushd</code> 和 <code>popd</code> 操作后的结果。</p>
<div><pre><code><span>dirs</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>它有以下参数。</p>
<ul>
<li><code>-c</code>: 清空目录栈。</li>
<li><code>-l</code>: 用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>: 每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>: 每行一个条目，每个条目之前显示位置编号(从 0 开始)。</li>
<li><code>+N</code>: <code>N</code> 为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>: <code>N</code> 为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 启动环境</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/startup.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/startup.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 启动环境</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="session" tabindex="-1"> Session</h2>
<p>用户每次使用 Shell，都会开启一个与 Shell 的 Session(对话)。</p>
<p>Session 有两种类型: 登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="登录-session" tabindex="-1"> 登录 Session</h3>
<p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>: 所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code> 目录里面所有 <code>.sh</code> 文件</li>
<li><code>~/.bash_profile</code>: 用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>: 如果 <code>~/.bash_profile</code> 没找到，则尝试执行这个脚本(C shell 的初始化脚本)。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>: 如果<code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都没找到，则尝试读取这个脚本(Bourne shell 和 Korn shell 的初始化脚本)。</li>
</ul>
<p>Linux 发行版更新的时候，会更新 <code>/etc</code> 里面的文件，比如 <code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在 <code>/etc/profile.d</code> 目录里面新建 <code>.sh</code> 脚本。</p>
<p>如果想修改您个人的登录环境，一般是写在 <code>~/.bash_profile</code> 里面。下面是一个典型的 <code>.bash_profile</code> 文件。</p>
<div><pre><code><span># .bash_profile</span>
<span><span>PATH</span></span><span>=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$HOME</span>/bin

<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>MANPATH</span><span>=</span>/usr/man:/usr/X11/man
<span>EDITOR</span><span>=</span>/usr/bin/vi
<span><span>PS1</span></span><span>=</span><span>'\h:\w\$ '</span>
<span><span>PS2</span></span><span>=</span><span>'> '</span>

<span>if</span> <span>[</span> -f ~/.bashrc <span>]</span><span>;</span> <span>then</span>
<span>.</span> ~/.bashrc
<span>fi</span>

<span>export</span> <span>PATH</span>
<span>export</span> EDITOR
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了 <code>~/.bashrc</code>。</p>
<p><code>bash</code> 命令的 <code>--login</code> 参数，会强制执行登录 Session 会执行的脚本。</p>
<div><pre><code><span>bash</span> --login
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>bash</code> 命令的 <code>--noprofile</code> 参数，会跳过上面这些 Profile 脚本。</p>
<div><pre><code><span>bash</span> --noprofile
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="非登录-session" tabindex="-1"> 非登录 Session</h3>
<p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行 <code>bash</code> 命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>: 对全体用户有效。</li>
<li><code>~/.bashrc</code>: 仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code> 通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以 <code>~/.bashrc</code> 也是每次执行脚本都会执行的。</p>
<p><code>bash</code> 命令的 <code>--norc</code> 参数，可以禁止在非登录 Session 执行 <code>~/.bashrc</code> 脚本。</p>
<div><pre><code><span>bash</span> --norc
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>bash</code> 命令的 <code>--rcfile</code> 参数，指定另一个脚本代替 <code>.bashrc</code>。</p>
<div><pre><code><span>bash</span> --rcfile testrc
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="bash-logout" tabindex="-1"> .bash_logout</h3>
<p><code>~/.bash_logout</code> 脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="启动选项" tabindex="-1"> 启动选项</h2>
<p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>: 不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>: 输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>: 每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li>
</ul>
<div><pre><code><span>bash</span> -n scriptname
<span>bash</span> -v scriptname
<span>bash</span> -x scriptname
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="键盘绑定" tabindex="-1"> 键盘绑定</h2>
<p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为 <code>/etc/inputrc</code>，您可以在主目录创建自己的键盘绑定文件 <code>.inputrc</code> 文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<div><pre><code><span>$include</span> /etc/inputrc
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>.inputrc</code> 文件里面的快捷键，可以像这样定义，<code>&quot;\C-t&quot;:&quot;pwd\n&quot;</code> 表示将 <code>Ctrl + t</code> 绑定为运行 <code>pwd</code> 命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>字符串操作</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/string.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/string.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">字符串操作</source>
      <description>本章介绍 Bash 字符串操作的语法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>

<h2 id="字符串的长度" tabindex="-1"> 字符串的长度</h2>
<p>获取字符串长度的语法如下。</p>
<div><pre><code><span>${<span>#</span>varname}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name
$ <span>echo</span> <span>${<span>#</span>myPath}</span>
<span>29</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>大括号 <code>{}</code> 是必需的，否则 Bash 会将 <code>$#</code> 理解成脚本的参数个数，将变量名理解成文本。</p>
<div><pre><code>$ <span>echo</span> <span>$#</span>myvar
0myvar
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，Bash 将 <code>$#</code> 和 <code>myvar</code> 分开解释了。</p>
<h2 id="子字符串" tabindex="-1"> 子字符串</h2>
<p>字符串提取子串的语法如下。</p>
<div><pre><code><span>${varname<span>:</span>offset<span>:</span>length}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是返回变量 <code>$varname</code> 的子字符串，从位置 <code>offset</code> 开始(从 <code>0</code> 开始计算)，长度为 <code>length</code>。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4<span>:</span>4}</span>
foot
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子返回字符串 <code>frogfootman</code> 从 4 号位置开始的长度为 4 的子字符串 <code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span>${"hello"<span>:</span>2<span>:</span>3}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 不是变量名，导致 Bash 报错。</p>
<p>如果省略 <code>length</code>，则从位置 <code>offset</code> 开始，一直返回到字符串的结尾。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4}</span>
footman
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子是返回变量 <code>count</code> 从 4 号位置一直到结尾的子字符串。</p>
<p>如果 <code>offset</code> 为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与 <code>${variable:-word}</code> 的变量的设置默认值语法混淆。这时，如果还指定 <code>length</code>，则 <code>length</code> 不能小于零。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>"This string is long."</span>
$ <span>echo</span> <span>${foo<span>:</span> -5}</span>
long.
$ <span>echo</span> <span>${foo<span>:</span> -5<span>:</span>2}</span>
lo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>offset</code> 为 <code>-5</code>，表示从倒数第 5 个字符开始截取，所以返回 <code>long.</code>。如果指定长度为 <code>2</code>，则返回 <code>lo</code>。</p>
<h2 id="搜索和替换" tabindex="-1"> 搜索和替换</h2>
<p>Bash 提供字符串搜索和替换的多种方法。</p>
<h3 id="字符串头部的模式匹配" tabindex="-1"> 字符串头部的模式匹配</h3>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>#</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>##</span>pattern}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面两种语法会删除变量字符串开头的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<p>匹配模式 <code>pattern</code> 可以使用 <code>*</code>、<code>?</code>、<code>[]</code> 等通配符。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>#</span><span>/</span>*<span>/</span>}</span>
cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>##</span><span>/</span>*<span>/</span>}</span>
long.file.name
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，匹配的模式是 <code>/*/</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>/home/</code>，最长匹配是 <code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>##</span>*<span>/</span>}</span>
long.file.name
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，模式 <code>*/</code> 匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>*-}</span>
<span>456</span>-1414
$ <span>echo</span> <span>${phone<span>##</span>*-}</span>
<span>1414</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>444}</span>
<span>555</span>-456-1414
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，原始字符串里面无法匹配模式 <code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>#</span>JPG<span>/</span>jpg}</span>
jpg.JPG
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串头部，所以返回 <code>jpg.JPG</code>。</p>
<h3 id="字符串尾部的模式匹配" tabindex="-1"> 字符串尾部的模式匹配</h3>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%%</span>pattern}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面两种语法会删除变量字符串结尾的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span>.*}</span>
/home/cam/book/long.file

$ <span>echo</span> <span>${path<span>%%</span>.*}</span>
/home/cam/book/long
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，匹配模式是 <code>.*</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>.name</code>，最长匹配是 <code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span><span>/</span>*}</span>
/home/cam/book
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，模式 <code>/*</code> 匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<div><pre><code>$ <span>file</span><span>=</span>foo.png
$ <span>echo</span> <span>${file<span>%</span>.png}</span>.jpg
foo.jpg
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的例子将文件的后缀名，从 <code>.png</code> 改成了 <code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>%</span>-*}</span>
<span>555</span>-456
$ <span>echo</span> <span>${phone<span>%%</span>-*}</span>
<span>555</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>%</span>JPG<span>/</span>jpg}</span>
JPG.jpg
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串尾部，所以返回 <code>JPG.jpg</code>。</p>
<h3 id="任意位置的模式匹配" tabindex="-1"> 任意位置的模式匹配</h3>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，但仅替换第一个匹配</span>
<span>${variable<span>/</span>pattern<span>/</span>string}</span>

<span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，所有匹配都替换</span>
<span>${variable<span>/</span><span>/</span>pattern<span>/</span>string}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面两种语法都是最长匹配(贪婪匹配)下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/foo.name

$ <span>echo</span> <span>${path<span>/</span><span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/bar.name
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，前一个命令只替换了第一个 <code>foo</code>，后一个命令将两个 <code>foo</code> 都替换了。</p>
<p>下面的例子将分隔符从 <code>:</code> 换成换行符。</p>
<div><pre><code>$ <span>echo</span> -e <span>${<span>PATH</span><span>/</span><span>/</span><span>:</span><span>/</span>'\n'}</span>
/usr/local/bin
/usr/bin
/bin
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 命令的 <code>-e</code> 参数，表示将替换后的字符串的 <code>\n</code> 字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>/</span>5?4<span>/</span>-}</span>
<span>55</span>-56-1414
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的例子将 <code>5-4</code> 替换成 <code>-</code>。</p>
<p>如果省略了 <code>string</code> 部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>.*<span>/</span>}</span>
/home/cam/foo/foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，第二个斜杠后面的 <code>string</code> 部分省略了，所以模式 <code>.*</code> 匹配的部分 <code>.name</code> 被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="改变大小写" tabindex="-1"> 改变大小写</h2>
<p>下面的语法可以改变变量的大小写。</p>
<div><pre><code><span># 转为大写</span>
<span>${varname<span>^^</span>}</span>

<span># 转为小写</span>
<span>${varname<span>,,</span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span>heLLo
$ <span>echo</span> <span>${foo<span>^^</span>}</span>
HELLO
$ <span>echo</span> <span>${foo<span>,,</span>}</span>
hello
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Bash 变量</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/bash/variable.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/bash/variable.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Bash 变量</source>
      <description>Bash 变量分成环境变量和自定义变量两类。
</description>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 变量分成环境变量和自定义变量两类。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code> 命令或 <code>printenv</code> 命令，可以显示所有环境变量。</p>
<div><pre><code>$ <span>env</span>
<span># 或者</span>
$ <span>printenv</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面是一些常见的环境变量。</p>
<ul>
<li><code>BASHPID</code>: Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>: 当前 Shell 的参数，可以用 <code>shopt</code> 命令修改。</li>
<li><code>DISPLAY</code>: 图形环境的显示器名字，通常是 <code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>: 默认的文本编辑器。</li>
<li><code>HOME</code>: 用户的主目录。</li>
<li><code>HOST</code>: 当前主机的名称。</li>
<li><code>IFS</code>: 词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>: 字符集以及语言编码，比如 <code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>: 由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>: Shell 提示符。</li>
<li><code>PS2</code>: 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>: 当前工作目录。</li>
<li><code>RANDOM</code>: 返回一个 0 到 32767 之间的随机数。</li>
<li><code>SHELL</code>: Shell 的名字。</li>
<li><code>SHELLOPTS</code>: 启动当前 Shell 的 <code>set</code> 命令的参数，参见《set 命令》一章。</li>
<li><code>TERM</code>: 终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>: 当前用户的 ID 编号。</li>
<li><code>USER</code>: 当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<p>注意，Bash 变量名区分大小写，<code>HOME</code> 和 <code>home</code> 是两个不同的变量。</p>
<p>查看单个环境变量的值，可以使用 <code>printenv</code> 命令或 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>printenv</span> <span>PATH</span>
<span># 或者</span>
$ <span>echo</span> <span>$PATH</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>注意，<code>printenv</code> 命令后面的变量名，不用加前缀 <code>$</code>。</p>
<p>自定义变量是用户在当前 Shell 里面自己定义的变量，必须先定义后使用，而且仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code> 命令可以显示所有变量(包括环境变量和自定义变量)，以及所有的 Bash 函数。</p>
<div><pre><code><span>set</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="创建变量" tabindex="-1"> 创建变量</h2>
<p>用户创建变量的时候，变量名必须遵守下面的规则。</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不允许出现空格和标点符号。</li>
</ul>
<p>变量声明的语法如下。</p>
<div><pre><code><span>variable</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<div><pre><code><span>myvar</span><span>=</span><span>"hello world"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<div><pre><code><span>a</span><span>=</span>z                     <span># 变量 a 赋值为字符串 z</span>
<span>b</span><span>=</span><span>"a string"</span>            <span># 变量值包含空格，就必须放在引号里面</span>
<span>c</span><span>=</span><span>"a string and <span>$b</span>"</span>     <span># 变量值可以引用其他变量的值</span>
<span>d</span><span>=</span><span>"<span title="\t">\t</span><span title="\t">\t</span>a string<span title="\n">\n</span>"</span>      <span># 变量值可以使用转义字符</span>
<span>e</span><span>=</span><span><span>$(</span><span>ls</span> -l foo.txt<span>)</span></span>      <span># 变量值可以是命令的执行结果</span>
<span>f</span><span>=</span><span><span>$((</span><span>5</span> <span>*</span> <span>7</span><span>))</span></span>            <span># 变量值可以是数学运算的结果</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
$ <span>echo</span> <span>$foo</span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>foo</code> 的第二次赋值会覆盖第一次赋值。</p>
<h2 id="读取变量" tabindex="-1"> 读取变量</h2>
<p>读取变量的时候，直接在变量名前加上 <code>$</code> 就可以了。</p>
<div><pre><code>$ <span>foo</span><span>=</span>bar
$ <span>echo</span> <span>$foo</span>
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>每当 Shell 看到以 <code>$</code> 开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于 <code>$</code> 在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<div><pre><code>$ <span>echo</span> The total is <span>$100</span>.00
The total is 00.00
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令的原意是输入 <code>$100</code>，但是 Bash 将 <code>$1</code> 解释成了变量，该变量为空，因此输入就变成了 <code>00.00</code>。所以，如果要使用 <code>$</code> 的原义，需要在 <code>$</code> 前面放上反斜杠，进行转义。</p>
<div><pre><code>$ <span>echo</span> The total is <span>\</span><span>$100</span>.00
The total is <span>$100</span>.00
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>读取变量的时候，变量名也可以使用花括号 <code>{}</code> 包围，比如 <code>$a</code> 也可以写成 <code>${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<div><pre><code>$ <span>a</span><span>=</span>foo
$ <span>echo</span> <span>$a_file</span>

$ <span>echo</span> <span>${a}</span>_file
foo_file
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，变量名 <code>a_file</code> 不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分 <code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法 <code>$foo</code>，可以看作是 <code>${foo}</code> 的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用 <code>${!varname}</code> 的语法，读取最终的值。</p>
<div><pre><code>$ <span>myvar</span><span>=</span><span>USER</span>
$ <span>echo</span> <span>${<span>!</span>myvar}</span>
ruanyf
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的例子中，变量 <code>myvar</code> 的值是 <code>USER</code>，<code>${!myvar}</code> 的写法将其展开成最终的值。</p>
<h2 id="删除变量" tabindex="-1"> 删除变量</h2>
<p><code>unset</code> 命令用来删除一个变量。</p>
<div><pre><code><span>unset</span> NAME
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使 <code>unset</code> 命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<div><pre><code><span>foo</span><span>=</span><span>''</span>
<span>foo</span><span>=</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面两种写法，都是删除了变量 <code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h2 id="输出变量-export-命令" tabindex="-1"> 输出变量，export 命令</h2>
<p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 <code>export</code> 命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code> 命令用来向子 Shell 输出变量。</p>
<div><pre><code><span>NAME</span><span>=</span>foo
<span>export</span> NAME
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令输出了变量 <code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<div><pre><code><span>export</span> <span>NAME</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量 <code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<div><pre><code><span># 输出变量 $foo</span>
$ <span>export</span> <span>foo</span><span>=</span>bar

<span># 新建子 Shell</span>
$ <span>bash</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar

<span># 修改继承的变量</span>
$ <span>foo</span><span>=</span>baz

<span># 退出子 Shell</span>
$ <span>exit</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，子 Shell 修改了继承的变量 <code>$foo</code>，对父 Shell 没有影响。</p>
<h2 id="特殊变量" tabindex="-1"> 特殊变量</h2>
<p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<p>(1) <code>$?</code></p>
<p><code>$?</code> 为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是 <code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>
<div><pre><code>$ <span>ls</span> doesnotexist
ls: doesnotexist: No such <span>file</span> or directory

$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>ls</code> 命令查看一个不存在的文件，导致报错。<code>$?</code> 为 1，表示上一个命令执行失败。</p>
<p>(2) <code>$$</code></p>
<p><code>$$</code> 为当前 Shell 的进程 ID。</p>
<div><pre><code>$ <span>echo</span> <span>$$</span>
<span>10662</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这个特殊变量可以用来命名临时文件。</p>
<div><pre><code><span>LOGFILE</span><span>=</span>/tmp/output_log.<span>$$</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>(3) <code>$_</code></p>
<p><code>$_</code> 为上一个命令的最后一个参数。</p>
<div><pre><code>$ <span>grep</span> dictionary /usr/share/dict/words
dictionary

$ <span>echo</span> <span>$_</span>
/usr/share/dict/words
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>(4) <code>$!</code></p>
<p><code>$!</code> 为最近一个后台执行的异步命令的进程 ID。</p>
<div><pre><code>$ firefox <span>&amp;</span>
<span>[</span><span>1</span><span>]</span> <span>11064</span>

$ <span>echo</span> <span>$!</span>
<span>11064</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>firefox</code> 是后台运行的命令，<code>$!</code> 返回该命令的进程 ID。</p>
<p>(5) <code>$0</code></p>
<p><code>$0</code> 为当前 Shell 的名称(在命令行直接执行时)或者脚本名(在脚本中执行时)。</p>
<div><pre><code>$ <span>echo</span> <span>$0</span>
<span>bash</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>$0</code> 返回当前运行的是 Bash。</p>
<p>(6) <code>$-</code></p>
<p><code>$-</code> 为当前 Shell 的启动参数。</p>
<div><pre><code>$ <span>echo</span> $-
himBHs
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>(7) <code>$@</code> 和 <code>$#</code></p>
<p><code>$@</code> 和 <code>$#</code> 表示脚本的参数数量，参见脚本一章。</p>
<h2 id="变量的默认值" tabindex="-1"> 变量的默认值</h2>
<p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<div><pre><code><span>${varname<span>:-</span>word}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则返回 <code>word</code>。它的目的是返回一个默认值，比如 <code>${count:-0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:=</span>word}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则将它设为 <code>word</code>，并且返回 <code>word</code>。它的目的是设置变量的默认值，比如 <code>${count:=0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>，且将 <code>count</code> 设为 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:+</span>word}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量名存在且不为空，则返回 <code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如 <code>${count:+1}</code> 表示变量 <code>count</code> 存在时返回 <code>1</code>(表示 <code>true</code>)，否则返回空值。</p>
<div><pre><code><span>${varname<span>:?</span>message}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则打印出 <code>varname: message</code>，并中断脚本的执行。如果省略了 <code>message</code>，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如 <code>${count:?&quot;undefined!&quot;}</code> 表示变量 <code>count</code> 未定义时就中断执行，抛出错误，返回给定的报错信息 <code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用到数字 <code>1</code> 到 <code>9</code>，表示脚本的参数。</p>
<div><pre><code><span>filename</span><span>=</span><span>${1<span>:?</span>"filename missing."}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码出现在脚本中，<code>1</code> 表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h2 id="declare-命令" tabindex="-1"> declare 命令</h2>
<p><code>declare</code> 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<div><pre><code><span>declare</span> OPTION <span>VARIABLE</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>declare</code> 命令的主要参数(OPTION)如下。</p>
<ul>
<li><code>-a</code>: 声明数组变量。</li>
<li><code>-f</code>: 输出所有函数定义。</li>
<li><code>-F</code>: 输出所有函数名。</li>
<li><code>-i</code>: 声明整数变量。</li>
<li><code>-l</code>: 声明变量为小写字母。</li>
<li><code>-p</code>: 查看变量信息。</li>
<li><code>-r</code>: 声明只读变量。</li>
<li><code>-u</code>: 声明变量为大写字母。</li>
<li><code>-x</code>: 该变量输出为环境变量。</li>
</ul>
<p><code>declare</code> 命令如果用在函数中，声明的变量只在函数内部有效，等同于 <code>local</code> 命令。</p>
<p>不带任何参数时，<code>declare</code> 命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的 <code>set</code> 命令。</p>
<div><pre><code><span>declare</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>(1) <code>-i</code> 参数</strong></p>
<p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算。</p>
<div><pre><code>$ <span>declare</span> -i <span>val1</span><span>=</span><span>12</span> <span>val2</span><span>=</span><span>5</span>
$ <span>declare</span> -i result
$ <span>result</span><span>=</span>val1*val2
$ <span>echo</span> <span>$result</span>
<span>60</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果变量 <code>result</code> 不声明为整数，<code>val1*val2</code> 会被当作字面量，不会进行整数运算。另外，<code>val1</code> 和 <code>val2</code> 其实不需要声明为整数，因为只要 <code>result</code> 声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<div><pre><code>$ <span>declare</span> -i <span>var</span><span>=</span><span>12</span>
$ <span>var</span><span>=</span>foo
$ <span>echo</span> <span>$var</span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>var</code> 声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出 0，也可能输出的是 3。</p>
<p><strong>(2) <code>-x</code> 参数</strong></p>
<p><code>-x</code> 参数等同于 <code>export</code> 命令，可以输出一个变量为子 Shell 的环境变量。</p>
<div><pre><code>$ <span>declare</span> -x foo
<span># 等同于</span>
$ <span>export</span> foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>(3) <code>-r</code> 参数</strong></p>
<p><code>-r</code> 参数可以声明只读变量，无法改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>declare</span> -r <span>bar</span><span>=</span><span>1</span>

$ <span>bar</span><span>=</span><span>2</span>
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>

$ <span>unset</span> bar
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<p><strong>(4) <code>-u</code> 参数</strong></p>
<p><code>-u</code> 参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<div><pre><code>$ <span>declare</span> -u foo
$ <span>foo</span><span>=</span>upper
$ <span>echo</span> <span>$foo</span>
UPPER
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>(5) <code>-l</code> 参数</strong></p>
<p><code>-l</code> 参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<div><pre><code>$ <span>declare</span> -l bar
$ <span>bar</span><span>=</span>LOWER
$ <span>echo</span> <span>$bar</span>
lower
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>(6) <code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数输出变量信息。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>declare</span> -p foo
<span>declare</span> -- <span>foo</span><span>=</span><span>"hello"</span>
$ <span>declare</span> -p bar
bar: 未找到
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>declare -p</code> 可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declare -p</code> 输出所有变量的信息。</p>
<div><pre><code><span>declare</span> -p
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>(7) <code>-f</code> 参数</strong></p>
<p><code>-f</code> 参数输出当前环境的所有函数，包括它的定义。</p>
<div><pre><code><span>declare</span> -f
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>(8) <code>-F</code> 参数</strong></p>
<p><code>-F</code> 参数输出当前环境的所有函数名，不包含函数定义。</p>
<div><pre><code><span>declare</span> -F
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="readonly-命令" tabindex="-1"> readonly 命令</h2>
<p><code>readonly</code> 命令等同于 <code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>readonly</span> <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
bash: foo: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，更改只读变量 <code>foo</code> 会报错，命令执行失败。</p>
<p><code>readonly</code> 命令有三个参数。</p>
<ul>
<li><code>-f</code>: 声明的变量为函数名。</li>
<li><code>-p</code>: 打印出所有的只读变量。</li>
<li><code>-a</code>: 声明的变量为数组。</li>
</ul>
<h2 id="let-命令" tabindex="-1"> let 命令</h2>
<p><code>let</code> 命令声明变量时，可以直接执行算术表达式。</p>
<div><pre><code>$ <span>let</span> <span>foo</span><span>=</span><span>1</span>+2
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>let</code> 命令可以直接计算 <code>1 + 2</code>。</p>
<p><code>let</code> 命令的参数表达式如果包含空格，就需要使用引号。</p>
<div><pre><code><span>let</span> <span>"foo = 1 + 2"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>let</code> 可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<div><pre><code>$ <span>let</span> <span>"v1 = 1"</span> <span>"v2 = v1++"</span>
$ <span>echo</span> <span>$v1</span>,<span>$v2</span>
<span>2,1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>let</code> 声明了两个变量 <code>v1</code> 和 <code>v2</code>，其中 <code>v2</code> 等于 <code>v1++</code>，表示先返回 <code>v1</code> 的值，然后 <code>v1</code> 自增。</p>
<p>这种语法支持的运算符，参考《Bash 的算术运算》一章。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 命令格式</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 命令格式</source>
      <category>Linux</category>
      <pubDate>Mon, 18 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令补全</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/add.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/add.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">命令补全</source>
      <description>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 cd、mkdir、cp 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。
考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。
</description>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 <code>cd</code>、<code>mkdir</code>、<code>cp</code> 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。</p>
<p>考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>

<p>举个例子，在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> /etc</span></span>
<span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> fs <span>&lt;</span>-- 按一次 Tab 键</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>当按下 Tab 键时，您会发现 Shell 自动将 &quot;fs&quot; 补全成了 &quot;fatab&quot;，这是因为当前 <code>/etc</code> 目录中只有 fstab 是以 &quot;fs&quot; 开头，因此 Shell 可以确定这里想要输入的文件名称为 fstab。</p>
<p>那么，如果当前目录中含有多个以指定字符(或字符串)开头的目录或文件，Shell 还可以成功辨认吗? 答案是否定的，但它会以列表的形式给出所有以指定字符或字符串开头的文件或目录，供用户选择。</p>
<p>例如，还是在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> b <span>&lt;</span>-- 连续按两次 Tab 键</span></span>
<span>bash_completion.d/      blkid/          bonobo-activation/
bashrc                  bluetooth
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，当按一次 Tab 键时，Shell 没有任何反映，原因就是当前目录下以 &quot;b&quot; 为开头的文件或目录有多个(2 个以上)，仅凭一个字符 &quot;b&quot; 无法精准判断出具体指的是哪个文件。而当再一次按下 Tab 键时，Shell 会列表的形式显示给用户当前目录下所有以 &quot;b&quot; 开头的文件或目录。</p>
<p>事实上，Shell 提供的命令行补全功能不仅适用于补全文件名，也同样适用于所有 Linux 命令。举个例子，当输入 <code>ca</code> 并连续按下 2 次 Tab 键时，Shell 会罗列出所有以 &quot;ca&quot; 开头的 Linux 命令，如下所示:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span>ca <span>&lt;</span>--连续按两次 Tab 键</span></span>
<span>cacertdir_rehash    cache_restore       capsh       catchsegv
cache_check         cal                 captoinfo
cache_dump          caller              case
cache_repair        canberra-gtk-play   cat
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，Shell 还有一套被称作通配符的转用符号，这些通配符可以搜索并匹配文件名的一部分，从而大大简化了文件名的输入。</p>
<ul>
<li><code>*</code>: 匹配任意数量的字符。</li>
<li><code>?</code>: 匹配任意一个字符。</li>
<li><code>[]</code>: 匹配括号内的任意一个字符，甚至 <code>[]</code> 中还可以包含用 <code>-</code>(短横线)连接的字符或数字，表示一定范围内的字符或数字。</li>
</ul>
<p>为了学习这些通配符的用法，首先需要建立一个空目录(如 test)，并在该目录中创建一些文件(供测试用)，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span>makdir <span>test</span></span></span>
<span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> <span>test</span></span></span>
<span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>touch</span> apple banana grape grapefruit watermelon</span></span>
<span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>apple banana grape grapefruit watermelon
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>在此基础上，继续执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> a* <span>&lt;</span>--匹配所有以 a 字符开头的文件名</span></span>
<span>apple
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> g*t <span>&lt;</span>--匹配所有以 g 字符开头，以 t 字符结尾的文件名</span></span>
<span>grapefruit
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> *e* <span>&lt;</span>--匹配所有包含 e 字符的文件名</span></span>
<span>apple grape grapefruit watermelon
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> *n* <span>&lt;</span>--匹配所有包含 n 字符的文件名</span></span>
<span>banana watermelon
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>结合以上实例，因为 <code>*</code> 可以匹配任何数量的字符，因此可以一一实现实例中标注的功能。</p>
<p>接下来，列举一下使用 ? 匹配文件名的示例:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> ????e</span></span>
<span>apple grape
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> g???e*</span></span>
<span>grape grapefruit
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>因为 1 个 ? 只能匹配 1 个任意字符，因此该示例中第一个例子表示的是匹配任意包含 5 个字符但以 e 结尾的文件(apple 和 grape)，第二例子表示匹配任何以 g 开头且第 5 个字符为 e 的文件(grape 和 grapefruit)。</p>
<p>最后，列举一些使用括号 <code>[]</code> 匹配文件名的示例:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>abw<span>]</span>*</span></span>
<span>apple banana watermelon
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>agw<span>]</span>*<span>[</span>ne<span>]</span></span></span>
<span>apple grape watermelon
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>此示例中，第一个例子表示匹配任何以 a、b 或 w 开头的文件；第二个例子中表示匹配任何以 a、g、w 开头，以 n 或 e 结尾的文件名。</p>
<p>不仅如此，<code>[]</code> 中还可以通过 -(短横线)表示一定范围内的任意字符(或数字)，例如:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>a-g<span>]</span>*</span></span>
<span>apple banana grape grapefruit
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>其中，<code>[a-g]*</code> 表示匹配以字母 a 到 g 之间任何一个字母开头的文件名。</p>
]]></content:encoded>
    </item>
    <item>
      <title>基本格式</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/command.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/command.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">基本格式</source>
      <category>Linux</category>
      <pubDate>Mon, 18 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="命令提示符" tabindex="-1"> 命令提示符</h2>
<p>登录系统后，第一眼看到的内容是:</p>
<div><pre><code><span>[root@localhost ~]#
</span></code></pre><div aria-hidden="true"><div></div></div></div><p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢?</p>
<ul>
<li><code>[]</code>: 这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>: 显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li><code>@</code>: 分隔符号，没有特殊含义。</li>
<li><code>localhost</code>: 当前系统的简写主机名(完整主机名是 <code>localhost.localdomain</code>)。</li>
<li><code>~</code>: 代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>: 命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 <code>#</code>；如果是普通用户，提示符就是 <code>$</code>。</li>
</ul>
<p>家目录(又称主目录)是什么? Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家:
超级用户的家目录: <code>/root</code>。
普通用户的家目录: <code>/home/用户名</code>。</p>
<p>用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> /usr/local</span></span>
<span>[root@localhost local]#
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录(不显示完整的所在目录 <code>/usr/loca</code>l，只显示最后一个目录 <code>local</code>)。</p>
<h2 id="命令的基本格式" tabindex="-1"> 命令的基本格式</h2>
<p>接下来看看 Linux 命令的基本格式:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>命令<span>[</span>选项<span>]</span><span>[</span>参数<span>]</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>命令格式中的 <code>[]</code> 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 <code>ls</code> 命令来解释一下命令的格式(有关 <code>ls</code> 命令的具体用法，后续章节会详细介绍)。如果按照命令的分类，那么 <code>ls</code> 命令应该属于目录操作命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ol>
<li>
<p>选项的作用</p>
<p>选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。</p>
<p>Linux 的选项又分为短格式选项(<code>-l</code>)和长格式选项(-<code>-all</code>)。短格式选项是英文的简写，用一个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>而长格式选项是英文完整单词，一般用两个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls --all</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 <code>ls</code> 命令的短格式选项 <code>-l</code> 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。</p>
</li>
<li>
<p>参数的作用</p>
<p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l anaconda-ks.cfg</span>
-rw-------.1 root root <span>1207</span> <span>1</span> 月 <span>14</span> <span>18</span>:18 anaconda-ks.cfg
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>但是为什么一开始 <code>ls</code> 命令可以省略参数? 那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这个 <code>ls</code> 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
</li>
</ol>
<p>总结一下: <strong>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>文件夹</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/dir.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/dir.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">文件夹</source>
      <category>Linux</category>
      <pubDate>Mon, 18 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="pwd-命令" tabindex="-1"> pwd 命令</h2>
<p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录(目前的工作目录)搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p>当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢? 可以使用 Linux 系统的 pwd 命令来显示当前目录的绝对路径。</p>
<p>pwd 命令，是 Print Working Directory (打印工作目录)的缩写，功能是显示用户当前所处的工作目录。该命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>pwd</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="cd-命令" tabindex="-1"> cd 命令</h2>
<p>cd 命令，是 Change Directory 的缩写，用来切换工作目录。</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 cd 命令是一个典型的 Shell 内置命令，所以 cd 命令没有执行文件所在路径。</p>
<p>cd 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> <span>[</span>相对路径或绝对路径<span>]</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>除此之外，cd 命令后面可以跟一些特殊符号，表达固定的含义。</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td><code>~&lt;用户名&gt;</code></td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td><code>-</code></td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td><code>.</code></td>
<td>代表当前目录</td>
</tr>
<tr>
<td><code>..</code></td>
<td>代表上级目录</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>在 Linux 系统中，根目录确实存在 <code>.</code>(当前目录)以及 <code>..</code>(当前目录的父目录)两个目录，但由于根目录是最顶级目录，因此根目录的 <code>..</code> 和 <code>.</code> 的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
</div>
<h2 id="ls-命令" tabindex="-1"> ls 命令</h2>
<p>ls 命令，list 的缩写，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span> <span>[</span>选项<span>]</span> 目录名称</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>| 选项                                                | 功能                                                                                                                                              |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| -a                                                  | 显示全部的文件，包括隐藏文件(开头为 <code>.</code> 的文件)也一起罗列出来，这是最常用的选项之一。                                                             |
| -A                                                  | 显示全部的文件，连同隐藏文件，但不包括 <code>.</code> 与 <code>..</code> 这两个目录。                                                                                   |
| -d                                                  | 仅列出目录本身，而不是列出目录内的文件数据。                                                                                                      |
| -f                                                  | ls 默认会以文件名排序，使用 <code>-f</code> 选项会直接列出结果，而不进行排序。                                                                               |
| -F                                                  | 在文件或目录名后加上文件类型的指示符号，例如，<code>*</code> 代表可运行文件，<code>/</code> 代表目录，= 代表 socket 文件，                                              | 代表 FIFO 文件。 |
| -h                                                  | 以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。                                                                                       |
| -i                                                  | 显示 inode 节点信息。                                                                                                                             |
| -l                                                  | 使用长格式列出文件和目录信息。                                                                                                                    |
| -n                                                  | 以 UID 和 GID 分别代替文件用户名和群组名显示出来。                                                                                                |
| -r                                                  | 将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。                                                                                |
| -R                                                  | 连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。                                                                                    |
| -S                                                  | 以文件容量大小排序，而不是以文件名排序。                                                                                                          |
| -t                                                  | 以时间排序，而不是以文件名排序。                                                                                                                  |
| --color=never<br />--color=always<br />--color=auto | <code>never</code> 表示不依据文件特性给予颜色显示。<br /><code>always</code> 表示显示颜色，ls 默认采用这种方式。<br /><code>auto</code> 表示让系统自行依据配置来判断是否给予颜色。 |
| --full-time                                         | 以完整时间模式 (包含年、月、日、时、分)输出                                                                                                       |
| --time={atime,ctime}                                | 输出 access 时间或改变权限属性时间(ctime)，而不是内容变更时间。                                                                                   |</p>
<div><p>提示</p>
<p>当 ls 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色(蓝色显示目录，白色显示一般文件)。</p>
</div>
<div><p>提示</p>
<p>ls 命令使用了 <code>-l</code> 选项，显示出文件的详细信息，此选项显示的这 7 列的含义分别是:</p>
<ul>
<li>第一列: 规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。</li>
<li>第二列: 引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列: 所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列: 所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列: 大小，默认单位是字节。</li>
<li>第六列: 文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列: 文件名或目录名。</li>
</ul>
</div>
<h2 id="mkdir-命令" tabindex="-1"> mkdir 命令</h2>
<p>mkdir 命令，是 make directories 的缩写，用于创建新目录，此命令所有用户都可以使用。</p>
<p>mkdir 命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> <span>[</span>-mp<span>]</span> 目录名</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。</li>
<li>-p 选项递归创建所有目录，以创建 <code>/home/test/demo</code> 为例，在默认情况下，您需要一层一层的创建各个目录，而使用 <code>-p</code> 选项，则系统会自动帮您创建 <code>/home</code>、<code>/home/test</code> 以及 <code>/home/test/demo</code>。</li>
</ul>
<h2 id="rmdir-命令" tabindex="-1"> rmdir 命令</h2>
<p>和 mkdir 命令(创建空目录)恰好相反，rmdir(remove empty directories 的缩写)命令用于删除空目录，此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rmdir</span> <span>[</span>-p<span>]</span> 目录名</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>-p 选项用于递归删除空目录。</p>
<div><p>提示</p>
<p>rmdir 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>命令执行</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/excu.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/excu.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">命令执行</source>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢?</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<ol>
<li>
<p>判断路径</p>
<p>判断用户是否以绝对路径或相对路径的方式输入命令(如 <code>/bin/ls</code>)，如果是的话直接执行。</p>
</li>
<li>
<p>检查别名</p>
<p>Linux 系统会检查用户输入的命令是否为 “别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。</p>
<p>例如，我们经常使用的 <code>rm</code> 命令，其实就是 <code>rm -i</code> 这个整体的别名:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>rm</span></span></span>
<span>alias rm='rm -i'
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> a.txt <span>&lt;</span>-- 假定当前目录中已经存在 a.txt 文件</span></span>
<span>rm: remove regular file 'a.txt'? y  &lt;-- 手动输入 y，即确定删除
[root@localhost ~]#
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这里可以使用 <code>unalias</code> 命令，将 Linux 系统设置的 <code>rm</code> 别名删除掉，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>rm</span></span></span>
<span>alias rm='rm -i'
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>unalias</span> <span>rm</span></span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> a.txt</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span>  <span><span>&lt;</span>--直接删除，不再询问</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>判断是内部命令还是外部命令</p>
<p>Linux 命令行解释器 (又称为 Shell) 会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。</p>
<p>判断一个命令属于内部命令还是外部命令，可以使用 <code>type</code> 命令实现。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>type</span> <span>pwd</span></span></span>
<span>pwd is a shell builtin  &lt;-- pwd是内部命令
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>type</span> <span>top</span></span></span>
<span>top is /usr/bin/top  &lt;-- top是外部命令
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>查找外部命令对应的可执行文件</p>
<p>当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止(如果找不到，Shell 会提供用户“找不到此命令”)。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>文件</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/file.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/file.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">文件</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="touch-命令" tabindex="-1"> touch 命令</h2>
<p>需要注意的是，touch 命令不光可以用来创建文件(当指定操作文件不存在时，该命令会在当前位置建立一个空文件)，此命令更重要的功能是修改文件的时间参数(但当文件存在时，会修改此文件的时间参数)。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间:</p>
<ul>
<li>访问时间 (Access Time，简称 atime): 只要文件的内容被读取，访问时间就会更新。例如，使用 <code>cat</code> 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间 (Modify Time，简称 mtime): 当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间 (Change Time，简称 ctime): 当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
<p>touch 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> <span>[</span>选项<span>]</span> 文件名</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-a: 只修改文件的访问时间；</li>
<li>-c: 仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件。</li>
<li>-d: 后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</li>
<li>-m: 只修改文件的数据修改时间。</li>
<li>-t: 命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。</li>
</ul>
<p>可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变(更新为操作当前文件的真正时间)。</p>
<h2 id="ln-命令" tabindex="-1"> ln 命令</h2>
<p>如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统(Linux 文件系统)是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。</p>
<p>ext4 文件系统会把分区主要分为两大部分(暂时不提超级块): 小部分用于保存文件的 inode (i 节点)信息；剩余的大部分用于保存 block 信息。</p>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限(r、w、x)、文件的所有者和属组、文件的大小、文件的状态改变时间(ctime)、文件的最近一次读取时间(atime)、文件的最近一次修改时间(mtime)、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息:</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ol>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。</p>
<p>ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种:</p>
<ul>
<li>软链接: 类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接: 我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p>ln 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> <span>[</span>选项<span>]</span> 源文件 目标文件</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-s: 建立软链接文件。如果不加 <code>-s</code> 选项，则建立硬链接文件；</li>
<li>-f: 强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<h3 id="ln-扩展介绍" tabindex="-1"> ln 扩展介绍</h3>
<ul>
<li><a href="/linux/command/ln.html">点击前往</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>链接</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/ln.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/ln.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">链接</source>
      <description>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。
</description>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>

<h2 id="ln-创建硬链接" tabindex="-1"> ln 创建硬链接</h2>
<p>我们再来建立一个硬链接文件，然后看看这两个文件的特点。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> <span>test</span></span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> /root/test /tmp/test-hard</span></span>
<span>#给源文件建立硬链接文件 /tmp/test-hard
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i /root/test /tmp/test-hard</span></span>
<span>262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /root/test
hard
262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /tmp/test-hard
#查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，"ll"等同于"ls -l"。
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。</p>
<p>但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢? 我们来画一张示意图，如图 2 所示。</p>
<p><img src="@source/linux/assets/hardlink.jpg" alt="Hardlink"></p>
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。</p>
<p>当我们查找一个文件，比如 <code>/root/test</code> 时，要经过以下步骤:</p>
<ul>
<li>首先找到根目录的 inode(根目录的 inode 是系统已知的，inode 号是 2)，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 <code>/root</code> 的文件名及对应的 inode 号。</li>
<li>通过 <code>/root/</code> 目录的 inode 号，可以查找到 <code>/root/</code> 目录的 inode 信息，接着判断用户是否有权限访问 <code>/root/</code> 目录的 block。</li>
<li>如果有权限，则可以从 <code>/root/</code> 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 <code>/root/test</code> 文件的读取与访问。</li>
</ul>
<p>按照这个步骤，在给源文件 <code>/root/test</code> 建立了硬链接文件 <code>/tmp/test-hard</code> 之后，在 <code>/root/</code> 目录和 <code>/tmp/</code> 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。</p>
<p>这就是硬链接的原理。硬链接的特点如下:</p>
<ul>
<li>不论是修改源文件(test 文件)，还是修改硬链接文件(test-hard 文件)，另一个文件中的数据都会发生改变。</li>
<li>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件(inode 号是 262147 的文件)都可以被访问。</li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统(分区)建立，因为在不同的文件系统中，inode 号是重新计算的。</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p>硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。</p>
<h2 id="ln-创建软链接" tabindex="-1"> ln 创建软链接</h2>
<p>软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> check</span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> -s /root/check /tmp/check-soft</span></span>
<span>#建立软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -id /root/check /tmp/check-soft</span></span>
<span>262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check
917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -> /root/check
#软链接和源文件的 inode 号不一致，软链接通过 -> 明显地标识出源文件的位置
#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再强调一下，软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用。</p>
<p>软链接的标志非常明显，首先，权限位中&quot;l&quot;表示这是一个软链接文件；其次，在文件的后面通过 &quot;-&gt;&quot; 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。</p>
<p>软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。</p>
<p>大家在学习软链接的时候会有一些疑问: Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢?</p>
<p>软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 <code>/etc/rc.local</code> 放置在 <code>/etc</code> 目录中，而有些系统却将其放置在 <code>/etc/rc.d/rc.local</code> 中，那么干脆对这两个文件建立软链接，不论您习惯操作哪一个文件，结果都是一样的。</p>
<p>如果您比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图 3 所示。</p>
<p><img src="@source/linux/assets/softlink.jpg" alt="软链接示意图"></p>
<p>软链接和硬链接在原理上最主要的不同在于: 硬链接不会建立自己的 inode 索引和 block(数据块)，而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
<p>我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。</p>
<ul>
<li>首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限访问根目录的 block，就会在 block 中查找到 <code>/tmp/</code> 目录的 inode 号。</li>
<li>接着访问 <code>/tmp/</code> 目录的 inode 信息，判断用户是否有权限访问 <code>/tmp/</code> 目录的 block。</li>
<li>如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。</li>
<li>通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。</li>
<li>接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。</li>
</ul>
<p>通过这个过程，我们就可以总结出软链接的特点(软链接的特点和 Windows 中的快捷方式完全一致)。</p>
<ul>
<li>不论是修改源文件(check)，还是修改硬链接文件(check-soft)，另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。</li>
<li>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>其他文件命令</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/other.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/other.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">其他文件命令</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="cp-命令" tabindex="-1"> cp 命令</h2>
<p>cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p>
<p>cp 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> <span>[</span>选项<span>]</span> 源文件 目标文件</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-a: 相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；</li>
<li>-d: 如果源文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接；</li>
<li>-i: 询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li>-l: 把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li>-s: 把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li>-p: 复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)；</li>
<li>-r: 递归复制，用于复制目录；</li>
<li>-u: 若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。</p>
<h3 id="cp-命令基本用法" tabindex="-1"> cp 命令基本用法</h3>
<p>cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/</span></span>
<span>#把源文件不改名复制到 /tmp/ 目录下
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>如果需要改名复制，则命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/bols</span></span>
<span>#改名复制
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是 <code>cp -i</code> 的别名，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/</span></span>
<span>cp:是否覆盖"/tmp/cangls"?y
#目标位置有同名文件，所以会提示是否覆盖
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>接下来我们看看如何复制目录，其实复制目录只需使用 <code>-r</code> 选项即可，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> movie</span></span>
<span>#建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -r /root/movie/ /tmp/</span></span>
<span>#目录原名复制
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="复制软链接文件" tabindex="-1"> 复制软链接文件</h3>
<p>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢? 我们试试:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> -s /root/cangls /tmp/cangls_slink</span></span>
<span>#建立一个测试软链接文件/tmp/cangls_slink
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /tmp/cangls_slink</span></span>
<span>lrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -> /root/cangls
#源文件本身就是一个软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> /tmp/cangls_slink /tmp/cangls_t1</span></span>
<span>#复制软链接文件，但是不加"-d"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -d /tmp/cangls_slink /tmp/cangls_t2</span></span>
<span>#复制软链接文件，加入"-d"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /tmp/cangls_t1 /tmp/cangls_t2</span></span>
<span>-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1
#会发现不加"-d"选项，实际复制的是软链接的源文件，而不是软链接文件
lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-> /root/cangls
#而如果加入了"-d"选项，则会复制软链接文件
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个例子说明，如果在复制软链接文件时不使用 <code>-d</code> 选项，则 <code>cp</code> 命令复制的是源文件，而不是软链接文件；只有加入了 <code>-d</code> 选项，才会复制软链接文件。请大家注意，<code>-d</code> 选项对硬链接是无效的。</p>
<h3 id="保留源文件属性复制" tabindex="-1"> 保留源文件属性复制</h3>
<p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> /var/lib/mlocate/mlocate.db /tmp/</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /var/lib/mlocate/mlocate.db</span></span>
<span>-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db
#注意源文件的时间和所属组
[root@localhost ~]#ll /tmp/mlocate.db
-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db
#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 <code>-p</code> 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span>
<span>#使用"-p"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span>
<span>-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2
-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db
#源文件和目标文件的所有属性都一致，包括时间
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们之前讲过，<code>-a</code> 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 <code>-a</code> 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 <code>-a</code> 选项来取代 &quot;-d、-p、-r&quot; 选项更加方便。</p>
<h3 id="l-和-s-选项" tabindex="-1"> &quot;-l&quot; 和 &quot;-s&quot; 选项</h3>
<p>我们如果使用 <code>-l</code> 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 <code>-s</code> 选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和 <code>-d</code> 选项是不同的，<code>d</code> 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 <code>-l</code> 和 <code>-s</code> 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> bols</span></span>
<span>#建立测试文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i bols</span></span>
<span>262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols
#源文件只是一个普通文件，而不是软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -l /root/bols /tmp/bols_h</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -s /root/bols /tmp/bols_s</span></span>
<span>#使用"-l" 和"-s"选项复制
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i /tmp/bols_h /tmp/bols_s</span></span>
<span>262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h
#目标文件 /tmp/bols_h 为源文件的硬链接文件
932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -> /root/bols
#目标文件 /tmp/bols_s 为源文件的软链接文件
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="rm-命令" tabindex="-1"> rm 命令</h2>
<p>当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件(即垃圾)，这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。</p>
<p>rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>rm<span>[</span>选项<span>]</span> 文件或目录</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-f: 强制删除(force)，和 <code>-i</code> 选项相反，使用 <code>-f</code>，系统将不再询问，而是直接删除目标文件或目录。</li>
<li>-i: 和 <code>-f</code> 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 <code>-i</code> 可以有效防止不小心删除有用的文件或目录。</li>
<li>-r: 递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
<div><p>提示</p>
<p>rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。</p>
</div>
<h3 id="基本用法" tabindex="-1"> 基本用法</h3>
<p>rm 命令如果任何选项都不加，则默认执行的是 <code>rm -i 文件名</code>，也就是在删除一个文件之前会先询问是否删除。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> cangls</span></span>
<span>rm:是否删除普通空文件"cangls"?y
#删除前会询问是否删除
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="删除目录" tabindex="-1"> 删除目录</h3>
<p>如果需要删除目录，则需要使用 <code>-r</code> 选项。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> -p /test/lm/movie/jp</span></span>
<span>#递归建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> /test</span></span>
<span>rm:无法删除"/test/": 是一个目录
#如果不加"-r"选项，则会报错
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> -r /test</span></span>
<span>rm:是否进入目录"/test"?y
rm:是否进入目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm/movie/jp"?y
rm:是否删除目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm"?y
rm:是否删除目录"/test"?y
#会分别询问是否进入子目录、是否删除子目录
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难!</p>
<h3 id="强制删除" tabindex="-1"> 强制删除</h3>
<p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> -p /test/lm/movie/jp</span></span>
<span>#重新建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> -rf /test</span></span>
<span>#强制删除，一了百了
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p>
<p>虽然 <code>-rf</code> 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 <code>-rf</code> 选项。</p>
<h2 id="mv-命令" tabindex="-1"> mv 命令</h2>
<p>mv 命令(move 的缩写)，既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> 【选项】 源文件 目标文件</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-f: 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li>-i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认选项)；</li>
<li>-n: 如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li>-v: 显示文件或目录的移动过程；</li>
<li>-u: 若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
<p>需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p>
<h3 id="移动文件或目录" tabindex="-1"> 移动文件或目录</h3>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> cangls /tmp</span></span>
<span>#移动之后，源文件会被删除，类似剪切
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> movie</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> movie/ /tmp</span></span>
<span>#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 "-r" 选项
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 <code>mv -i</code> 的别名，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#重新建立文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> cangls /tmp</span></span>
<span>mv:县否覆盖"tmp/cangls"? y
#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="强制移动" tabindex="-1"> 强制移动</h3>
<p>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p>
<p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 <code>-f</code> 选项进行强制移动，这就不再需要用户手工确认了。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#重新建立文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -f cangls /tmp</span></span>
<span>#就算 /tmp/ 目录下已经存在同名的文件，由于"-f"选项的作用，所以会强制覆盖
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="不覆盖移动" tabindex="-1"> 不覆盖移动</h3>
<p>既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 <code>-n</code> 选项的帮助了。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span> /tmp</span></span>
<span>/tmp/bols /tmp/cangls
#在/tmp/目录下已经存在bols、cangls文件了
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -vn bols cangls lmls /tmp/、</span></span>
<span>"lmls"->"/tmp/lmls"
#再向 /tmp/ 目录中移动同名文件，如果使用了 "-n" 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动("-v" 选项用于显示移动过程)
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="改名" tabindex="-1"> 改名</h3>
<p>如果源文件和目标文件在同一目录中，那就是改名。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> bols lmls</span></span>
<span>#把 bols 改名为 lmls
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>目录也可以按照同样的方法改名。</p>
<h3 id="显示移动过程" tabindex="-1"> 显示移动过程</h3>
<p>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 <code>-v</code> 选项来查看详细的移动信息。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> test1.txt test2.txt test3.txt</span></span>
<span>#建立三个测试文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -v *.txt /tmp</span></span>
<span>"test1.txt" -> "/tmp/test1.txt"
"test2.txt" -> "/tmp/test2.txt"
"test3.txt" -> "/tmp/test3.txt"
#加入"-v"选项，可以看到有哪些文件进行了移
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>环境变量</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/path.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/path.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">环境变量</source>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="环境变量" tabindex="-1"> 环境变量</h1>
<h2 id="变量" tabindex="-1"> 变量</h2>
<p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录 (HOME)、邮件存放位置 (MAIL)等。
值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</p>
<p>我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>env</span></span></span>
<span>ORBIT_SOCKETDIR=/tmp/orbit-root
HOSTNAME=livecd.centos
GIO_LAUNCHED_DESKTOP_FILE_PID=2065
TERM=xterm
SHELL=/bin/bash
......
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Linux 系统能够正常运行并且为用户提供服务，需要数百个环境变量来协同工作，但是，我们没有必要逐一学习每个变量。常见变量见下表:</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录(也称家目录)</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash 解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody>
</table>
<p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。</p>
<p>例如，使用下述命令来查看 <code>HOME</code> 变量在不同用户身份下都有哪些值:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$HOME</span></span></span>
<span>/root
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>su</span> - user1  <span>&lt;</span>--切换到 user1 用户身份</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>echo</span> <span>$HOME</span></span></span>
<span>/home/user1
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的 <code>su</code> 命令可以临时切换用户身份，此命令的具体用法会在后续章节做详细介绍。</p>
<p>其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 <code>WORKDIR</code> 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> /home/work1</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>WORKDIR</span><span>=</span>/home/work1</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>pwd</span></span></span>
<span>/home/work1
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 <code>export</code> 命令将其提升为全局环境变量，这样其他用户就可以使用它了:</p>
<div><pre><code><span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>su</span> user1  <span>&lt;</span>-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>echo</span> <span>$WORKDIR</span></span></span>

<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>exit</span> <span>&lt;</span>--退出user1身份</span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>export</span> WORKDIR</span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>su</span> user1</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[user1@localhost work1]</span></span><span>$</span> <span><span>pwd</span></span></span>
<span>/home/work1
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="path" tabindex="-1"> path</h2>
<p>在讲解 PATH 环境变量之前，首先介绍一下 <code>which</code> 命令，它用于查找某个命令所在的绝对路径。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>rm</span></span></span>
<span>/bin/rm
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>rmdir</span></span></span>
<span>/bin/rmdir
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>ls</span></span></span>
<span>alias ls='ls --color=auto'
        /bin/ls
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>ls</code> 是一个相对特殊的命令，它使用 alias 命令做了别名，也就是说，我们常用的 <code>ls</code> 实际上执行的是 <code>ls --color=auto</code>。</p>
<p>通过使用 <code>which</code> 命令，可以查找各个外部命令(和 Shell 内置命令相对)所在的绝对路径。学到这里，读者是否有这样一个疑问，为什么前面在使用 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置 (绝对路径) 呢? 其实，这是 PATH 环境变量在起作用。</p>
<p>首先，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$PATH</span></span></span>
<span>/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这里的 <code>echo</code> 命令用来输出 PATH 环境变量的值(这里的 <code>$</code> 是 PATH 的前缀符号)，PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号 <code>:</code> 隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。
如果在 PATH 包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。</p>
<p>从执行结果中可以看到，<code>/bin</code> 目录已经包含在 PATH 环境变量中，因此在使用类似 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，即便直接使用其命令名，Linux 也可以找到该命令。</p>
<p>为了印证以上观点，下面举个反例，如果我们将 <code>ls</code> 命令移动到 <code>/root</code> 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 <code>ls</code> 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 <code>No such file or directory</code>，示例命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> /bin/ls /root</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>bash: /bin/ls: No such file or directory
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>此时，如果仍想使用 <code>ls</code> 命令，有 2 种方法，一种是直接将 <code>/root</code> 添加到 PATH 环境变量中，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span><span>PATH</span></span><span>=</span><span>$PATH</span>:/root</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$PATH</span></span></span>
<span>/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，<code>$PATH</code> 就恢复成了默认值。</p>
<p>另一种方法是以绝对路径的方式使用此命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>/root/ls</span></span>
<span>Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>为了不影响系统的正常使用，强烈建议大家将移动后的 <code>ls</code> 文件还原，命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> /root/ls /bin</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>其他指令</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/command/temp.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/command/temp.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">其他指令</source>
      <category>Linux</category>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="其他指令" tabindex="-1"> 其他指令</h1>
<h2 id="文件" tabindex="-1"> 文件</h2>
<h3 id="创建文件" tabindex="-1"> 创建文件</h3>
<ul>
<li>touch</li>
<li>vi</li>
</ul>
<h3 id="编辑文件" tabindex="-1"> 编辑文件</h3>
<ul>
<li>vi</li>
</ul>
<div><p>提示</p>
<p>使用 vi 命令后，默认进入浏览模式。</p>
<p>按 <code>i</code> 进入 insert 模式， 按 <code>ESC</code> 退出。</p>
<ol>
<li>
<p>命令模式下，输入: <code>/</code> 字符串</p>
<p>比如搜索 user, 输入 <code>/user</code></p>
<p>按下回车之后，可以看到 vim 已经把光标移动到该字符处和高亮了匹配的字符串</p>
</li>
<li>
<p>查看下一个匹配，按下 n(小写 n)</p>
</li>
<li>
<p>跳转到上一个匹配，按下 N(大写 N)</p>
</li>
<li>
<p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮?</p>
</li>
</ol>
<p>命令模式下，输入 <code>:nohlsearch</code> 也可以 <code>:set nohlsearch</code>；当然，可以简写，<code>noh</code> 或者 <code>set noh</code>。</p>
</div>
<h3 id="重命名文件" tabindex="-1"> 重命名文件</h3>
<ul>
<li>rename</li>
</ul>
<h3 id="移动文件" tabindex="-1"> 移动文件</h3>
<ul>
<li>mv</li>
</ul>
<div><p>提示</p>
<p>该命令也可用于重命名</p>
</div>
<h3 id="文件浏览" tabindex="-1"> 文件浏览</h3>
<ul>
<li>pwd: 查看当前目录</li>
<li>cd: 移动当前目录</li>
<li>ls: 列出当前目录
<ul>
<li><code>-l</code>: 以表格列出当前目录详情</li>
<li><code>-a</code>: 包括隐藏文件</li>
</ul>
</li>
</ul>
<h2 id="权限" tabindex="-1"> 权限</h2>
<ul>
<li>chmod: 查看/更改文件或文件夹权限</li>
</ul>
<p><code>chmod</code> 是权限管理命令 <code>change the permissions mode of a file</code> 的缩写。</p>
<p><code>u</code> 代表所有者，<code>x</code> 代表执行权限。<code>+</code> 表示增加权限。</p>
<div><pre><code><span>chmod</span> u+x file.sh
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>chmod</span> 权限数字 文件名
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>
<p>r 读权限 read 4</p>
</li>
<li>
<p>w 写权限 write 2</p>
</li>
<li>
<p>x 操作权限 execute 1</p>
</li>
</ul>
<div><pre><code><span>chmod</span> <span>600</span> id_rsa
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="用户组" tabindex="-1"> 用户组</h2>
<h3 id="管理用户组" tabindex="-1"> 管理用户组</h3>
<p>groupadd groupname 　　添加用户组</p>
<p>groupdel groupname 　　删除用户组</p>
<p>##　添加用户到用户组
将一个用户添加到用户组中，千万不能直接用:</p>
<div><pre><code><span>usermod</span> -G groupA
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样做会使您离开其他用户组，仅仅做为 这个用户组 groupA 的成员。</p>
<p>应该用 加上 <code>-a</code> 选项:</p>
<div><pre><code><span>usermod</span> -a -G groupA user
<span>(</span>FC4: <span>usermod</span> -G groupA,groupB,groupC user<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>-a</code> 代表 <code>append</code>， 也就是 将自己添加到 用户组 groupA 中，而不必离开 其他用户组。</p>
<p>命令的所有的选项，及其含义:</p>
<div><pre><code>Options:

-c, –comment COMMENT new value of the GECOS field
-d, –home HOME_DIR new home directory for the user account
-e, –expiredate EXPIRE_DATE set account expiration date to EXPIRE_DATE
-f, –inactive INACTIVE set password inactive after expiration
to INACTIVE
-g, –gid GROUP force use GROUP as new primary group
-G, –groups GROUPS new list of supplementary GROUPS
-a, –append append the user to the supplemental GROUPS
mentioned by the -G option without removing
him/her from other groups
-h, –help display this help message and exit
-l, –login NEW_LOGIN new value of the login name
-L, –lock lock the user account
-m, –move-home move contents of the home directory to the new
location (use only with -d)
-o, –non-unique allow using duplicate (non-unique) UID
-p, –password PASSWORD use encrypted password for the new password
-s, –shell SHELL new login shell for the user account
-u, –uid UID new UID for the user account
-U, –unlock unlock the user account
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>查看用户所属的组使用命令:</p>
<div><pre><code><span>groups</span> user
</code></pre><div aria-hidden="true"><div></div></div></div><p>或者查看文件:</p>
<div><pre><code><span>cat</span> /etc/group
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="用户" tabindex="-1"> 用户</h2>
<p><code>cat /etc/passwd</code> 查看用户列表</p>
<h3 id="添加用户" tabindex="-1"> 添加用户</h3>
<div><pre><code><span>sudo</span> <span>useradd</span> <span>[</span>用户名<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>创建新用户: useradd</p>
<p><code>-d</code> 指定目录文件夹</p>
<p><code>-m</code> 新账号名</p>
<p>如:</p>
<div><pre><code><span>useradd</span> -d /www/abc -m abc
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li><code>-c</code>: comment 指定一段注释性描述。</li>
<li><code>-d</code>: 目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。</li>
<li><code>-g</code>: 用户组 指定用户所属的用户组。</li>
<li><code>-G</code>: 用户组，用户组 指定用户所属的附加组。</li>
<li><code>-s</code>: Shell 文件 指定用户的登录 Shell。</li>
<li><code>-u</code>: 用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。</li>
</ul>
<h3 id="设置密码" tabindex="-1"> 设置密码</h3>
<div><pre><code><span>sudo</span> <span>passwd</span> <span>[</span>用户名<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="删除用户" tabindex="-1"> 删除用户</h2>
<div><pre><code><span>userdel</span> abc
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>使用 userdel abc 命令删除该用户时，并不能删除该用户的所有信息，只是删除了/etc/passwd、/etc/shadow、/etc/group/、/etc/gshadow 四个文件里的该账户和组的信息。默认情况下创建一个用户账号，会创建一个家目录和一个用户邮箱(在/var/spool/mail 目录以用户名命名)</p>
<p>所以建议使用 <code>userdel -r abc</code> 删除用户。</p>
</div>
<h2 id="服务管理" tabindex="-1"> 服务管理</h2>
<p>Linux 服务管理两种方式 service 和 systemctl</p>
<ol>
<li>
<p>service 命令</p>
<p>service 命令其实是去 <code>/etc/init.d</code> 目录下，去执行相关程序</p>
<ul>
<li>service 命令启动 redis 脚本</li>
</ul>
<div><pre><code><span>service</span> redis start
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>直接启动 redis 脚本</li>
</ul>
<div><pre><code>/etc/init.d/redis start
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>开机自启动</li>
</ul>
<div><pre><code>update-rc.d redis defaults
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中脚本需要我们自己编写</p>
</li>
<li>
<p>systemctl 命令</p>
<p>systemd 是 Linux 系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。</p>
<p>systemd 对应的进程管理命令是 systemctl</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>文件</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/file/</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/file/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">文件</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="/linux/file/mount.html">挂载</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/file/dir.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/file/dir.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">目录</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="linux-文件目录结构" tabindex="-1"> Linux 文件目录结构</h2>
<p>学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。</p>
<p>使用 Linux 时，通过命令行输入 <code>ls -l /</code> 可以看到，在 Linux 根目录 (/) 下包含很多的子目录(称为一级目录)，例如 <code>bin</code>、<code>boot</code>、<code>dev</code> 等。同时，各一级目录下还含有很多子目录(称为二级目录)，比如 <code>/bin/bash</code>、<code>/bin/ed</code> 等。Linux 文件系统目录总体呈现树形结构，<code>/</code> 根目录就相当于树根。</p>
<p>由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果您进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。</p>
<p>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p>
<div><p>提示</p>
<p>FHS(Filesystem Hierarchy Standard)，文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录(<code>/usr</code> 和 <code>/var</code>)的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
</div>
<h2 id="linux-根目录" tabindex="-1"> Linux 根目录(/)</h2>
<p>FHS 认为，Linux 系统的根目录 (/) 最为重要(没有之一)，其原因有以下 2 点:</p>
<ul>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ul>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令，普通用户和 root 都可以执行。放在 <code>/bin</code> 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm 安装)的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的主目录(也称为家目录)。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 <code>/home/</code> 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 <code>/home/liming</code></td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 <code>/media/</code>、<code>/mnt/</code>、<code>/misc/</code>，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 <code>/mnt/</code> 下建立不同目录挂载不同设备的习惯，如 <code>/mnt/cdrom/</code> 挂载光盘、<code>/mnt/usb/</code> 挂载 U 盘，都是可以的</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 <code>/usr/local/</code> 目录中，也就是说，<code>/usr/local/</code> 目录也可以用来安装软件</td>
</tr>
<tr>
<td>/root/</td>
<td>root 的主目录。普通用户主目录在 <code>/home/</code> 下，root 主目录直接在“/”下</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
</tbody>
</table>
<p>FHS 针对根目录中包含的子目录仅限于上表，但除此之外，Linux 系统根目录下通常还包含下表中的几个一级目录。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，<code>/lost+found</code> 就是根分区的备份恢复目录，<code>/boot/lost+found</code> 就是 <code>/boot</code> 分区的备份恢复目录</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 <code>/proc/cpuinfo</code> 是保存 CPU 信息的，<code>/proc/devices</code> 是保存设备驱动的列表的，<code>/proc/filesystems</code> 是保存文件系统列表的，<code>/proc/net</code> 是保存网络协议信息的......</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和 <code>/proc/</code> 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
</tbody>
</table>
<h2 id="linux-usr-目录" tabindex="-1"> Linux /usr 目录</h2>
<p>usr(注意不是 user)，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 <code>/usr</code> 目录下的各子目录中，而不是为他们的产品创建单独的目录。</p>
<p>Linux 系统中，所有系统默认的软件都存储在 <code>/usr</code> 目录下，<code>/usr</code> 目录类似 Windows 系统中 <code>C:\Windows\</code> + <code>C:\Program files\</code> 两个目录的综合体。</p>
<p>FHS 建议，<code>/usr</code> 目录应具备下表所示的子目录。</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/XllR6/</td>
<td>图形界面系统保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 <code>/usr/local/src/</code> 目录中，把内核源码保存到 <code>/usr/src/linux/</code> 目录中</td>
</tr>
<tr>
<td>/usr/include</td>
<td>C/C++ 等编程语言头文件的放置目录</td>
</tr>
</tbody>
</table>
<h2 id="linux-var-目录" tabindex="-1"> Linux /var 目录</h2>
<p><code>/var</code> 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如下表所示的这些子目录。</p>
<table>
<thead>
<tr>
<th>/var 子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 <code>/var/lib/mysql/</code> 目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 <code>/var/log/messages</code>, <code>/var/log/wtmp</code> 等。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的 PID(进程 ID)保存位置</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 <code>/var/spool/mail/</code> 存放新收到的邮件，<code>/var/spool/cron/</code> 存放系统定时任务。</td>
</tr>
<tr>
<td>/var/www/</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>/var/nis 和/var/yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td>
</tr>
<tr>
<td>/var/tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody>
</table>
<p>根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢?</p>
<p>答案是用户的主目录或 <code>/tmp/</code> 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 <code>/proc/fn/sys/</code> 目录，因为它们是保存在内存中的，如果在这里写入数据，那么您的内存会越来越小，直至死机；<code>/boot/</code> 目录也不能保存额外数据，因为 <code>/boot/</code> 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。</p>
<p>总之，Linux 要在合理的目录下进行操作和修改。</p>
<div><p>注意</p>
<p>目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由 <code>/</code> 来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
</div>
<h2 id="硬件设备名称" tabindex="-1"> 硬件设备名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI/SATA/U 盘</td>
<td><code>/dev/sd[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>文件</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/file/file.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/file/file.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">文件</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="文件系统" tabindex="-1"> 文件系统</h2>
<p>目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“<code>/</code>”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含(子)目录或文件。如此反复就可以构成一个庞大的文件系统。
其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“/”来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“<code>.</code>”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“<code>..</code>”表示。</p>
<p>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找(后续会讲查找命令)时，不显示该目录或文件。</p>
<p>为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件(或子目录)，比如说，在 <code>/bin</code> 和 <code>/sbin</code> 目录中存放的应该是可执行文件，有关各个目录存放文件的类型，已在《Linux 文件目录结构一览表》一节中作了详解介绍，这里不再过多赘述。</p>
<h2 id="文件" tabindex="-1"> 文件</h2>
<p>虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p>
<p>和 Linux 不同，Windows 下带有 <code>&lt;DIR&gt;</code> 标记的行或使用中括号 <code>[]</code> 括起来的名称就是目录，其他的则是文件。</p>
<p>不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。</p>
<p>但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 <code>/etc/DIR_COLORS</code> 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 <code>man</code> 命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>man</span> dir_colors</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意，有些 Linux 发行版单独使用 <code>ls</code> 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 <code>ls --color=auto</code> 命令，明确令其使用颜色来区分文件类型。</p>
<p>在此基础上，如果不想每次使用 <code>ls</code> 命令时，都显式附带 <code>--color=auto</code>，可以执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>ls</span> <span>=</span> <span>'ls --color=auto'</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>通过给 <code>ls --color==auto</code> 这个整体设置一个别名 <code>ls</code>，这样当后续使用 <code>ls</code> 命令时，就等同于执行 <code>ls --color=auto</code> 命令。</p>
<p>同时，如果想使这个设置永远生效，还需要将其添加到 <code>/etc/bashrc</code> 或 <code>/home/&lt;user&gt;/.bashrc</code> 文件中，前者对所有用户有效，而后者仅对用户 <code>&lt;user&gt;</code> 有效。</p>
<p>其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。</p>
<p>当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。</p>
<p>通过 <code>ls -l</code> 命令，我们就可以查看当前目录下所有文件和目录各自的属性</p>
<h2 id="命名规则" tabindex="-1"> 命名规则</h2>
<ul>
<li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 <code>&lt;</code>、<code>&gt;</code>、<code>?</code>、<code>*</code> 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。</li>
</ul>
<h2 id="不同字符对应的文件类型" tabindex="-1"> 不同字符对应的文件类型</h2>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 挂载</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/file/mount.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/file/mount.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 挂载</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-挂载" tabindex="-1"> Linux 挂载</h1>
<p>前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统(文件目录结构)。</p>
<p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将 Linux 本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p>
<p>如果不挂载，通过 Linux 系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p>
<p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录(最好是空目录)，访问此目录就等同于访问设备文件。</p>
<p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p>
<p>举个例子，我们想通过命令行访问某个 U 盘中的数据，我们要在根目录下新建一个目录 <code>/sdb-u</code>，通过挂载命令将 U 盘文件系统挂载到此目录，</p>
<p>前面讲过，根目录下的 <code>/dev/</code> 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件(比如 sdb1)，就位于 <code>/dev/</code> 目录下 (<code>/dev/sdb1</code>)，但无法通过 <code>/dev/sdb1/</code> 直接访问 U 盘数据，访问此目录只会提供给您此设备的一些基本信息(比如容量)。</p>
<p>总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。</p>
<h2 id="linux-硬件设备文件名称" tabindex="-1"> Linux 硬件设备文件名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd\[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI / SATA / U 盘</td>
<td><code>/dev/sd\[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd\[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp\[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 简介</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 简介</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-简介" tabindex="-1"> Linux 简介</h1>
<ul>
<li>
<p><a href="/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 的优点</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/advantage.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/advantage.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 的优点</source>
      <category>Linux</category>
      <pubDate>Sat, 16 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-的优点" tabindex="-1"> Linux 的优点</h1>
<p>相比 Windows 系统，Linux 系统有更好的稳定性。此外，Linux 还有如下优点:</p>
<ol>
<li>
<p>大量的可用软件及免费软件</p>
<p>Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。</p>
<p>但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。</p>
</li>
<li>
<p>良好的可移植性及灵活注
Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。</p>
<p>如果读者希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。</p>
</li>
<li>
<p>优良的稳定性和安全性</p>
<p>著名的黑客埃里克•雷蒙德(EricS.Raymond)有一句名言: “足够多的眼睛，就可让所有问题浮现”。举个例子，假如笔者在演讲，台下人山人海，明哥中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算明哥衣领上有一大块油渍也不会被发现。</p>
<p>Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。</p>
</li>
<li>
<p>支持几乎所有的网络协议及开发语言</p>
<p>经常有初学的朋友问我，Linux 是不是对 TCP/IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP/IP 无关呢? 所以，Linux 对网络协议和开发语言的支持很好。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>桌面系统</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/desktop.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/desktop.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">桌面系统</source>
      <category>Linux</category>
      <pubDate>Sat, 16 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="桌面系统" tabindex="-1"> 桌面系统</h1>
<h2 id="kde-桌面系统" tabindex="-1"> KDE 桌面系统</h2>
<p>KDE 是 K Desktop Environment 的缩写，中文译为“K 桌面环境”。</p>
<p>KDE 是基于大名鼎鼎的 Qt 的，最初于 1996 年作为开源项目公布，并在 1998 年发布了第一个版本，现在 KDE 几乎是排名第一的桌面环境了。</p>
<p>许多流行的 Linux 发行版都提供了 KDE 桌面环境，比如 Ubuntu、Linux Mint、OpenSUSE、Fedora、Kubuntu、PC Linux OS 等。</p>
<p>KDE 和 Windows 比较类似，各位初学者相信都是 Windows 的用户，所以切换到 KDE 也不会有太大的障碍。</p>
<p>KDE 允许您把应用程序图标和文件图标放置在桌面的特定位置上。单击应用程序图标，Linux 系统就会运行该应用程序。单击文件图标，KDE 桌面就会确定使用哪种应用程序来处理该文件。</p>
<p>KDE 是所有桌面环境中最容易定制的。在其他桌面环境中，您需要几个插件、窗口组件和调整工具才可以定制环境，KDE 将所有工具和窗口组件都塞入到系统设置中。借助先进的设置管理器，可以控制一切，不需要任何第三方工具，就可以根据用户的喜好和要求来美化及调整桌面。</p>
<p>KDE 项目组还还发了大量的可运行在 KDE 环境中的应用程序，包括 Dolphin(文件管理工具)、Konsole(终端)、Kate(文本编辑工具)、Gwenview(图片查看工具)、Okular(文档及 PDF 查看工具)、Digikam(照片编辑和整理工具)、KMail(电子邮件客户软件)、Quassel(IRC 客户软件)、K3b(DVD 刻录程序)、Krunner(启动器)等，它们都是默认安装的。</p>
<p>对 KDE 优缺点的总结:</p>
<ul>
<li>优点: KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备</li>
<li>缺点: Kmail 等一些组件的配置对新手来说过于复杂。</li>
</ul>
<h2 id="gnome-桌面环境" tabindex="-1"> GNOME 桌面环境</h2>
<p>GNOME 是 the GNU Network Object Model Environment 的缩写，中文译为“GNU 网络对象模型环境”。</p>
<p>GNOME 于 1999 年首次发布，现已成为许多 Linux 发行版默认的桌面环境(不过用得最多的是 Red Hat Linux)。</p>
<p>GNOME 的特点是简洁、运行速度快，但是没有太多的定制选项，用户需要安装第三方工具来实现。</p>
<p>GNOME 甚至不包括一些简单的调整选项，比如更改主题、更改字体等，就这两种基本的调整而言，用户都需要安装第三方工具。所以，GONME 适合那些不需要高度定制界面的用户。</p>
<p>GNOME 被用作 Fedora 中的默认桌面环境，提供在几款流行的 Linux 发行版中，比如 Ubuntu、Debian、OpenSUSE 等。</p>
<p>2011 年，GNOME 3 进行了重大更新，不再采用传统的 Windows 风格的界面，而是进行了全新的设计，惊艳了很多用户。GNOME 3 的这种行为也导致部分用户和开发人员不满，他们又开发了多款其他的桌面环境，比如 MATE 和 Cinnamon。</p>
<p>对 GNOME 优缺点的总结:</p>
<ul>
<li>优点: 简单易用，可通过插件来扩展功能。</li>
<li>缺点: 对插件的管理能力比较差，也缺少其它桌面环境拥有的许多功能。</li>
</ul>
<h2 id="unity" tabindex="-1"> Unity</h2>
<p>Unity 是由 Ubuntu 的母公司 Canonical 开发的一款外壳。之所以说它是外壳，是因为 Unity 运行在 GNOME 桌面环境之上，使用了所有 GNOME 的核心应用程序。</p>
<p>2010 年，Unity 第一个版本发布，此后经过数次改进，如今和其它的桌面环境一样，也可以安装到其它的 Linux 发行版上了。</p>
<p>Unity 使用了不同的界面风格，如果您用的是 Ubuntu Linux 发行版，您会注意到 Unity 与 KDE 和 GNOME 桌面环境有些不一样。</p>
<p>Unity 在左边有一个启动器，位于启动器顶部的是搜索图标，又叫“Dash”。在 Dash 上搜索文件时，不仅会给出来自硬盘的搜索结果，还会给出来自在线来源的搜索结果，比如 Google Drive、Facebook、Picasa、Flick 及其他。</p>
<p>Unity 还提供了隐藏启动器、触摸侧边栏就显示的选项，用户还可以调高/调低显示启动器菜单的灵敏度。</p>
<p>Unity 很简单、运行速度快，但 Unity 在系统设置下却没有定制桌面的太多选项，要想安装主题或者定制另外不同的选项，比如系统菜单是否应该总是可见，或者“从启动器图标一次点击最小化”，用户需要安装第三方工具。</p>
<p>CCSM 和 Unity Tweak Tool 是面向 Unity 桌面环境的非常流行的定制工具。</p>
<p>对 Unity 优缺点的总结:</p>
<ul>
<li>优点: 界面简洁直观，可以通过第三方工具来深度定制，而且使用了平视显示器(HUD)等新技术。</li>
<li>缺点: 默认的定制功能比较差劲，通知机制一般。</li>
</ul>
<h2 id="mate" tabindex="-1"> MATE</h2>
<p>上面我们提到，GNOME 3 进行了全新的界面设计，这招致一些用户的不满，他们推出了其它的桌面环境，MATE 就是其中之一。</p>
<p>MATE 是一种从现在无人维护的 GNOME 2 代码库派生出来的桌面环境。</p>
<p>MATE 让人觉得在使用旧的桌面环境，但是结合了历年来界面方面的诸多改进。MATE 还非常适用于低配计算机，所以如果您有一台旧的或速度较慢的计算机，可以使用 MATE。</p>
<p>MATE 还是许多流行的 Linux 发行版随带的，比如 Ubuntu、Linux Mint、Mageia、Debian 及另外更多发行版。Ubuntu MATE 头一回是官方版本。</p>
<p>“欢迎首次发布的 Ubuntu MATE 官方版本。现在，用户将更容易更新软件，因为所有组件现在都在 Ubuntu 软件库中。”</p>
<p>MATE 自带的应用程序包括 Caja(文件管理工具)、Pluma(文本编辑工具)、Atril(文档查看工具)、Eye of MATE(图像查看工具)等，如果用户不需要其他功能完备的桌面环境的所有额外功能，那么 MATE 对他们来说是一款简单的轻量级桌面环境。</p>
<p>对 META 优缺点的总结:</p>
<ul>
<li>优点: 轻量级的桌面环境，能够兼容教旧的硬件设备。</li>
<li>缺点: 我也不知道有什么明显的缺点，欢迎读者留言告知。</li>
</ul>
<h2 id="cinnamon" tabindex="-1"> Cinnamon</h2>
<p>与 MATE 类似，Cinnamon 是由 Linux Mint 团队因为不满 Gnome 3 的改进而开发的另一种桌面环境。但 Cinnamon 与 MATE 不同之处在于，Cinnamon 建立在 Gnome 3 的基础上。Cinnamon 是新的，而且在积极开发之中，但这款出色的桌面环境没有因新颖而在功能方面有所减弱。</p>
<p>Cinnamon 拥有 GNOME 和 Unity 等其它桌面环境所没有的种种功能。Cinnamon 是高度可定制的桌面环境，不需要任何外部插件、窗口组件和调整工具来定制桌面。Cinnamon 甚至可以通过设置管理器本身来下载并安装主题，甚至不需要打开互联网浏览器。</p>
<p>由于种种出色的所需功能，Cinnamon 对任何刚接触 Linux 的新用户来说都非常方便。许多用户放弃使用 Linux，是因为他们并不了解 Linux 的工作方式，但是我强烈建议新手应从 Cinnamon 桌面环境开始入手。</p>
<p>许多流行的 Linux 发行版提供了各自版本的 Cinnamon，比如 Ubuntu、Fedora、OpenSUSE、Gentoo、Arch Linux 等。Cinnamon 还是 Linux Mint 的默认桌面环境。</p>
<p>对 Cinnamon 优缺点的总结:</p>
<ul>
<li>优点: 成熟完美，高度可性质，适合 Linux 新手。</li>
<li>缺点: 有时候可能会有软件错误。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 和 UNIX</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/history.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/history.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 和 UNIX</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-和-unix" tabindex="-1"> Linux 和 UNIX</h1>
<p>UNIX 与 Linux 之间的关系是一个很有意思的话题。在目前主流的服务器端操作系统中，UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 UNIX 是操作系统中的&quot;老大哥&quot;，后来的 Windows 和 Linux 都参考了 UNIX。</p>
<div><p>提示</p>
<p>现代的 Windows 系统已经朝着“图形界面”的方向发展了，和 UNIX 系统有了巨大的差异，从表面上甚至看不出两者的关联。</p>
</div>
<h2 id="unix-的坎坷历史" tabindex="-1"> UNIX 的坎坷历史</h2>
<p>UNIX 操作系统由肯·汤普森(Ken Thompson)和丹尼斯·里奇(Dennis Ritchie)发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。</p>
<div><p>提示</p>
<p>分时操作系统使一台计算机可以同时为多个用户服务，连接计算机的终端用户交互式发出命令，操作系统采用时间片轮转的方式处理用户的服务请求并在终端上显示结果(操作系统将 CPU 的时间划分成若干个片段，称为时间片)。操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片。</p>
</div>
<p>可惜，由于 Multics 工程计划所追求的目标太庞大、太复杂，以至于它的开发人员都不知道要做成什么样子，最终以失败收场。</p>
<p>以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了一种分时操作系统的雏形，1970 年该系统正式取名为 UNIX。</p>
<p>想一下英文中的前缀 Multi 和 Uni，就明白了 UNIX 的隐意。Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。</p>
<p>有意思的是，肯•汤普森当年开发 UNIX 的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，UNIX 诞生了。</p>
<p>自 1970 年后，UNIX 系统在贝尔实验室内部的程序员之间逐渐流行起来。1971-1972 年，肯•汤普森的同事丹尼斯•里奇发明了传说中的 C 语言，这是一种适合编写系统软件的高级语言，它的诞生是 UNIX 系统发展过程中的一个重要里程碑，它宣告了在操作系统的开发中，汇编语言不再是主宰。</p>
<p>到了 1973 年，UNIX 系统的绝大部分源代码都用 C 语言进行了重写，这为提高 UNIX 系统的可移植性打下了基础(之前操作系统多采用汇编语言，对硬件依赖性强)，也为提高系统软件的开发效率创造了条件。可以说，UNIX 系统与 C 语言是一对孪生兄弟，具有密不可分的关系。</p>
<p>20 世纪 70 年代初，计算机界还有一项伟大的发明——TCP/IP 协议，这是当年美国国防部接手 ARPAnet 后所开发的网络协议。美国国防部把 TCP/IP 协议与 UNIX 系统、C 语言捆绑在一起，由 AT&amp;T 发行给美国各个大学非商业的许可证，这为 UNIX 系统、C 语言、TCP/IP 协议的发展拉开了序幕，它们分别在操作系统、编程语言、网络协议这三个领域影响至今。肯•汤普森和丹尼斯•里奇因在计算机领域做出的杰出贡献，于 1983 年获得了计算机科学的最高奖——图灵奖。</p>
<p>随后出现了各种版本的 UNIX 系统，目前常见的有 Sun Solaris、FreeBSD、IBM AIX、HP-UX 等。</p>
<h2 id="solaris-和-freebsd" tabindex="-1"> Solaris 和 FreeBSD</h2>
<p>我们重点介绍一下 Solaris，它是 UNIX 系统的一个重要分支。Solaris 除可以运行在 SPARC CPU 平台上外，还可以运行在 x86 CPU 平台上。在服务器市场上，Sun 的硬件平台具有高可用性和高可靠性，是市场上处于支配地位的 UNIX 系统。</p>
<p>对于难以接触到 Sun SPARC 架构计算机的用户来说，可以通过使用 Solaris x86 来体验世界知名大厂的商业 UNIX 风采。当然，Solaris x86 也可以用于实际生产应用的服务器，在遵守 Sun 的有关许可条款的情况下，Solaris x86 可以免费用于学习研究或商业应用。</p>
<p>FreeBSD 源于美国加利福尼亚大学伯克利分校开发的 UNIX 版本，它由来自世界各地的志愿者开发和维护，为不同架构的计算机系统提供了不同程度的支持。FreeBSD 在 BSD 许可协议下发布，允许任何人在保留版权和许可协议信息的前提下随意使用和发行，并不限制将 FreeBSD 的代码在另一协议下发行，因此商业公司可以自由地将 FreeBSD 代码融入它们的产品中。苹果公司的 macOS 就是基于 FreeBSD 的操作系统。</p>
<p>FreeBSD 与 Linux 的用户群有相当一部分是重合的，二者支持的硬件环境也比较一致，所采用的软件也比较类似。FreeBSD 的最大特点就是稳定和高效，是作为服务器操作系统的不错选择；但其对硬件的支持没有 Linux 完备，所以并不适合作为桌面系统。</p>
<p>其他 UNIX 版本因应用范围相对有限，在此不做过多介绍。</p>
<h2 id="linux-的那些往事" tabindex="-1"> Linux 的那些往事</h2>
<p>Linux 内核最初是由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷您版 UNIX 操作系统 Minix 太难用了，于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月发布，当时仅有 10 000 行代码。</p>
<p>李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。</p>
<p>据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核(操作系统的核心部分)，并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。</p>
<p>李纳斯•托瓦兹无疑是这个世界上最伟大的程序员之一，何况，他还搞出了全世界最大的程序员交友社区 GitHub (开源代码库及版本控制系统)。</p>
<p>关于 Linux Logo 的由来是一个很有意思的话题，它是一只企鹅。企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，任何国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是: 开放源代码的 Linux 为全人类共同所有，任何公司无权将其私有。</p>
<h2 id="unix-与-linux-的关系" tabindex="-1"> UNIX 与 Linux 的关系</h2>
<p>二者的关系，不是大哥和小弟，&quot;UNIX 是 Linux 的父亲&quot;这个说法更怡当。之所以要介绍它们的关系，是因为要告诉读者，在学习的时候，其实 Linux 与 UNIX 有很多的共通之处，简单地说，如果您已经熟练掌握了 Linux，那么再上手使用 UNIX 会非常容易。</p>
<p>二者也有两个大的区别:</p>
<ul>
<li>
<p>UNIX 系统大多是与硬件配套的，也就是说，大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上；</p>
</li>
<li>
<p>UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的。</p>
</li>
</ul>
<p>Linux 受至旷大计算机爱好者的喜爱，主要原因也有两个:</p>
<ul>
<li>
<p>它属于开源软件，用户不用支付可费用就可以获得它和它的源代码，并且可以根据自己的需要对它进行必要的修改，无偿使用，无约束地继续传播；</p>
</li>
<li>
<p>它具有 UNIX 的全部功能，任何使用 UNIX 操作系统或想要学习 UNIX 操作系统的人都可以从 Linux 中获益。</p>
</li>
</ul>
<p>开源软件是不同于商业软件的一种模式，从字面上理解，就是开放源代码，大家不用担心里面会搞什么猫腻，这会带来软件的革新和安全。</p>
<p>另外，开源其实并不等同于免费，而是一种新的软件盈利模式。目前很多软件都是开源软件，对计算机行业与互联网影响深远。</p>
<p>近年来，Linux 已经青出于蓝而胜于蓝，以超常的速度发展，从一个丑小鸭变成了一个拥有庞大用户群的真正优秀的、值得信赖的操作系统。历史的车轮让 Linux 成为 UNIX 最优秀的传承者。</p>
<div><p>总结</p>
<p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX(但并没有抄袭 UNIX 的源码)，使得 Linux 在外观和交互上与 UNIX 非常类似。</p>
</div>
<p>相比于 UNIX，Linux 最大的创新是开源免费，这是它能够蓬勃发展的最重要原因；而目前的 UNIX 大部分都是收费的，小公司和个人都难以承受。</p>
<p>正是由于 Linux 和 UNIX 有着千丝万缕的联系，所以人们把 Linux 叫做“类 UNIX 系统”。</p>
<h2 id="unix-linux-系统结构" tabindex="-1"> UNIX/Linux 系统结构</h2>
<p>UNIX/Linux 系统可以粗糙地抽象为 3 个层次(所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解)，如图 3 所示。底层是 UNIX/Linux 操作系统，即系统内核(Kernel)；中间层是 Shell 层，即命令解释层；高层则是应用层。</p>
<p><img src="@source/linux/assets/structure.jpg" alt="Structrure"></p>
<ol>
<li>
<p>内核层</p>
<p>内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</p>
</li>
<li>
<p>Shell 层</p>
<p>Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p>
</li>
<li>
<p>应用层</p>
<p>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能(就如同 TCP/IP 是一个协议，定义软件所应具备的功能)，可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</p>
</li>
</ol>
<p>现在大多数的 UNIX 系统上(包括 Solaris、HP-UX、AIX 等)都可以运行 CDE (Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境) 的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。</p>
<h2 id="协议" tabindex="-1"> 协议</h2>
<p>早在 20 世纪 70 年代，UNIX 系统是开源而且免费的，但是在 1979 年时，AT&amp;T 公司宣布了对 UNIX 系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。</p>
<p>于是在 1984 年，Richard Stallman 面对于如此封闭的软件创作环境，发起了 GNU 源代码开放计划并制定了著名的 GPL 许可协议。</p>
<p>1987 年时，GNU 计划获得了一项重大突破，即发布了 gcc 编译器，这使得程序员可以基于该编译器编写出属于自己的开源软件。随之，在 1991 年 10 月，芬兰赫尔辛基大学的在校生 Linus Torvalds 编写了一款名为 Linux 的操作系统，该系统因其较高的代码质量且基于 GNU GPL 许可协议的开放源代码特性，迅速得到了 GNU 计划和一大批黑客程序员的支持，随后 Linux 系统便进入了如火如荼的发展阶段。</p>
<p>1994 年 1 月，Bob Young(红帽创始人)在 Linux 系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了 Linux 系统的普及。</p>
<p>1998 年以后，随着 GNU 源代码开放计划和 Linux 系统的继续火热，以 IBM 和 Intel 为首的多家 IT 企业巨头开始大力推动开放源代码软件的发展。</p>
<p>到了 2017 年年底，Linux 内核已经发展到了 4.13 版本，并且 Linux 系统版本也有数百个之多，但它们依然都使用 Linus Torvalds 开发、维护的 Linux 系统内核。RedHat 公司也成为了开源行业及 Linux 系统的带头公司。</p>
<p>初步接触 Linux 的读者，或者有这样一个疑问，Windows 系统也很好用，也能满足日常工作需求，为什么要学习 Linux 系统呢?</p>
<p>有些初学者会将“Linxu 系统是开源的”作为这个问题的答案，其实不然。开源的操作系统少说有 100 个，开源的软件至少也有十万个，为什么不去逐个学习? Linux 的开源特性只是一部分优势，并不是学习 Linux 的主要原因。</p>
<p>对于用户来讲，开源精神仅具备锦上添花的效果，真正的原因在于，Linux 系统是一款优秀的软件产品，具有类似 UNIX 的程序界面，而且继承了 UNIX 的稳定性，能够较好地满足工作需求。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 简介</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/intro.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/intro.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 简介</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-简介" tabindex="-1"> Linux 简介</h1>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹 (Linus Torvalds) 在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p>Linux 让开展各种实际有用且具有创造性的事情成为可能。例如，您可以在一个 U 盘上装载 Linux 的自生系统引导映像 (live boot image)，启动一台硬盘已经崩溃的计算机，之后査找并解决该问题。或者，因为 Linux 是一个真正的多用户操作系统，它具有非常好的私密性和稳定性，整个团队可以同时从本地或远程登录进行工作。</p>
<p>Linux 的构建采用了一些与 UNIX 操作系统相同的技术，并带有大多数与深度成熟的 UNIX 操作系统相一致的工具，这极大地增加了稳定性与安全性。</p>
<p>Linux 的发行版还提供了复杂的软件包管理系统，可以可靠地安装和维护每一个在线资源库中成千上万的免费软件应用。</p>
<p>Linux 不仅是免费的，更是开源的(open source)，这意味着任何人都可以获得其代码并根据自己的需求进行修改。</p>
<h2 id="linux-的发行版" tabindex="-1"> Linux 的发行版</h2>
<p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p><img src="@source/linux/assets/intro.jpg" alt="intro"></p>
<p>事实上，已经孵化出专属 Linux 各发行版的巨大生态系统。一个发行版(distribution ，有时缩写为 distro)是一个定制的软件包，它将 Linux 内核以及用户计算机 Linux 运行版的安装工具一起发布。</p>
<p>在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以 Linux 为核心的操作系统软件包”。</p>
<p>Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层(由发行商整合开发的应用)才有所体现。</p>
<p>目前市面上较知名的发行版有: Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<p>Linux 的发行版本可以大体分为两类:</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表；</li>
<li>社区组织维护的发行版本，以 Debian 为代表。</li>
</ul>
<p>很难说大量 Linux 版本中哪一款更好，每个版本都有自己的特点。</p>
<h3 id="red-hat-linux" tabindex="-1"> Red Hat Linux</h3>
<p>Red Hat(红帽公司)创建于 1993 年，是目前世界上资深的 Linux 厂商，也是最获认可的 Linux 品牌。</p>
<p>Red Hat 公司的产品主要包括 RHEL(Red Hat Enterprise Linux，收费版本)和 CentOS(RHEL 的社区克隆版本，免费版本)、Fedora Core(由 Red Hat 桌面版发展而来，免费版本)。</p>
<p>Red Hat 是在我国国内使用人群最多的 Linux 版本，资料丰富，如果您有什么不明白的地方，则容易找到人来请教，而且大多数 Linux 教程是以 Red Hat 为例来讲解的(包括本教程)。</p>
<p>CentOS 是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任。</p>
<h3 id="ubuntu-linux" tabindex="-1"> Ubuntu Linux</h3>
<p>Ubuntu 基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供。</p>
<p>Ubuntu 的创始人 Mark Shuttleworth 是非常具有传奇色彩的人物。他在大学毕业后创建了一家安全咨询公司，1999 年以 5.75 亿美元被收购，由此一跃成为南非最年轻有为的本土富翁。作为一名狂热的天文爱好者，Mark Shuttleworth 于 2002 年自费乘坐俄罗斯联盟号飞船，在国际空间站中度过了 8 天的时光。之后，Mark Shuttleworth 创立了 Ubuntu 社区，2005 年 7 月 1 日建立了 Ubuntu 基金会，并为该基金会投资 1000 万美元。他说，太空的所见正是他创立 Ubuntu 的精神之所在。如今，他最热衷的事情就是到处为自由开源的 Ubuntu 进行宣传演讲。</p>
<h3 id="suse-linux" tabindex="-1"> SuSE Linux</h3>
<p>SuSE Linux 以 Slackware Linux 为基础，原来是德国的 SuSE Linux AG 公司发布的 Linux 版本，1994 年发行了第一版，早期只有商业版本，2004 年被 Novell 公司收购后，成立了 OpenSUSE 社区，推出了自己的社区版本 OpenSUSE。</p>
<p>SuSE Linux 在欧洲较为流行，在我国国内也有较多应用。值得一提的是，它吸取了 Red Hat Linux 的很多特质。</p>
<p>SuSE Linux 可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便。</p>
<h3 id="gentoo" tabindex="-1"> Gentoo</h3>
<p>Gentoo 最初由 Daniel Robbins(FreeBSD 的开发者之一)创建，首个稳定版本发布于 2002 年。Gentoo 是所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。</p>
<p>不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。自从 Gentoo 1.0 面世后，它就像一场风暴，给 Linux 世界带来了巨大的惊喜，同时也吸引了大量的用户和开发者投入 Gentoo Linux 的怀抱。</p>
<p>有人这样评价 Gentoo: 快速、设计干净而有弹性，它的出名是因为其高度的自定制性(基于源代码的发行版)。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译。这也是为什么 Gentoo 适合比较有 Linux 使用经验的老手使用。</p>
<h3 id="发行版选择" tabindex="-1"> 发行版选择</h3>
<p>Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议:</p>
<ul>
<li>
<p>如果您需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议您选择 CentOS 或 RHEL。</p>
</li>
<li>
<p>如果您只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。</p>
</li>
<li>
<p>如果您想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。</p>
</li>
<li>
<p>如果您对系统稳定性要求很高，则可以考虑 FreeBSD。</p>
</li>
<li>
<p>如果您需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>语言</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/language.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/language.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">语言</source>
      <description>Linux 中大量使用脚本语言，而不是 C 语言!
</description>
      <category>Linux</category>
      <pubDate>Sat, 16 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Linux 中大量使用脚本语言，而不是 C 语言!</p>

<p>说到在 Linux 下的编程，很多人会想到用 C 语言，Linux 的内核、shell、基础命令程序，也的确是用 C 语言编写的，这首先证明了一点，C 语言很强很通用。</p>
<p>到目前为止，C 语言依然垄断着计算机工业中几乎所有的系统编程，而且也正因为是 C 语言，才使得 Unix 以及后来的 Linux 能够这么广泛地被人们去研究、去改进、去制作自己的分支，以至于我们能在各种硬件平台上使用它们。</p>
<p>但是细心的人会发现，Linux 启动过程中所涉及的各种程序，很少有 C 语言的痕迹。它们大多是脚本程序。不单单在启动过程中是这样，那些用于安装软件的工具 yum、apt-get，甚至是 configure 和 Makefile 也都是脚本程序。而且您可能还没注意到，那些用于系统管理的工具，如配置 ADSL 拨号上网的工具、配置守护进程的工具等，很多也都是脚本程序。</p>
<p>大量使用脚本程序，是所有类 Unix 系统不同于其他系统的一个显著特征，催生人们在 Linux 中大量使用脚本来编写程序，并不仅仅是因为脚本对人直观、容易修改这种显著特性所决定的。另外一个主要的原因就是 Linux 所支持的脚本语言种类十分丰富。</p>
<p>所有类 Unix 系统所必备的 shell，其本身就是一个强大的脚本解释器。所以从 shell 诞生的那一天起，shell 就是那些不懂 C 语言，又必须在 Unix 上编写程序的用户们的首选工具。</p>
<p>这就给了人们一种新的选择，使用 shell 编程不用去理会让人头晕的指针；shell 程序可以直接利用系统命令来完成一些需要用大量 C 代码的功能；shell 编程不用去理会数据类型，不用考虑烦人的数值和字符数据的转换问题；shell 程序同样提供顺序、选择分支和循环这三种能够构建任意算法的基础设施。因此，shell 很快就能够被非专业用户所接受、掌握，并编写出非常实用的程序。</p>
<p>随着时间的推移，这些非专业用户想往更高的方向发展，遇到了一些 shell 处理起来会很“蹩脚”的问题，比如分析文本和修改文本(别忘了“万般皆文本”)。这个时候他们会发现 有 awk 和 sed。也只需要写几行脚本就能将这些问题处理得很好。而且它们也跟 shell 配合得天衣无缝。或许这个时候会觉得加入了 awk 和 sed 的 shell 脚本有些难看，不过没关系，还有 Perl 和 TCL。Perl 天生就是为处理文本而存在的，TCL 也不含糊。</p>
<p>如果觉得这些语言都太老气了，有些过时了，不要紧，还有 Python、Ruby 等这些现代脚本语言，它们除了不能写操作系统内核之外，几乎什么都能干，而且还是面向对象的。</p>
<p>不管怎样，在 Linux 下能够选择的脚本语言都是极其丰富的。它们最大的特点就是简单、好学且资料丰富。简单就意味着容易维护，好学就容易吸引用户，资料丰富就不会在解决 bug 上出现障碍。即便是专业的程序员，也会因为这些特点而特别偏好脚本语言，导致的一个结果就是脚本程序在 Linux 中的大爆发。</p>
<p>为什么不选择 C 语言呢?</p>
<h2 id="c-语言并不是最佳选择" tabindex="-1"> C 语言并不是最佳选择</h2>
<p>C 语言是 Unix 的母语，这是毋庸罝疑的。前面也说过，正是因为有了 C 语言，才使得 Unix 有了今天的成就。但为什么在 Linux 中有这么多程序，甚至是关键程序，不用 C 语言编写呢?</p>
<p>脚本程序由于是解释执行的，在执行效率上自然是会有很大损失的。并且大家都知道，C 语言所编写的程序又是以效率著称的。但是 C 语言是一种编译型语言，要想让 C 语言的程序能够运行，必须经过编译和链接这两个步骤。</p>
<p>要知道，能够将由几十个源代码文件构成的 C 语言程序，有条不紊地编译完成并能最终链接成一个可执行程序，本身就是一件费时又费力的事情，如果一旦程序有问题，还必须使用专门的调试工具一点点地去跟踪判断，修正之后再重复那些复杂的编译和链接步骤，这又是一个极需技巧的事情。积累并掌握技巧又是一件费时又费力的事情。</p>
<p>在早些年，计算机性能不佳的时候，这些付出或许是值得的。但是放到现在，处理器的速度至少快了几千倍，内存大了几千倍，硬盘甚至大了几万倍，而价格却更低了。从经济角度分析，机器的时间成本早己远远低于人的时间成本了。那么 C 语言在机器效率上的优势根本没有任何意义。脚本程序能够给人节省下来的时间成本，则更具经济效益。
要论机器效率，汇编语言比 C 语言要好上几十倍，但是目前还有谁在用汇编语言编程呢?</p>
<p>C 语言在设计的时候，最主要的一个目标就是能够让程序员自己处理内存管理的问题。这使得 C 语言很强大但又太过于灵活，导致了很多陷阱的出现。稍微一不注意，程序中就会存在难以发觉的 Bug，甚至是严重的安全漏洞。程序员们大多是要以时间或失败为代价去积累经验，才能尽量避免这些问题的发生。而且效率在大多数应用中根本就不是问题，首要的是正确。脚本程序的简单和直观正是正确的起点，C 语言的灵活却是错误的根源。</p>
<p>但是，C 语言并不是一无是处，也是 Unix 的精华。C 语言作为通用程序设计语言是所向无敌的。C 语言本身也非常简洁和紧凑，资料丰富且容易学习。C 语言之后的少数语言设计，为了不被 C 语言所吞并，不得不进行大的改动，比如引进垃圾回收机制等，以和 C 语言能够在功能上保持足够距离。也正是因为这样，C 语言始终没有消失，只是它的光辉在 Linux 中稍稍地被脚本程序所遮挡了一下。</p>
<h2 id="脚本语言也有不足" tabindex="-1"> 脚本语言也有不足</h2>
<p>虽然效率并不是脚本程序的缺点，但是种类过于丰富却是一个极大不足。编写一个复杂的应用，往往很难使用一种脚本语言包杆到底，因为脚本语言都有自己适用的场景，为了能够快速有效地完成某个应用，就需扬长避短，利用多种脚本语言混合编程。</p>
<p>多脚本语言的混合编程是一种知识密集型的编程方法，但不是编码密集型的(这是能够被普遍接受的原因)。为了能够良好地使用这种方法，就要求程序员不仅仅要具备相当数量的多种语言知识，还必须具备能够判断这些语言的适用场景、以及如何将它们有效地组合在一起的经验。</p>
<p>实际上，混合编程并不是脚本语言的专利，任何编程语言都行，只要您能找准那些语言的特点。比如笔者就曾经使用过 Basic 和 C 进行混合编程，去完成一个 DOS 版万年历程序。为了支持鼠标点击操作，用 C 完成了鼠标中断的处理。余下的部分都用 Basic 来完成。</p>
<p>在 Linux 中大量应用脚本程序的场景，好多都是这种混合编程的典范。比如 Linux 的启动过程，主程序 init 是用 C 语言写的，具体到启动流程的各个环节则是 shell 脚本程序。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 系统启动过程</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/intro/startup.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/intro/startup.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">Linux 系统启动过程</source>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-系统启动过程" tabindex="-1"> Linux 系统启动过程</h1>
<div><p>提示</p>
<p>本篇教程以 CentOS 为例介绍系统的启动过程。</p>
</div>
<p>Linux 启动时我们会看到许多启动信息。</p>
<p>Linux 系统的启动过程并不是大家想象中的那么复杂，其过程可以分为 5 个阶段:</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<div><p>提示</p>
<p>init 程序的类型:</p>
<ul>
<li>SysV: init, CentOS 5 之前, 配置文件: /etc/inittab。</li>
<li>Upstart: init,CentOS 6, 配置文件: /etc/inittab, /etc/init/*.conf。</li>
<li>Systemd: systemd, CentOS 7,配置文件: /usr/lib/systemd/system、 /etc/systemd/system。</li>
</ul>
</div>
<h2 id="内核引导" tabindex="-1"> 内核引导</h2>
<p>当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备(通常是硬盘)来启动。</p>
<p>操作系统接管硬件以后，首先读入 <code>/boot</code> 目录下的内核文件。</p>
<p><img src="@source/linux/assets/boot.png" alt="boot"></p>
<h2 id="运行-init" tabindex="-1"> 运行 init</h2>
<p>init 进程是系统所有进程的起点，您可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<p>init 程序首先是需要读取配置文件 <code>/etc/inittab</code>。</p>
<p><img src="@source/linux/assets/init.png" alt="init"></p>
<h3 id="运行级别" tabindex="-1"> 运行级别</h3>
<p>许多程序需要开机启动。它们在 Windows 叫做&quot;服务&quot;(service)，在 Linux 就叫做&quot;守护进程&quot;(daemon)。</p>
<p>init 进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。</p>
<p>Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做&quot;运行级别&quot;(runlevel)。也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</p>
<p><img src="@source/linux/assets/runlevel.png" alt="runlevel"></p>
<p>Linux 系统有 7 个运行级别(runlevel):</p>
<ul>
<li>运行级别 0: 系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</li>
<li>运行级别 1: 单用户工作状态，root 权限，用于系统维护，禁止远程登陆</li>
<li>运行级别 2: 多用户状态(没有 NFS)</li>
<li>运行级别 3: 完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别 4: 系统未使用，保留</li>
<li>运行级别 5: X11 控制台，登陆后进入图形 GUI 模式</li>
<li>运行级别 6: 系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</li>
</ul>
<h2 id="系统初始化" tabindex="-1"> 系统初始化</h2>
<p>在 init 的配置文件中有这么一行: <code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了 <code>/etc/rc.d/rc.sysinit</code>，而 <code>rc.sysinit</code> 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有: 激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<div><pre><code>l5:5:wait:/etc/rc.d/rc <span>5</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这一行表示以 5 为参数运行 <code>/etc/rc.d/rc</code>，<code>/etc/rc.d/rc</code> 是一个 Shell 脚本，它接受 5 作为参数，去执行 <code>/etc/rc.d/rc5.d/</code> 目录下的所有的 rc 启动脚本，<code>/etc/rc.d/rc5.d/</code> 目录中的这些启动脚本实际上都是一些连接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际上都是放在 <code>/etc/rc.d/init.d/</code>目录下。</p>
<p>而这些 rc 启动脚本有着类似的用法，它们一般能接受 start、stop、restart、status 等参数。</p>
<p><code>/etc/rc.d/rc5.d/</code> 中的 rc 启动脚本通常是 K 或 S 开头的连接文件，对于以 S 开头的启动脚本，将以 start 参数来运行。</p>
<p>而如果发现存在相应的脚本也存在 K 打头的连接，而且已经处于运行态了(以 <code>/var/lock/subsys/</code> 下的文件作为标志)，则将首先以 stop 为参数停止这些已经启动了的守护进程，然后再重新运行。</p>
<p>这样做是为了保证是当 init 改变运行级别时，所有相关的守护进程都将重启。</p>
<p>至于在每个运行级中将运行哪些守护进程，用户可以通过 chkconfig 或 setup 中的 &quot;System Services&quot; 来自行设定。</p>
]]></content:encoded>
    </item>
    <item>
      <title>ubuntu</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/ubuntu/</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/ubuntu/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">ubuntu</source>
      <category>Linux</category>
      <pubDate>Thu, 21 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="ubuntu" tabindex="-1"> ubuntu</h1>
<ul>
<li>
<p><a href="/linux/ubuntu/manage.html">管理包</a></p>
</li>
<li>
<p><a href="/linux/ubuntu/debug.html">开发软件</a></p>
</li>
<li>
<p><a href="/linux/ubuntu/webserver.html">网络服务器相关</a></p>
</li>
<li>
<p><a href="/linux/ubuntu/lang.html">语言切换</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>开发软件</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/ubuntu/debug.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/ubuntu/debug.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">开发软件</source>
      <category>Linux</category>
      <pubDate>Thu, 21 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="开发软件" tabindex="-1"> 开发软件</h1>
<h2 id="安装-vs-code" tabindex="-1"> 安装 VS Code</h2>
<ul>
<li>
<p>使用 snap</p>
<div><pre><code><span>sudo</span> snap <span>install</span> --classic code
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>在 WSL 环境下 snap 无法使用，则使用以下命令安装 code 库。</p>
<div><pre><code><span>curl</span> https://packages.microsoft.com/keys/microsoft.asc <span>|</span> gpg --dearmor <span>></span> packages.microsoft.gpg
<span>sudo</span> <span>install</span> -o root -g root -m <span>644</span> packages.microsoft.gpg /usr/share/keyrings/
<span>sudo</span> <span>sh</span> -c <span>'echo "deb [arch=amd64 signed-by=/usr/share/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main" > /etc/apt/sources.list.d/vscode.list'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>然后正常安装:</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> apt-transport-https
<span>sudo</span> <span>apt-get</span> update
<span>sudo</span> <span>apt-get</span> <span>install</span> code <span># or code-insiders</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
</ul>
<p>可能还需要安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> libx11-xcb1 libasound2
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="remote-插件安装" tabindex="-1"> remote 插件安装</h3>
<div><pre><code>code --install-extension ms-vscode-remote.vscode-remote-extensionpack
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="nvm" tabindex="-1"> nvm</h2>
<div><pre><code><span>curl</span> -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh <span>|</span> <span>bash</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在 Linux 上可能需要重新链接终端，命令才可用。</p>
<p>测试命令，输入 <code>nvm</code> 即安装成功:</p>
<div><pre><code><span>command</span> -v nvm
</code></pre><div aria-hidden="true"><div></div></div></div><p>安装命令:</p>
<div><pre><code>nvm <span>install</span> <span>10</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>切换命令:</p>
<div><pre><code>nvm use <span>10</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="安装-git" tabindex="-1"> 安装 Git</h2>
<div><pre><code><span>sudo</span> add-apt-repository ppa:git-core/ppa

<span>sudo</span> <span>apt-get</span> update

<span>sudo</span> <span>apt-get</span> <span>install</span> <span>git</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="yarn" tabindex="-1"> yarn</h2>
<div><pre><code><span>curl</span> -sS https://dl.yarnpkg.com/debian/pubkey.gpg <span>|</span> <span>sudo</span> apt-key <span>add</span> -
<span>echo</span> <span>"deb https://dl.yarnpkg.com/debian/ stable main"</span> <span>|</span> <span>sudo</span> <span>tee</span> /etc/apt/sources.list.d/yarn.list
<span>sudo</span> <span>apt-get</span> update <span>&amp;&amp;</span> <span>sudo</span> <span>apt-get</span> <span>install</span> <span>yarn</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>语言切换</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/ubuntu/lang.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/ubuntu/lang.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">语言切换</source>
      <category>Linux</category>
      <pubDate>Fri, 22 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="语言切换" tabindex="-1"> 语言切换</h1>
<p>查看当前语言包: <code>locale -a</code></p>
<p>中文语言是: <code>zh_CN.utf8</code></p>
<h2 id="安装中文语言包" tabindex="-1"> 安装中文语言包</h2>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> language-pack-zh-hans
</code></pre><div aria-hidden="true"><div></div></div></div><p>之后修改 <code>/etc/default/locale</code>，将 <code>LANG</code> 改为 <code>zh_CN.utf8</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>管理工具</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/ubuntu/manage.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/ubuntu/manage.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">管理工具</source>
      <category>Linux</category>
      <pubDate>Thu, 21 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="管理工具" tabindex="-1"> 管理工具</h1>
<h2 id="apt-get" tabindex="-1"> apt-get</h2>
<p><code>apt-get</code> 命令默认的源在国内访问很慢，可以考虑换源。</p>
<ul>
<li>
<p>获取软件包更新:</p>
<div><pre><code><span>apt-get</span> update
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>更新软件包:</p>
<div><pre><code><span>apt-get</span> update
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>其他命令<sup></sup></p>
</li>
</ul>
<h2 id="snap" tabindex="-1"> Snap</h2>
<p>已经预装。</p>
<p>在中国大陆不建议使用 Snap</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>其他命令</p>
<div><pre><code><span>apt-cache</span> search <span># ------(package 搜索包)</span>

<span>apt-cache</span> show <span>#------(package 获取包的相关信息，如说明、大小、版本等)</span>

<span>sudo</span> <span>apt-get</span> <span>install</span> <span># ------(package 安装包)sudo apt-get install # -----(package - - reinstall 重新安装包)</span>

<span>sudo</span> <span>apt-get</span> -f <span>install</span> <span># -----(强制安装?#"-f = --fix-missing"当是修复安装吧...)</span>

<span>sudo</span> <span>apt-get</span> remove <span>#-----(package 删除包)</span>

<span>sudo</span> <span>apt-get</span> remove - - purge <span># ------(package 删除包，包括删除配置文件等)</span>

<span>sudo</span> <span>apt-get</span> autoremove --purge <span># ----(package 删除包及其依赖的软件包+配置文件等(只对6.10有效，强烈推荐))</span>

<span>sudo</span> <span>apt-get</span> update <span>#------更新源</span>

<span>sudo</span> <span>apt-get</span> upgrade <span>#------更新已安装的包</span>

<span>sudo</span> <span>apt-get</span> dist-upgrade <span># ---------升级系统</span>

<span>sudo</span> <span>apt-get</span> dselect-upgrade <span>#------使用 dselect 升级</span>

<span>apt-cache</span> depends <span>#-------(package 了解使用依赖)</span>

<span>apt-cache</span> rdepends <span># ------(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧...)</span>

<span>sudo</span> <span>apt-get</span> build-dep <span># ------(package 安装相关的编译环境)</span>

<span>apt-get</span> <span>source</span> <span>#------(package 下载该包的源代码)</span>

<span>sudo</span> <span>apt-get</span> clean <span>&amp;&amp;</span> <span>sudo</span> <span>apt-get</span> autoclean <span># --------清理下载文件的存档 &amp;&amp; 只清理过时的包</span>

<span>sudo</span> <span>apt-get</span> check <span>#-------检查是否有损坏的依赖</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div> </li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>网络服务器相关</title>
      <link>https://songjun520.cn/vuepress-blog2/linux/ubuntu/webserver.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/linux/ubuntu/webserver.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">网络服务器相关</source>
      <pubDate>Fri, 22 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="网络服务器相关" tabindex="-1"> 网络服务器相关</h1>
<h2 id="ftp" tabindex="-1"> ftp</h2>
<h3 id="vsftpd" tabindex="-1"> vsftpd</h3>
<ul>
<li>
<p>安装</p>
<div><pre><code><span>apt-get</span> <span>install</span> vsftpd <span>ftp</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>配置</p>
<div><pre><code><span>vim</span> /etc/vsftpd.conf
</code></pre><div aria-hidden="true"><div></div></div></div><p>至少要更改:</p>
<div><pre><code><span>write_enable</span><span>=</span><span>YES</span>
<span>utf8_filesystem</span><span>=</span><span>YES</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
</ul>
<h2 id="nginx" tabindex="-1"> Nginx</h2>
<ul>
<li>
<p>安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> nginx
</code></pre><div aria-hidden="true"><div></div></div></div><p>Nginx 默认安装在 <code>/etc/nginx</code> 目录下</p>
</li>
<li>
<p>配置</p>
<p>配置文件为 <code>nginx.conf</code>。</p>
<p>默认站点配置文件在 <code>/etc/nginx/sites-available/default</code></p>
<p>为了使得 Nginx 能使用 PHP，需要配置</p>
<div><pre><code>
<span><span>location</span> ~ \.php$</span> <span>{</span>
    <span><span>root</span>           /var/www/html</span><span>;</span>
    <span># 配置给 socks 应该可行，还在研究中</span>
    <span><span>fastcgi_pass</span>   127.0.0.1:9000</span><span>;</span>
    <span><span>fastcgi_index</span>  index.php</span><span>;</span>
    <span><span>fastcgi_param</span>  SCRIPT_FILENAME  <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
    <span><span>include</span>        fastcgi_params</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
<h2 id="php" tabindex="-1"> PHP</h2>
<div><pre><code><span># Apache</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php

<span># Ngnix</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php-fpm

<span># MySQL</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php-mysql
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="mysql" tabindex="-1"> MySQL</h2>
<h3 id="安装" tabindex="-1"> 安装</h3>
<div><pre><code><span>wget</span> https://dev.mysql.com/get/mysql-apt-config_0.8.14-1_all.deb
<span>sudo</span> dpkg -i mysql-apt-config_0.8.14-1_all.deb
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>配置版本(一般是 5.7)后安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> mysql-server
</code></pre><div aria-hidden="true"><div></div></div></div><p>之后重启，完成配置</p>
<div><pre><code><span>sudo</span> <span>service</span> mysql restart
mysql -u root -p
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="nmp" tabindex="-1"> NMP</h2>
<p>需要对 Nginx 的配置文件进行修改: 主要改动的目标是把 Nginx 代理端口转发给 php-fpm。</p>
<p>首先配置 index:</p>
<div><pre><code><span><span>index</span> index.php index.html</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>需要注意的是，Nginx 将端口转发给 php 默认的 9000 端口。而通过 apt-get 安装的 php 默认使用本地 sock 文件通信，需要对 php 的配置进行修改。要修改的文件位于: <code>/etc/php/7.2/fpm/pool.d/www.conf</code>，将</p>
<div><pre><code><span>listen</span> <span>=</span> <span>/run/php/php7.0-fpm.sock</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>改成:</p>
<div><pre><code><span>listen</span> <span>=</span> <span>127.0.0.1:9000</span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>如果报了 permission limitted 的错误，说明 php 没法访问 html 文件夹，修改配置的 html 文件夹权限即可。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>NodeJS</title>
      <link>https://songjun520.cn/vuepress-blog2/note/node-js/</link>
      <guid>https://songjun520.cn/vuepress-blog2/note/node-js/</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">NodeJS</source>
      <pubDate>Fri, 26 Aug 2022 09:37:39 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li><a href="/note/node-js/current-path.html">current-path 相关</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>__dirname、__filename 和 process.cwd() 三者的区别</title>
      <link>https://songjun520.cn/vuepress-blog2/note/node-js/current-path.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/note/node-js/current-path.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">__dirname、__filename 和 process.cwd() 三者的区别</source>
      <pubDate>Tue, 10 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="dirname、-filename-和-process-cwd-三者的区别" tabindex="-1"> <code>__dirname</code>、<code>__filename</code> 和 <code>process.cwd()</code> 三者的区别</h1>
<ol>
<li>
<p><code>process.cwd()</code> 方法返回 Node.js 进程当前工作的目录</p>
<p>例: 我在 <code>F:\自己的文件\自己在网上学习的知识点\node学习\node-API\process</code> 这个文件加下面创建了一个 test.js 在该 js 文件中写下下面的代码，然后右键 <code>run test.js</code></p>
<div><pre><code><span>const</span> cwd <span>=</span> process<span>.</span><span>cwd</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>cwd<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>输出如下 <code>F:\自己的文件\自己在网上学习的知识点\node学习\node-API\process</code></p>
</li>
<li>
<p><code>__dirname</code> 是 Node.js 的一个全局变量，获得当前文件所在目录的完整目录名</p>
<p>还在上面的 js 文件中输入一下代码</p>
<div><pre><code>console<span>.</span><span>log</span><span>(</span>__dirname<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>输出如下 <code>F:\自己的文件\自己在网上学习的知识点\node学习\node-API\process</code></p>
<p>现在一看感觉上面两个方法是一样的，其实不是。node.js 进程当前工作的目录有可能不是该文件所在目录的完整目录。例如: 我用 <code>node webpack ..</code> 打包了一个应用程序，
我用这个应用程序可以生产出一套完整的页面架构，在应用程序的配置文件中 console.log(cwd)
在完整的这个页面架构中执行启动这个项目的命令，则对应的 cwd 就是当前项目所在的绝对路径,而不是应用程序的路径</p>
</li>
<li>
<p><code>__filename</code> 也是 Node.js 的全局变量 Node.js 中，在任何模块文件内部，可以使用 <code>__filename</code> 变量获取当前模块文件的带有完整绝对路径的文件名</p>
</li>
</ol>
<div><pre><code>console<span>.</span><span>log</span><span>(</span>__filename<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>输出 <code>F:\自己的文件\自己在网上学习的知识点\node 学习\node-API\process\test.js</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>GIT指令</title>
      <link>https://songjun520.cn/vuepress-blog2/other/GIT/git.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/other/GIT/git.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">GIT指令</source>
      <description>GIT
git指令操作
应有尽有
let’s go!
......

</description>
      <category>GIT</category>
      <pubDate>Fri, 07 Aug 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>GIT</p>
<p>git指令操作<br>
应有尽有<br>
let’s go!<br>
......</p>
</div>

<h2 id="初始化git流程" tabindex="-1"> 初始化git流程</h2>
<div><pre><code><span>git</span> init
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="添加文件" tabindex="-1"> 添加文件</h2>
<div><pre><code><span>git</span> <span>add</span> <span>.</span>  
<span># 添加文件,git add 文件路径(单个文件方式)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="提交注释" tabindex="-1"> 提交注释</h2>
<div><pre><code><span>git</span> commit -m <span>"sk"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="设置远程主机" tabindex="-1"> 设置远程主机</h2>
<div><pre><code><span>git</span> remote <span>add</span> origin https://git.coding.net/QQ15994206180/WordPress.git
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="推送到远程主机" tabindex="-1"> 推送到远程主机</h2>
<div><pre><code><span>git</span> push -u origin master
<span># 推送到远程主机,如果出现![rejected],说明初次使用git仓库,远程仓库与本地仓库不一致,需拉一下,使用命令git pull --rebase origin master(此命令前提是本地新建仓库应为空仓库),在推送就OK了.下次直接使用git push就OK了.</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="本地仓库关联远程分支" tabindex="-1"> 本地仓库关联远程分支</h2>
<div><pre><code>$ <span>git</span> branch --set-upstream-to<span>=</span>origin/master master
<span># 本地仓库关联远程分支（就可以直接使用Git pull,Git push等指令）</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="修改远程地址" tabindex="-1"> 修改远程地址</h2>
<div><pre><code><span>git</span> remote set-url origin https://e.coding.net/QQ15994206180/blog.git
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="分支匹配" tabindex="-1"> 分支匹配</h2>
<div><pre><code><span>git</span> config --global push.default matching
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="git全局name-email修改" tabindex="-1"> git全局name,email修改</h2>
<div><pre><code><span>git</span> credential-manager uninstall
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="配置用户名指令" tabindex="-1"> 配置用户名指令</h2>
<div><pre><code><span>git</span> config --global user.name 用户名
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="配置邮箱指令" tabindex="-1"> 配置邮箱指令</h2>
<div><pre><code><span>git</span> config --global user.email 邮箱地址
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="查看配置的用户名和邮箱" tabindex="-1"> 查看配置的用户名和邮箱</h2>
<div><pre><code><span>git</span> config --list
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="查看指定配置项的值" tabindex="-1"> 查看指定配置项的值</h2>
<div><pre><code><span>git</span> config user.name

<span>git</span> config user.email
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="git-编辑模式退出" tabindex="-1"> git 编辑模式退出</h2>
<div><pre><code><span>":wq+enter键"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="撤回操作" tabindex="-1"> 撤回操作</h2>
<div><pre><code><span>git</span> reset
<span># 撤回git add .操作</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="查看所有分支的所有操作记录" tabindex="-1"> 查看所有分支的所有操作记录</h2>
<div><pre><code><span>git</span> reflog
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="根据版本号撤回版本" tabindex="-1"> 根据版本号撤回版本</h2>
<div><pre><code><span>git</span> reset --hard <span>"版本号"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="撤销本地版本修改" tabindex="-1"> 撤销本地版本修改</h2>
<div><pre><code><span>git</span> checkout <span>.</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="创建分支" tabindex="-1"> 创建分支</h2>
<div><pre><code><span>git</span> branch sk
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="切换分支" tabindex="-1"> 切换分支</h2>
<div><pre><code><span>git</span> checkout sk

<span>git</span> checkout -b sk
<span># 创建sk分支,并切换到sk分支</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="记住用户名和密码" tabindex="-1"> 记住用户名和密码</h2>
<div><pre><code><span># GIT之https或http方式设置记住用户名和密码的方法</span>

<span># 设置记住密码（默认15分钟）：</span>
<span>git</span> config --global credential.helper cache

<span># 如果想自己设置时间，可以这样做：</span>
<span>git</span> config credential.helper <span>'cache --timeout=3600'</span>
<span># 这样就设置一个小时之后失效</span>

<span># 长期存储密码：</span>
<span>git</span> config --global credential.helper store

<span># 增加远程地址的时候带上密码也是可以的。(推荐)</span>
http://yourname:password@git.oschina.net/name/project.git
<span># 补充：使用客户端也可以存储密码的。</span>

<span># 如果你正在使用ssh而且想体验https带来的高速，那么你可以这样做： 切换到项目目录下 ：</span>
<span>cd</span> projectfile/
<span># 移除远程ssh方式的仓库地址</span>
<span>git</span> remote <span>rm</span> origin

<span># 增加https远程仓库地址</span>
<span>git</span> remote <span>add</span> origin https://yourname:password@git.oschina.net/name/project.git
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="查看操作" tabindex="-1"> 查看操作</h2>
<div><pre><code><span># 没提交之前，查看更改内容</span>
<span>git</span> <span>diff</span>
<span># 查看所有</span>

<span>git</span> <span>diff</span> 文件名
<span># 单个文件</span>

<span># 查看提交记录</span>

<span>git</span> log <span>git</span> log <span>&lt;</span>file<span>></span> 
<span># 查看该文件每次提交记录</span>

<span>git</span> log -p <span>&lt;</span>file<span>></span>
<span># 查看每次详细修改内容的diff</span>

<span>git</span> log -p -2 
<span># 查看最近两次详细修改内容的diff</span>

<span>git</span> log --stat 
<span># 查看提交统计信息</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>git push origin master和git push有什么区别？</p>
<ul>
<li>master是主分支，还可以建一些其他的分支用于开发。</li>
<li>git push origin master的意思就是上传本地当前分支代码到master分支。git push是上传本地所有分支代码到远程对应的分支上。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>CSS</title>
      <link>https://songjun520.cn/vuepress-blog2/other/html5/CSS.html</link>
      <guid>https://songjun520.cn/vuepress-blog2/other/html5/CSS.html</guid>
      <source url="https://songjun520.cn/vuepress-blog2/rss.xml">CSS</source>
      <description>CSS
按钮边款特效
字体显示控制
重置样式
......

</description>
      <category>CSS</category>
      <pubDate>Fri, 07 Aug 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>CSS</p>
<p>按钮边款特效<br>
字体显示控制<br>
重置样式<br>
......</p>
</div>

<h2 id="css特效" tabindex="-1"> CSS特效</h2>
<p>按钮边款特效</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>title</span><span>></span></span>css hover<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>*</span> <span>{</span>
      <span>margin</span><span>:</span> 0<span>;</span>
      <span>padding</span><span>:</span> 0<span>;</span>
    <span>}</span>

    <span>.container</span> <span>{</span>
      <span>width</span><span>:</span> 100%<span>;</span>
      <span>height</span><span>:</span> 100vh<span>;</span>
      <span>display</span><span>:</span> flex<span>;</span>
      <span>flex-direction</span><span>:</span> column<span>;</span>
      <span>justify-content</span><span>:</span> center<span>;</span>
      <span>align-items</span><span>:</span> center<span>;</span>
      <span>background-color</span><span>:</span> #000<span>;</span>
    <span>}</span>

    <span>a</span> <span>{</span>
      <span>position</span><span>:</span> relative<span>;</span>
      <span>width</span><span>:</span> 100px<span>;</span>
      <span>height</span><span>:</span> 60px<span>;</span>
      <span>text-align</span><span>:</span> center<span>;</span>
      <span>line-height</span><span>:</span> 60px<span>;</span>
      <span>margin</span><span>:</span> 45px<span>;</span>
      <span>text-decoration</span><span>:</span> none<span>;</span>
      <span>color</span><span>:</span> aqua<span>;</span>
      <span>font-size</span><span>:</span> 20px<span>;</span>
      <span>padding</span><span>:</span> 0 20px<span>;</span>
      <span>text-transform</span><span>:</span> uppercase<span>;</span>
      <span>transition</span><span>:</span> 0.5s<span>;</span>
      <span>overflow</span><span>:</span> hidden<span>;</span>
      <span>-webkit-box-reflect</span><span>:</span> below 1px <span>linear-gradient</span><span>(</span>transparent<span>,</span> #1113<span>)</span><span>;</span>
    <span>}</span>

    <span>a::before</span> <span>{</span>
      <span>content</span><span>:</span> <span>''</span><span>;</span>
      <span>position</span><span>:</span> absolute<span>;</span>
      <span>top</span><span>:</span> 0<span>;</span>
      <span>left</span><span>:</span> 0<span>;</span>
      <span>width</span><span>:</span> 20px<span>;</span>
      <span>height</span><span>:</span> 20px<span>;</span>
      <span>border-top</span><span>:</span> 2px solid aqua<span>;</span>
      <span>border-left</span><span>:</span> 2px solid aqua<span>;</span>
      <span>transition</span><span>:</span> 0.5s<span>;</span>
      <span>transition-delay</span><span>:</span> 0.5s<span>;</span>
    <span>}</span>

    <span>a::after</span> <span>{</span>
      <span>content</span><span>:</span> <span>''</span><span>;</span>
      <span>position</span><span>:</span> absolute<span>;</span>
      <span>bottom</span><span>:</span> 0<span>;</span>
      <span>right</span><span>:</span> 0<span>;</span>
      <span>width</span><span>:</span> 20px<span>;</span>
      <span>height</span><span>:</span> 20px<span>;</span>
      <span>border-bottom</span><span>:</span> 2px solid aqua<span>;</span>
      <span>border-right</span><span>:</span> 2px solid aqua<span>;</span>
      <span>transition</span><span>:</span> 0.5s<span>;</span>
      <span>transition-delay</span><span>:</span> 0.5s<span>;</span>
    <span>}</span>

    <span>a:hover::before,
    a:hover::after</span> <span>{</span>
      <span>width</span><span>:</span> 100%<span>;</span>
      <span>height</span><span>:</span> 100%<span>;</span>
      <span>transition-delay</span><span>:</span> 0s<span>;</span>
    <span>}</span>

    <span>a:hover</span> <span>{</span>
      <span>background-color</span><span>:</span> aqua<span>;</span>
      <span>color</span><span>:</span> #000<span>;</span>
      <span>box-shadow</span><span>:</span> 0 0 50px #21ebff<span>;</span>
      <span>transition-delay</span><span>:</span> 0.3s<span>;</span>
    <span>}</span>

    <span>a:nth-child(1)</span> <span>{</span>
      <span>filter</span><span>:</span> <span>hue-rotate</span><span>(</span>150deg<span>)</span><span>;</span>
    <span>}</span>

    <span>a:nth-child(3)</span> <span>{</span>
      <span>filter</span><span>:</span> <span>hue-rotate</span><span>(</span>270deg<span>)</span><span>;</span>
    <span>}</span>

    <span>a:nth-child(4)</span> <span>{</span>
      <span>filter</span><span>:</span> <span>hue-rotate</span><span>(</span>400deg<span>)</span><span>;</span>
    <span>}</span>

    <span>a:nth-child(5)</span> <span>{</span>
      <span>filter</span><span>:</span> <span>hue-rotate</span><span>(</span>70deg<span>)</span><span>;</span>
    <span>}</span>
  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>button1<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>button2<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>button3<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>button4<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>button5<span><span><span>&lt;/</span>a</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>效果展示</li>
</ul>
<div>
  <img src="/assets/img/pig.png" alt="">
</div>
<h2 id="字体显示控制" tabindex="-1"> 字体显示控制</h2>
<ul>
<li>显示一行</li>
</ul>
<div><pre><code><span>/* 控制显示一行，多余部分...显示，添加width属性，可以控制单行宽度 */</span>
<span>overflow</span><span>:</span> hidden<span>;</span>  //文字溢出隐藏
<span>text-overflow</span><span>:</span> ellipsis<span>;</span>  //文字超出部分用省略号代替
<span>white-space</span><span>:</span> nowrap<span>;</span>  //文字不换行
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>控制显示多行</li>
</ul>
<div><pre><code><span>/**适用范围：因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；**/</span>
<span>display</span><span>:</span> -webkit-box<span>;</span> //将对象作为弹性伸缩盒子模型显示
<span>-webkit-box-orient</span><span>:</span> vertical<span>;</span> //设置或检索伸缩盒对象的子元素的排列方式
<span>-webkit-line-clamp</span><span>:</span> 3<span>;</span>  //一个块元素显示的文本的行数
<span>overflow</span><span>:</span> hidden<span>;</span> //溢出隐藏
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>控制显示多行(利用伪类after)</li>
</ul>
<div><pre><code><span>p</span><span>{</span><span>position</span><span>:</span> relative<span>;</span> <span>line-height</span><span>:</span> 20px<span>;</span> <span>max-height</span><span>:</span> 40px<span>;</span><span>overflow</span><span>:</span> hidden<span>;</span><span>}</span>
<span>p::after</span><span>{</span><span>content</span><span>:</span> <span>"..."</span><span>;</span> <span>position</span><span>:</span> absolute<span>;</span> <span>bottom</span><span>:</span> 0<span>;</span> <span>right</span><span>:</span> 0<span>;</span> <span>padding-left</span><span>:</span> 40px<span>;</span>
<span>background</span><span>:</span> <span>-webkit-linear-gradient</span><span>(</span>left<span>,</span> transparent<span>,</span> #fff 55%<span>)</span><span>;</span>
<span>background</span><span>:</span> <span>-o-linear-gradient</span><span>(</span>right<span>,</span> transparent<span>,</span> #fff 55%<span>)</span><span>;</span>
<span>background</span><span>:</span> <span>-moz-linear-gradient</span><span>(</span>right<span>,</span> transparent<span>,</span> #fff 55%<span>)</span><span>;</span>
<span>background</span><span>:</span> <span>linear-gradient</span><span>(</span>to right<span>,</span> transparent<span>,</span> #fff 55%<span>)</span><span>;</span>
<span>}</span>

<span>/* 1.将height设置为line-height的整数倍，防止超出的文字露出。 */</span>
<span>/* 2.给p::after添加渐变背景可避免文字只显示一半。 */</span>
<span>/* 3.由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：&lt;span>…&lt;span/>）；兼容ie8需要将::after替换成:after */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="重置样式" tabindex="-1"> 重置样式</h2>
<ul>
<li>搜狐css初始化</li>
</ul>
<div><pre><code><span>/* 搜狐 */</span>
<span>body</span><span>{</span><span>font-family</span><span>:</span><span>"宋体"</span><span>,</span><span>"Arial Narrow"</span><span>,</span>HELVETICA<span>;</span><span>text-align</span><span>:</span>center<span>;</span><span>margin</span><span>:</span>0 auto<span>;</span><span>padding</span><span>:</span>0<span>;</span><span>background</span><span>:</span>#FFF<span>;</span><span>font-size</span><span>:</span>12px<span>;</span><span>color</span><span>:</span>#333<span>;</span><span>}</span>
<span>div,form,ul,ol,li,span,p</span><span>{</span><span>margin</span><span>:</span>0<span>;</span><span>padding</span><span>:</span>0<span>;</span><span>border</span><span>:</span>0<span>;</span><span>}</span>
<span>img,a img</span><span>{</span><span>border</span><span>:</span>0<span>;</span><span>margin</span><span>:</span>0<span>;</span><span>padding</span><span>:</span>0<span>;</span><span>}</span>
<span>h1,h2,h3,h4,h5,h6</span><span>{</span><span>margin</span><span>:</span>0<span>;</span><span>padding</span><span>:</span>0<span>;</span><span>font-size</span><span>:</span>12px<span>;</span><span>font-weight</span><span>:</span>normal<span>;</span><span>}</span>
<span>ul,ol,li</span><span>{</span><span>list-style</span><span>:</span>none<span>}</span>
<span>table,td,input</span><span>{</span><span>font-size</span><span>:</span>12px<span>;</span><span>padding</span><span>:</span>0<span>}</span>
<span>a</span><span>{</span><span>outline-style</span><span>:</span>none<span>;</span><span>color</span><span>:</span>#333<span>;</span><span>text-decoration</span><span>:</span>none<span>}</span>
<span>a:hover</span><span>{</span><span>color</span><span>:</span>#c00<span>;</span><span>text-decoration</span><span>:</span>underline<span>;</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>新浪css初始化</li>
</ul>
<div><pre><code><span>/* 初始化CSS */</span>
<span>html, body, ul, li, ol, dl, dd, dt, p, h1, h2, h3, h4, h5, h6, form, fieldset, legend, img</span> <span>{</span> <span>margin</span><span>:</span>0<span>;</span> <span>padding</span><span>:</span>0<span>;</span> <span>}</span>
<span>fieldset, img</span> <span>{</span> <span>border</span><span>:</span>none<span>;</span> <span>}</span>
<span>img</span><span>{</span><span>display</span><span>:</span> block<span>;</span><span>}</span>
<span>address, caption, cite, code, dfn, th, var</span> <span>{</span> <span>font-style</span><span>:</span>normal<span>;</span> <span>font-weight</span><span>:</span>normal<span>;</span> <span>}</span>
<span>ul, ol</span> <span>{</span> <span>list-style</span><span>:</span>none<span>;</span> <span>}</span>
<span>input</span> <span>{</span> <span>padding-top</span><span>:</span>0<span>;</span> <span>padding-bottom</span><span>:</span>0<span>;</span> <span>font-family</span><span>:</span> <span>"SimSun"</span><span>,</span><span>"宋体"</span><span>;</span><span>}</span>
<span>input::-moz-focus-inner</span> <span>{</span> <span>border</span><span>:</span>none<span>;</span> <span>padding</span><span>:</span>0<span>;</span> <span>}</span>
<span>select, input</span> <span>{</span> <span>vertical-align</span><span>:</span>middle<span>;</span> <span>}</span>
<span>select, input, textarea</span> <span>{</span> <span>font-size</span><span>:</span>12px<span>;</span> <span>margin</span><span>:</span>0<span>;</span> <span>}</span>
<span>input[type="text"], input[type="password"], textarea</span> <span>{</span> <span>outline-style</span><span>:</span>none<span>;</span> <span>-webkit-appearance</span><span>:</span>none<span>;</span> <span>}</span>
<span>table</span> <span>{</span> <span>border-collapse</span><span>:</span>collapse<span>;</span> <span>}</span>
<span>body</span> <span>{</span> <span>color</span><span>:</span>#333<span>;</span> <span>padding</span><span>:</span>5px 0<span>;</span> <span>font</span><span>:</span>12px/20px <span>"SimSun"</span><span>,</span><span>"宋体"</span><span>,</span><span>"Arial Narrow"</span><span>,</span>HELVETICA<span>;</span> <span>background</span><span>:</span>#fff<span>;</span><span>/* overflow-y:scroll;*/</span> <span>}</span>
<span>a</span> <span>{</span> <span>color</span><span>:</span>#666<span>;</span> <span>text-decoration</span><span>:</span>none<span>;</span> <span>}</span>
<span>a:visited</span> <span>{</span> <span>color</span><span>:</span>#666<span>;</span> <span>}</span>
<span>a:hover, a:active, a:focus</span> <span>{</span> <span>color</span><span>:</span>#ff8400<span>;</span> <span>text-decoration</span><span>:</span>underline<span>;</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>腾讯css初始化</li>
</ul>
<div><pre><code><span>body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select</span><span>{</span><span>margin</span><span>:</span>0<span>;</span><span>padding</span><span>:</span>0<span>}</span>
<span>body</span><span>{</span><span>font</span><span>:</span>12px <span>"宋体"</span><span>,</span><span>"Arial Narrow"</span><span>,</span>HELVETICA<span>;</span><span>background</span><span>:</span>#fff<span>;</span><span>-webkit-text-size-adjust</span><span>:</span>100%<span>}</span>
<span>a</span><span>{</span><span>color</span><span>:</span>#172c45<span>;</span><span>text-decoration</span><span>:</span>none<span>}</span>
<span>a:hover</span><span>{</span><span>color</span><span>:</span>#cd0200<span>;</span><span>text-decoration</span><span>:</span>underline<span>}</span>
<span>em</span><span>{</span><span>font-style</span><span>:</span>normal<span>}</span>
<span>li</span><span>{</span><span>list-style</span><span>:</span>none<span>}</span>
<span>img</span><span>{</span><span>border</span><span>:</span>0<span>;</span><span>vertical-align</span><span>:</span>middle<span>}</span>
<span>table</span><span>{</span><span>border-collapse</span><span>:</span>collapse<span>;</span><span>border-spacing</span><span>:</span>0<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>网易css初始化</li>
</ul>
<div><pre><code><span>html</span> <span>{</span><span>overflow-y</span><span>:</span>scroll<span>;</span><span>}</span>
<span>body</span> <span>{</span><span>margin</span><span>:</span>0<span>;</span> <span>padding</span><span>:</span>0<span>;</span> <span>font</span><span>:</span>12px/1.5 \5b8b\4f53<span>,</span>Arial<span>,</span>sans-serif<span>;</span><span>/*background:#ffffff;*/</span><span>}</span>
<span>div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p</span><span>{</span><span>padding</span><span>:</span>0<span>;</span> <span>margin</span><span>:</span>0<span>;</span><span>}</span>
<span>table,td,tr,th</span><span>{</span><span>font-size</span><span>:</span>12px<span>;</span><span>}</span>
<span>ol,ul</span> <span>{</span><span>list-style</span><span>:</span>none<span>;</span><span>}</span>
<span>li</span><span>{</span><span>list-style-type</span><span>:</span>none<span>;</span><span>}</span>
<span>img</span><span>{</span><span>vertical-align</span><span>:</span>top<span>;</span><span>border</span><span>:</span>0<span>;</span><span>}</span>
<span>h1,h2,h3,h4,h5,h6</span><span>{</span><span>font-size</span><span>:</span>inherit<span>;</span> <span>font-weight</span><span>:</span>normal<span>;</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>淘宝css初始化</li>
</ul>
<div><pre><code><span>body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td</span> <span>{</span> <span>margin</span><span>:</span>0<span>;</span> <span>padding</span><span>:</span>0<span>;</span> <span>}</span>  
<span>body, button, input, select, textarea</span> <span>{</span> <span>font</span><span>:</span>12px/1.5tahoma<span>,</span> arial<span>,</span> \5b8b\4f53<span>;</span> <span>}</span>  
<span>h1, h2, h3, h4, h5, h6</span><span>{</span> <span>font-size</span><span>:</span>100%<span>;</span> <span>}</span>  
<span>address, cite, dfn, em, var</span> <span>{</span> <span>font-style</span><span>:</span>normal<span>;</span> <span>}</span>  
<span>code, kbd, pre, samp</span> <span>{</span> <span>font-family</span><span>:</span>couriernew<span>,</span> courier<span>,</span> monospace<span>;</span> <span>}</span>  
<span>small</span><span>{</span> <span>font-size</span><span>:</span>12px<span>;</span> <span>}</span>  
<span>ul, ol</span> <span>{</span> <span>list-style</span><span>:</span>none<span>;</span> <span>}</span>  
<span>a</span> <span>{</span> <span>text-decoration</span><span>:</span>none<span>;</span> <span>}</span>  
<span>a:hover</span> <span>{</span> <span>text-decoration</span><span>:</span>underline<span>;</span> <span>}</span>  
<span>sup</span> <span>{</span> <span>vertical-align</span><span>:</span>text-top<span>;</span> <span>}</span>  
<span>sub</span><span>{</span> <span>vertical-align</span><span>:</span>text-bottom<span>;</span> <span>}</span>  
<span>legend</span> <span>{</span> <span>color</span><span>:</span>#000<span>;</span> <span>}</span>  
<span>fieldset, img</span> <span>{</span> <span>border</span><span>:</span>0<span>;</span> <span>}</span>  
<span>button, input, select, textarea</span> <span>{</span> <span>font-size</span><span>:</span>100%<span>;</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
  </channel>
</rss>